// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                      String    @id @default(uuid())
  name                    String?
  username                String    @unique
  email                   String    @unique
  password                String
  saltPassword            String
  tokenVersion            Int?
  otp                     String?
  otpExpiry               DateTime?
  bio                     String?
  dateOfBirth             DateTime
  joinDate                DateTime  @default(now())
  verified                Boolean   @default(false)
  address                 String?
  website                 String?
  protectedAccount        Boolean   @default(false)
  profilePhoto            String?
  cover                   String?
  isEmailVerified         Boolean   @default(false)
  tfaVerifed              Boolean   @default(false)
  loginCodes              String?
  loginCodesSet           Boolean   @default(false)
  unseenChatCount         Int       @default(0)
  unseenNotificationCount Int       @default(0)

  messages              Message[]
  tweet                 Tweet[]
  followers             Follow[]        @relation("UserFollowers")
  followings            Follow[]        @relation("UserFollowings")
  mentioner             Mention[]       @relation("Mentioner")
  mentioned             Mention[]       @relation("Mentioned")
  retweets              Retweet[]
  tweetLikes            TweetLike[]
  tweetBookmark         TweetBookmark[]
  chatUsers             ChatUser[]
  muters                Mute[]          @relation("Muter")
  muted                 Mute[]          @relation("Muted")
  blockers              Block[]         @relation("Blocker")
  blocked               Block[]         @relation("Blocked")
  notification          Notification[]  @relation("User")
  notificationWithActor Notification[]  @relation("Actor")
  oldPassword           OldPassword[]
  deviceRecord          DeviceRecord[]
  OAuthAccount          OAuthAccount[]

  @@map("users")
}

model OldPassword {
  id       String @id @default(uuid())
  userId   String
  password String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("oldPasswords")
}

model Session {
  jti          String    @id
  userId       String
  isActive     Boolean   @default(true)
  issuedAt     DateTime  @default(now())
  deviceInfoId String?
  expire_at    DateTime?

  @@map("sessions")
}

model DeviceRecord {
  id        String    @id @default(uuid())
  city      String?
  region    String?
  country   String?
  locale    String?
  lat       Float?
  lon       Float?
  zipcode   String?
  lastLogin DateTime?
  browser   String?
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("device_record")
}

model OAuthAccount {
  id         String @id @default(uuid())
  provider   String
  providerId String
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Tweet {
  id           String       @id @default(uuid())
  userId       String
  content      String       @db.Text
  createdAt    DateTime     @default(now())
  likesCount   Int          @default(0)
  retweetCount Int          @default(0)
  repliesCount Int          @default(0)
  quotesCount  Int          @default(0)
  replyControl ReplyControl @default(EVERYONE)
  parentId     String?
  tweetType    TweetType

  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent        Tweet?          @relation("parentTweets", fields: [parentId], references: [id], onDelete: Cascade)
  parentTweet   Tweet[]         @relation("parentTweets")
  hashtags      TweetHash[]
  tweetSummary  TweetSummary?
  mention       Mention[]
  retweets      Retweet[]
  tweetLikes    TweetLike[]
  tweetBookmark TweetBookmark[]
  tweetMedia    TweetMedia[]
  Notification  Notification[]

  @@index([userId, createdAt])
  @@map("tweets")
}

model Hash {
  id       String @id @default(uuid())
  tag_text String @unique

  tweets TweetHash[]

  @@map("hashes")
}

model TweetHash {
  tweetId String @default(uuid())
  hashId  String @default(uuid())

  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)
  hash  Hash  @relation(fields: [hashId], references: [id], onDelete: Cascade)

  @@id([tweetId, hashId])
  @@map("tweetHashes")
}

model Message {
  id        String        @id @default(uuid())
  chatId    String
  userId    String
  content   String        @db.Text
  createdAt DateTime      @default(now())
  status    MessageStatus @default(PENDING)

  chat         Chat           @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  messageMedia MessageMedia[]

  @@index([chatId, createdAt])
  @@map("messages")
}

model Chat {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  DMChat    Boolean

  messages  Message[]
  chatGroup ChatGroup[]
  chatUsers ChatUser[]

  @@map("chats")
}

model ChatGroup {
  name        String?
  description String?
  photo       String?
  chatId      String  @id

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@map("chatGroups")
}

model Notification {
  id        String           @id @default(uuid())
  type      NotificationType
  content   String
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  userId    String
  tweetId   String?
  actorId   String?

  user  User   @relation("User", fields: [userId], references: [id], onDelete: Cascade)
  tweet Tweet? @relation(fields: [tweetId], references: [id], onDelete: Cascade)
  actor User?  @relation("Actor", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@map("notifications")
}

model Media {
  id   String    @id @default(uuid())
  name String
  url  String
  type MediaType
  size Int?

  tweetMedia   TweetMedia[]
  messageMedia MessageMedia[]

  @@map("medias")
}

model TweetMedia {
  tweetId String
  mediaId String

  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)
  media Media @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@id([tweetId, mediaId])
}

model MessageMedia {
  messageId String
  mediaId   String

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  media   Media   @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@id([messageId, mediaId])
}

model TweetSummary {
  id      String @id @default(uuid())
  tweetId String @unique
  summary String

  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)
}

model Follow {
  followerId  String
  followingId String
  status      FollowStatus @default(ACCEPTED)

  follower  User @relation("UserFollowings", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@id([followerId, followingId])
}

model Mute {
  mutedId String
  muterId String

  muter User @relation("Muter", fields: [muterId], references: [id], onDelete: Cascade)
  muted User @relation("Muted", fields: [mutedId], references: [id], onDelete: Cascade)

  @@id([muterId, mutedId])
}

model Block {
  blockedId String
  blockerId String

  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@id([blockerId, blockedId])
}

model Mention {
  tweetId     String
  mentionerId String
  mentionedId String

  mentioner User  @relation("Mentioner", fields: [mentionerId], references: [id], onDelete: Cascade)
  mentioned User  @relation("Mentioned", fields: [mentionedId], references: [id], onDelete: Cascade)
  tweet     Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@id([tweetId, mentionerId, mentionedId])
}

model Retweet {
  userId  String
  tweetId String

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@id([userId, tweetId])
}

model TweetLike {
  tweetId String
  userId  String

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)

  @@id([userId, tweetId])
}

model TweetBookmark {
  id      String @id @default(uuid())
  userId  String
  tweetId String

  tweet Tweet @relation(fields: [tweetId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("tweetbookmarks")
}

model ChatUser {
  id     String @id @default(uuid())
  userId String
  chatId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@unique([userId, chatId])
  @@map("chatusers")
}

enum ReplyControl {
  EVERYONE
  FOLLOWINGS
  VERIFIED
  MENTIONED
}

enum TweetType {
  TWEET
  REPLY
  QUOTE
}

enum MessageStatus {
  PENDING
  SENT
  READ
}

enum NotificationType {
  LIKE
  RETWEET
  REPLY
  QUOTE
  FOLLOW
  RequestToFollow
  AcceptedFollow
  MENTION
}

enum MediaType {
  IMAGE
  VIDEO
  GIF
}

enum FollowStatus {
  PENDING
  ACCEPTED
}
