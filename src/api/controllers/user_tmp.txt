import dotenv from "dotenv";
dotenv.config();
// Alias for utility functions - must be compatible with your utils.ts/js
import * as utils from "../../application/utils/tweets/utils";
import jwt, { JwtPayload } from "jsonwebtoken";
import bcrypt from "bcryptjs";
import { v4 as uuidv4 } from "uuid";
import zxcvbn from "zxcvbn";
import qrcode from "qrcode";
import speakeasy from "speakeasy";
// import nodemailer from "nodemailer";
import { addNotification } from "./notificationController";
import  prisma  from "../../database";
import { redisClient } from "../../config/redis";
import fetch from "node-fetch";
import crypto from "crypto";
// Import Express types for request and response objects
import { Request, Response, NextFunction } from "express";
// --- Custom Type Definitions ---
import axios from 'axios';
import qs from 'querystring';
// Define the structure of the JWT payload used locally
interface LocalJwtPayload extends JwtPayload {
  Username?: string;
  username?: string;
  email: string;

  id: string;
  version: number;
  jti: string;
  devid: string| null;
}
type UUID = `${string}-${string}-${string}-${string}-${string}`;

// Define a minimal User type for database results
// In a real TS project, this would come from Prisma Client's generated types (e.g., import { User } from '@prisma/client')
interface PrismaUser {
    id: string;
    username: string;
    name: string;
    email: string;
  
    password: string;
    saltPassword: string;
   tokenVersion: number;
    tfaVerifed: boolean;
    loginCodesSet: boolean;
    loginCodes: string | null;
    dateOfBirth: Date;
    isEmailVerified: boolean;
    otp: string | null;
    // Add other properties defined in your Prisma schema
}

// --- Environment Variables (type assertions) ---

const JWT_SECRET: string = process.env.JWT_SECRET || "changeme";
const PEPPER: string = process.env.PEPPER || "";
const DOMAIN: string = process.env.DOMAIN || "localhost";
const CLIENT_DOMAIN: string = process.env.CLIENT_DOMAIN || "localhost";

// Local helper functions (unmodified)
function timingSafeEqual(a: string | Buffer | number | object, b: string | Buffer | number | object): boolean {
  try {
    const A: Buffer = Buffer.from(String(a));
    const B: Buffer = Buffer.from(String(b));
    if (A.length !== B.length) {
      return false;
    }
    return crypto.timingSafeEqual ? crypto.timingSafeEqual(A, B) : A.equals(B);
  } catch (e) {
    return false;
  }
}

function gen6(): string {
  return Math.floor(Math.random() * 1000000).toString().padStart(6, "0");
}

function generateJwt({ username, email, id ,expiresInSeconds, version, devid }: {
    username: string;
    email: string;
    id: string;
   
    expiresInSeconds: number | undefined;
    version: number | undefined;
    devid: string | null | undefined;
}): { token: string; jti: string; payload: LocalJwtPayload } {
  const jti: string = uuidv4();
  const now: number = Math.floor(Date.now() / 1000);
  const payload: LocalJwtPayload = {
    Username: username,
    email,
    
    id,
    exp: now + (expiresInSeconds || 900),
    iat: now,
    version: version || 0,
    jti,
    devid: devid || null,
  };
  const token: string = jwt.sign(payload, JWT_SECRET, { algorithm: "HS256" });
  return { token, jti, payload };
}

function validateJwt(token: string): { ok: boolean; payload?: LocalJwtPayload; err?: Error } {
  try {
    const payload: LocalJwtPayload = jwt.verify(token, JWT_SECRET) as LocalJwtPayload;
    return { ok: true, payload };
  } catch (err) {
    return { ok: false, err: err as Error };
  }
}

/* --------------------- Controller functions --------------------- */

export async function Create(req: Request, res: Response,next: NextFunction): Promise<Response | void> {
   console.log("Signup body jkahdjfhjksdhfjhsdjf");
  try {
    const input: any = req.body;
    console.log("Signup body:", input);
    if (!input || !input.email || !input.name||!input.dateOfBirth) {
      return next(new Error("missing required fields"));
    }
// ‚úÖ Check if email already exists in DB
const existingUser = await prisma.user.findUnique({
  where: { email: input.email },
});

if (existingUser) {

 next(new Error("Email already in use"))
 return;
}


const isWebClient = req.headers["x-client-type"] === "web";

  const exist: number = await redisClient.exists(`signup_captcha:passed:${input.email}`);
   if (!exist&&isWebClient){
    
return next(new Error("u must solve Captcha first"));
    }
else{
     await redisClient.del(`signup_captcha:passed:${input.email}`);
}
  // const passRes: string = await utils.ValidatePassword(input.password);
//     if (passRes !== "0") return next(new Error(passRes));


    // email basic validation
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input.email)) return next(new Error("invalid email"));

    const code: string = gen6();
    await redisClient.set(`Signup:code:${input.email}`, code, { EX: 15 * 60 });
console.log("signupcod saved",code);
    const message: string = `Subject: Verify Your Email Address üöÄ

Hello ${input.name},

Thank you for signing up to Artimesa! üéâ  
To complete your registration and verify your email address, please enter the verification code below:

üîê Your verification code: ${code}

This code will expire in 15 minutes. ‚è≥  
If you didn't sign up for this account, you can safely ignore this message.

Welcome aboard,  
‚Äî The Artemisa Team üõ°Ô∏è
`;
    // Use the imported SendEmailSmtp from utils
    utils.SendEmailSmtp(res, input.email, message).catch(console.error);

    await redisClient.set(`Signup:user:${input.email}`, JSON.stringify(input), { EX: 15 * 60 });

    const exists: number = await prisma.user.count({ where: { email: input.email, isEmailVerified: true } });
    if (exists === 0) {
      return utils.SendRes(res,{ message: "User registered successfully. Please verify your email to continue." });
    }
    return utils.SendRes(res, {message:"Email already verified"});
  } catch (err) {
  console.error("Create err:", err);
return next(err);
}
}

export async function SignupCaptcha(req: Request, res: Response,next: NextFunction): Promise<Response | void> {
  try {
    let email: string | undefined;
    const emailQuery = req.query.email;
    if (typeof emailQuery === "string") {
      email = emailQuery;
    } else if (Array.isArray(emailQuery) && typeof emailQuery[0] === "string") {
      email = emailQuery[0];
    } else {
      email = undefined;
    }
    if (typeof email !== 'string' || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return next(new Error("Email is Required"));
console.log("Redis connected?", redisClient.isOpen);
    await redisClient.set(`signup_captcha:passed:${email}`, "1", { EX: 15 * 60 });
    return utils.SendRes(res, { Message: "You passed the Captcha you can continue regster now " });
  } catch (err) {
    console.error("Captcha err:", err);
    return next(new Error("Captcha err:"));
  }
}
export async function Verify_signup_email(req: Request, res: Response,next: NextFunction): Promise<Response | void> {
  try {
    const { email, code } = req.body;
    if (!email || !code) return next(new Error("email and token required"));

    const stored: string | null = await redisClient.get(`Signup:code:${email}`);
    console.log("signupcod rerived", stored);
    if (!stored) return next(new Error("something went wrong:u must signup again"));

    if (stored !== code) return next(new Error("verifying email code is incorrect"));

    // ‚úÖ Mark verified but DO NOT create user yet
    const userJson: string | null = await redisClient.get(`Signup:user:${email}`);
    if (!userJson) return next(new Error("something went wrong"));

    const input: any = JSON.parse(userJson);

    // Save verified user temporarily for password setup
    await redisClient.set(`Signup:verified:${email}`, JSON.stringify(input), { EX: 15 * 60 });

    // Delete the verification code key to avoid reuse
    await redisClient.del(`Signup:code:${email}`);

    return utils.SendRes(res, { message: "Email verified successfully, please set your password." });
  } catch (err) {
    console.error("Verify_signup_email err:", err);
    return next(err);
  }
}
// export async function FinalizeSignup(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const { email, password } = req.body;
//     if (!email || !password) return next(new Error("email and password required"));

//     const userJson: string | null = await redisClient.get(`Signup:verified:${email}`);
//     if (!userJson) return next(new Error("you must verify your email first"));

//     const input: any = JSON.parse(userJson);

//     let username: string = input.name.toLowerCase().replace(/[^a-z0-9]/g, "");
//     if (!username) username = `user${Math.floor(Math.random() * 10000)}`;
//     const existing = await prisma.user.findUnique({ where: { username } });
//     if (existing) username = `${username}${Math.floor(Math.random() * 10000)}`;

//     const salt: string = crypto.randomBytes(16).toString("hex");
//     const hashed: string = await utils.HashPassword(password, salt);

//     let parsedDate: Date = new Date(input.dateOfBirth);
//     if (isNaN(parsedDate.getTime())) {
//       parsedDate = new Date("2001-11-03T00:00:00.000Z");
//     }

//     const created: PrismaUser = await prisma.user.create({
//       data: {
//         username,
//         name: input.name,
//         email: input.email,
      
//         password: hashed,
//         saltPassword: salt,
//         isEmailVerified: true,
//         dateOfBirth: parsedDate,
//       },
//     }) as unknown as PrismaUser;

//     await utils.AddPasswordHistory(hashed, created.id);
//     await redisClient.del(`Signup:verified:${email}`);

//     // ‚úÖ Send signup completion email
//     const completeMsg = `Subject: Welcome to Artimesa üéâ

// Hello ${created.name},

// Your registration is now complete! ‚úÖ  
// You can log in anytime using your email: ${created.email}

// We're thrilled to have you on board at Artimesa ‚Äî enjoy exploring our community! üåü

// If you didn't create this account, please contact our support team immediately.

// ‚Äî The Artimesa Team üõ°Ô∏è
// `;
//     await utils.SendEmailSmtp(res, created.email, completeMsg).catch(console.error);

//     return utils.SendRes(res, { message: "Signup complete. Welcome!", user: created });
//   } catch (err) {
//     console.error("FinalizeSignup err:", err);
//     return next(err);
//   }
// }
export async function FinalizeSignup(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, password } = req.body;
    if (!email || !password) return next(new Error("email and password required"));

    const userJson: string | null = await redisClient.get(`Signup:verified:${email}`);
    if (!userJson) return next(new Error("you must verify your email first"));

    const input: any = JSON.parse(userJson);

    let username: string = input.name.toLowerCase().replace(/[^a-z0-9]/g, "");
    if (!username) username = `user${Math.floor(Math.random() * 10000)}`;
    const existing = await prisma.user.findUnique({ where: { username } });
    if (existing) username = `${username}${Math.floor(Math.random() * 10000)}`;

    const salt: string = crypto.randomBytes(16).toString("hex");
    const hashed: string = await utils.HashPassword(password, salt);

    let parsedDate: Date = new Date(input.dateOfBirth);
    if (isNaN(parsedDate.getTime())) parsedDate = new Date("2001-11-03T00:00:00.000Z");

    const created: PrismaUser = await prisma.user.create({
      data: {
        username,
        name: input.name,
        email: input.email,
        password: hashed,
        saltPassword: salt,
        isEmailVerified: true,
        dateOfBirth: parsedDate,
      },
    }) as unknown as PrismaUser;

    await utils.AddPasswordHistory(hashed, created.id);
    await redisClient.del(`Signup:verified:${email}`);

    // üõ∞Ô∏è Step 1: Set device info (geo, browser, etc.)
    const { devid, deviceRecord } = await utils.SetDeviceInfo(req, res, email);

    // üõ°Ô∏è Step 2: Generate JWT access token (15 min expiry)
    const { token: accessToken, jti, payload } = await utils.GenerateJwt({
      username: created.username,
      email: created.email,
      id: created.id,
      role: "user",
      expiresInSeconds: 15 * 60,
      version: 0,
      devid,
    });

    // üîÅ Step 3: Generate refresh token (30 days)
    const { token: refreshToken } = await utils.GenerateJwt({
      username: created.username,
      email: created.email,
      id: created.id,
      role: "user",
      expiresInSeconds: 60 * 60 * 24 * 30,
      version: 0,
      devid,
    });

    // üíæ Step 4: Store refresh token in Redis (30 days)
    await redisClient.set(`refreshToken:${created.id}`, refreshToken, { EX: 60 * 60 * 24 * 30 });

    // üîê Step 5: Save active session (with device id)
    await utils.SetSession(req, created.id, jti);

    // üìß Step 6: Send welcome email
    const completeMsg = `Subject: Welcome to Artimesa üéâ

Hello ${created.name},

Your registration is now complete! ‚úÖ  
You can log in anytime using your email: ${created.email}

We're thrilled to have you on board at Artimesa ‚Äî enjoy exploring our community! üåü

If you didn't create this account, please contact our support team immediately.

‚Äî The Artimesa Team üõ°Ô∏è
`;
    await utils.SendEmailSmtp(res, created.email, completeMsg).catch(console.error);

    // üéØ Step 7: Return everything in the response
    return utils.SendRes(res, {
      message: "Signup complete. Welcome!",
      user: {
        id: created.id,
        username: created.username,
        name: created.name,
        email: created.email,
        dateOfBirth: created.dateOfBirth,
        isEmailVerified: created.isEmailVerified,
      },
      device: deviceRecord,
      tokens: {
        accessToken,
        refreshToken,
      },
    });
  } catch (err) {
    console.error("FinalizeSignup err:", err);
    return next(err);
  }
}

// export async function Verify_signup_email(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const { email, code } = req.body;
//     if (!email || !code) return next(new Error("email and token required"));

//     const stored: string | null = await redisClient.get(`Signup:code:${email}`);
// console.log("signupcod rerived",stored);
//     if (!stored) return next(new Error("something went wrong:u must signup again"));

//     if (stored !== code) return next(new Error("verifying email code is incorrect"));

//     // mark IsEmailVerified true in DB if exists (optional)
//     await prisma.user.updateMany({ where: { email }, data: { isEmailVerified: true } });

//     const userJson: string | null = await redisClient.get(`Signup:user:${email}`);
//     if (!userJson) return next(new Error("something went wrong"));

//     const input: any = JSON.parse(userJson);
//     let username: string = input.name.toLowerCase().replace(/[^a-z0-9]/g, "");
//     if (!username) username = `user${Math.floor(Math.random() * 10000)}`;
//     const existing = await prisma.user.findUnique({ where: { username } });
//     if (existing) username = `${username}${Math.floor(Math.random() * 10000)}`;
//     //const salt: string = crypto.randomBytes(16).toString("hex");
//     // Use utils.HashPassword
// //     const hashed: string = await utils.HashPassword(input.password, salt);
// console.log("here is dataofbirth",input.dateOfBirth);
// let parsedDate: Date = new Date(input.dateOfBirth);
// if (isNaN(parsedDate.getTime())) {
//   parsedDate = new Date("2001-11-03T00:00:00.000Z");
// }

//     const created: PrismaUser = await prisma.user.create({
//       data: {
//         username,
       
//         name: input.name,
//         email: input.email,
//         // role: "user",
      
//        // password: hashed,
//         //saltPassword: salt,
//         dateOfBirth: parsedDate,
//       },
//     }) as unknown as PrismaUser;
//     await utils.AddPasswordHistory(hashed, created.id);

//     utils.SendEmailSmtp(res, created.email, `Subject: Welcome to artimsia\n\nWelcome ${created.name}`).catch(console.error);

//     return utils.SendRes(res, { user: created });
//   } catch (err) {
//     console.error("Verify_signup_email err:", err);
//     return next(err);
//   }
// }

export async function Login(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, password } = req.body;
    if (!email || !password) return next(new Error("Missing email or password"));
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return next(new Error("Enter valid email"));

    const clientType = req.headers["x-client-type"] || "web";
    const stop = await utils.Attempts(res, email, clientType);
    if (stop) return;

    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (!user) {
      await utils.IncrAttempts(res, email);
      return next(new Error("Try again and enter your info correctly"));
    }

    const ok: boolean = await utils.CheckPass(password + user.saltPassword, user.password);
    if (!ok) {
      await utils.IncrAttempts(res, email);
      return next(new Error("Invalid credentials"));
    }

    await utils.RestAttempts(email);

    // Set device info
    const { devid, deviceRecord } = await utils.SetDeviceInfo(req, res, email);

    // Generate JWTs
    const accessObj = generateJwt({
      username: user.username,
      email,
      id: user.id,
      expiresInSeconds: 15 * 60,
      version: user.tokenVersion || 0,
      devid,
    });

    const refreshObj = generateJwt({
      username: user.username,
      email,
      id: user.id,
      expiresInSeconds: 7 * 24 * 60 * 60,
      version: user.tokenVersion || 0,
      devid,
    });

    res.cookie("refresh_token", refreshObj.token, {
      maxAge: 7 * 24 * 60 * 60 * 1000,
      httpOnly: true,
      secure: process.env.COOKIE_SECURE === "true",
      sameSite: "lax",
      domain: CLIENT_DOMAIN,
    });

    await utils.SetSession(req, user.id, refreshObj.jti);

    // --- EMAIL NOTIFICATION ---
    const ip = req.ip || req.headers["x-forwarded-for"] || "unknown";
    const location = await utils.Sendlocation(ip as string); // your helper to get location
    const emailMessage = `Hello ${user.username},

üöÄ Your account was just accessed!

üìç Location: ${location}
üíª Device info: ${deviceRecord || "unknown"}
üïí Time: ${new Date().toLocaleString()}

If this was not you, immediately change your password!
‚Äî The Artemisa Team`;

    utils.SendEmailSmtp(res, email, emailMessage).catch(console.error);

    // --- IN-APP / PUSH NOTIFICATION (like X) ---
    await addNotification(user.id as UUID, {
  title: "NEW LOGIN DETECTED",
  body: `Login from ${deviceRecord || "unknown device"} at ${location}`,
  actorId: user.id as UUID,
  
}, (err) => {
  if (err) return next(err);
});


    return utils.SendRes(res, {
      User: user,
      DeviceRecord: deviceRecord,
      Token: accessObj.token,
      Refresh_token: refreshObj.token,
      message: "Login successful, email & in-app notification sent"
    });

  } catch (err) {
    console.error("Login err:", err);
    return next(err);
  }
}



// export async function Verify_email(req: Request, res: Response): Promise<Response | void> {
//   try {
// const { email} = req.body;   
//     const {code}=req.body;
//     if (!email || !code) return next(new Error("email and code required"));

//     const stored: string | null = await redisClient.get(`Login:code:${email}`);
//     if (!stored) return next(new Error("something went wrong"));
//     if (stored !== code) return next(new Error("Enter Email verification code correctly"));

//     await redisClient.del(`Login:code:${email}`);
//     await redisClient.set(`Login:verified:${email}`, "1", { EX: 10 * 60 });

//     const userRow = await prisma.user.findFirst({
//       where: { email, OR: [{ tfaVerifed: true }, { loginCodesSet: true }] },
//     }) as PrismaUser | null;

//     if (userRow) {
//       return utils.SendRes(res, {message:"Enter your 2FA code to login OR login codes to enter"});
//     }

//     const userJson: string | null = await redisClient.get(`Login:user:${email}`);
//     if (!userJson) return next(new Error("something went wrong"));
//     const user: PrismaUser = JSON.parse(userJson);
// if (!user) return next(new Error("user not found"));
//     // Use utils.SetDeviceInfo
// console.log("User inside Verify_email:", user);

//     const {devid, deviceRecord} = await utils.SetDeviceInfo(req, res, email);

//     const accessObj = generateJwt({
//       username: user.username,
//       email,
//       id: user.id,
//      
//       expiresInSeconds: 15 * 60,
//       version: user.tokenVersion || 0,
//       devid,
//     });
//     const refreshObj = generateJwt({
//       username: user.username,
//       email,
//       id: user.id,
//      
//       expiresInSeconds: 7 * 24 * 60 * 60,
//       version: user.tokenVersion || 0,
//       devid,
//     });

//     res.cookie("refresh_token", refreshObj.token, {
//       maxAge: 7 * 24 * 60 * 60 * 1000,
//       httpOnly: true,
//       secure: process.env.COOKIE_SECURE === "true",
//       sameSite: "lax",
//       domain: CLIENT_DOMAIN,
//     });

//     // Use utils.SetSession
// console.log("here is it req",req);
// console.log("user",user);

//  await utils.SetSession(req, user.id, refreshObj.jti);
// console.log("Device Info:", { devid, deviceRecord });

//     return utils.SendRes(res, { User: user, DeviceRecord:deviceRecord ,Token: accessObj.token, Refresh_token: refreshObj.token });
//   } catch (err) {
//     console.error("Verify_email err:", err);
//     return next(err);
//   }
// }

export async function Refresh(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const refreshToken: string | undefined = req.cookies?.refresh_token;
    if (!refreshToken) return next(new Error("no refreshToken cookie has been set cannot renew seasion"));

    const validated = validateJwt(refreshToken);
    if (!validated.ok) return next(new Error("no valid refreshToken cookie has been set cannot renew seasion"));

    const payload: LocalJwtPayload = validated.payload as LocalJwtPayload;
    const username: string = payload.Username || payload.username || "";
    const email: string = payload.email;
    const id: string = payload.id;
    
    const version: number = payload.version || 0;

    // Use utils.SetDeviceInfo
    // NOTE: The return type of utils.SetDeviceInfo has changed to {devid, deviceRecord}
    // I'm preserving the original variable name 'devid' for compatibility with the original logic, 
    // but this might need adjustment if it caused a runtime error in JS.
    const { devid } = await utils.SetDeviceInfo(req, res, email);

    const newAccess = generateJwt({
      username,
      email,
      id,
     
      expiresInSeconds: 7 * 60,
      version,
      devid,
    });

    const jti: string = uuidv4();
    // Use utils.SetSession
   await utils.SetSession(req, id, jti);

    return utils.SendRes(res, { NewAcesstoken: newAccess.token });
  } catch (err) {
    console.error("Refresh err:", err);
    return next(err);
  }
}

export async function Logout(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const refreshToken: string | undefined = req.cookies?.refresh_token;
    if (!refreshToken) return next(new Error("refresh token expried u already logged out"));

    const validated = validateJwt(refreshToken);
    if (!validated.ok) return next(new Error("refreshToken invalid"));

    const header: string | undefined = req.get("Authorization");
    if (!header) return next(new Error("No Authorization Header"));
    let tokenString: string | null = header.startsWith("Bearer") ? header.slice(6).trim() : null;
    if (!tokenString) return next(new Error("Not valid token should start with Bearer"));
    tokenString = tokenString.replace(/^&\{/, "");

    const accessVal = validateJwt(tokenString);
    if (!accessVal.ok) return next(new Error("Not valid token signuture"));

    if (tokenString === refreshToken) return next(new Error("token and refreshToken cannot be the same"));

    const accessPayload: LocalJwtPayload = accessVal.payload as LocalJwtPayload;
    const userId: string | undefined = accessPayload.id ||(req as any).user?.id;
    const jti: string | null = accessPayload.jti || req.body?.jti || null;
    if (userId && jti) {
      await redisClient.del(`session:${userId}:${jti}`);
    }

    res.clearCookie("refresh_token", { domain: DOMAIN, path: "/" });
    return utils.SendRes(res, {message:"logged out"});
  } catch (err) {
    console.error("Logout err:", err);
    return next(err);
  }
}

export async function Captcha(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
   const emailQuery = req.query.email;
let email: string | undefined;
if (Array.isArray(emailQuery)) {
  email = typeof emailQuery[0] === "string" ? emailQuery[0] : undefined;
} else if (typeof emailQuery === "string") {
  email = emailQuery;
} else {
  email = undefined;
}
    if (typeof email !== 'string' || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return next(new Error("Email is Required"));
    await redisClient.set(`captcha:passed:${email}`, "1", { EX: 15 * 60 });
    return utils.SendRes(res, { Message: "You passed the Captcha you can login now " });
  } catch (err) {
    console.error("Captcha err:", err);
    return next(err);
  }
}

//  async function Create_2fA(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const email = (req as any).user?.email || req.body?.email;
//     console.log("req.user::",(req as any).user);
//     if (!email) return next(new Error("email required"));
//     const secret = speakeasy.generateSecret({ issuer: "SOAH", name: email });
//     await redisClient.set(`Login:2fa:${email}`, secret.base32);
//     await prisma.user.updateMany({ where: { email }, data: { otp: secret.base32 } });
//     const png: string = await qrcode.toDataURL(secret.otpauth_url || "", { width: 256 });
//  export   await prisma.user.updateMany({ where: { email }, data: { tfaVerifed: true } });
//     return utils.SendRes(res, { Email: email, Png: png, Secret: secret.base32 });
//   } catch (err) {
//     console.error("Create_2fA err:", err);
//     return next(err);
//   }
// }

// export async function Verify_2fA(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const email = (req as any).user?.email || req.body?.email;  
//     const code=req.body?.code;

//   console.log("code:",code);
//   console.log("email::",email);
//     if (!email || !code) return next(new Error("email & code required"));
//     const secret: string | null = await redisClient.get(`Login:2fa:${email}`);
// console.log("secret :",secret);
//     if (!secret) return next(new Error("something went wrong"));
//     const ok: boolean = speakeasy.totp.verify({ secret, encoding: "base32", token: code, window: 1 });
//     if (!ok) return next(new Error("Enter valid 2fA code"));
//     const userJson: string | null = await redisClient.get(`Login:user:${email}`);

//     if (!userJson) return next(new Error("something went wrong"));
//     const user: PrismaUser = JSON.parse(userJson);
// console.log("user :",user);
//     // Use utils.SetDeviceInfo
//     const { devid } = await utils.SetDeviceInfo(req, res, email);
//     const accessObj = generateJwt({ username: user.username, email, id: user.id, expiresInSeconds: 15 * 60, version: user.tokenVersion || 0, devid });
//     const refreshObj = generateJwt({ username: user.username, email, id: user.id, expiresInSeconds: 7 * 24 * 60 * 60, version: user.tokenVersion || 0, devid });
//     res.cookie("refresh_token", refreshObj.token, { maxAge: 7 * 24 * 60 * 60 * 1000, httpOnly: true, secure: process.env.COOKIE_SECURE === "true", sameSite: "lax", domain: CLIENT_DOMAIN });
//    
//     await utils.SetSession(req, user.id, refreshObj.jti);
//     return utils.SendRes(res, { User: user, Token: accessObj.token, Refresh_token: refreshObj.token });
//   } catch (err) {
//     console.error("Verify_2fA err:", err);
//     return next(err);
//   }
// }

// export async function GenerteLoginCodes(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const { email } = req.body;
//     if (!email) return next(new Error("email required"));
//     const codes: string[] = [];
//     for (let i: number = 0; i < 12; i++) codes.push(gen6());
//     const joined: string = codes.join(",");
//     const updated = await prisma.user.updateMany({ where: { email }, data: { loginCodes: joined, loginCodesSet: true } });
//     if (updated.count === 0) return next(new Error("something went wrong"));
//     const msg: string = `Hello [UserName],\n\nYour backup codes:\n${codes.join("\n")} \n ‚Äî The Artemisa Team`;
//     // Note: Original code passes "Backup Login Codes" as the third argument (subject), but utils.SendEmailSmtp expects the third arg to be the message text.
//     // I'm keeping the parameter count and passing the message text (`msg`) as the second message part.
//     utils.SendEmailSmtp(res, email, msg).catch(console.error);
//     return utils.SendRes(res, msg);
//   } catch (err) {
//     console.error("GenerteLoginCodes err:", err);
//     return next(err);
//   }
// }

// export async function VerifyLoginCode(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const { email, code } = req.body;
//     if (!email || !code) return next(new Error("email & code required"));
//     const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
//     if (!user) return next(new Error("something went error"));
//     const codes: string[] = (user.loginCodes || "").split(",").filter(Boolean);
//     let found: boolean = false;
//     const copy: string[] = [];
//     for (const c of codes) {
//       if (c === code) {
//         found = true;
//         continue;
//       }
//       copy.push(c);
//     }
//     if (!found) return next(new Error("Enter your Login_codes correctly"));
//     // Use utils.SetDeviceInfo
//     const { devid } = await utils.SetDeviceInfo(req, res, email);
//     const accessObj = generateJwt({ username: user.username, email, id: user.id,  expiresInSeconds: 15 * 60, version: user.tokenVersion || 0, devid });
//     const refreshObj = generateJwt({ username: user.username, email, id: user.id,  expiresInSeconds: 7 * 24 * 60 * 60, version: user.tokenVersion || 0, devid });
//     await prisma.user.updateMany({ where: { email }, data: { loginCodes: copy.join(",") } });
//     res.cookie("refresh_token", refreshObj.token, { maxAge: 7 * 24 * 60 * 60 * 1000, httpOnly: true, secure: process.env.COOKIE_SECURE === "true", sameSite: "lax", domain: CLIENT_DOMAIN });
//     // Use utils.SetSession
//     await utils.SetSession(req, user.id, refreshObj.jti);
//     return utils.SendRes(res, { User: user, Token: accessObj.token, Refresh_token: refreshObj.token });
//   } catch (err) {
//     console.error("VerifyLoginCode err:", err);
//     return next(err);
//   }
// }

export async function ForgetPassword(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email } = req.body;
    if (!email) return next(new Error("Email required"));

    if (await utils.ResetAttempts(res, email)) return;

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      await utils.IncrResetAttempts(res, email);
      return next(new Error("User not found"));
    }

    // Generate a 6-digit numeric code
    const code = Math.floor(100000 + Math.random() * 900000).toString();

    const message = `
Hi ${user.username},

You requested a password reset for your Artemisa account.

üîë Your password reset code is: ${code}

This code is valid for 15 minutes.

If you didn't request this change, please ignore this email or contact Artemisa support immediately.

‚Äî The Artemisa Team
`;

    // Store code in Redis
    await redisClient.set(`Reset:code:${email}`, code, { EX: 15 * 60 });
    try {
  await utils.SendEmailSmtp(res, email, message);
} catch (err) {
  next(err); // <- this will forward it to your error middleware
}


    return utils.SendRes(res, { message: "Reset code sent via email. Check your inbox!" });
  } catch (err) {
    console.error("ForgetPassword err:", err);
    return next(err);
  }
}

export async function ResetPassword(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, code, password } = req.body;
    if (!email || !code || !password) return next(new Error("Missing fields"));

    // Check code from Redis
    const stored: string | null = await redisClient.get(`Reset:code:${email}`);
    if (!stored) return next(new Error("Something went wrong"));
    if (stored !== code) return next(new Error("Invalid reset code"));

    // Validate password
    const passValidation: string = await utils.ValidatePassword(password);
    if (passValidation !== "0") return next(new Error(passValidation));

    const salt: string = crypto.randomBytes(16).toString("hex");
    const hashed: string = await utils.HashPassword(password, salt);

    // Update password
    await prisma.user.updateMany({ where: { email }, data: { password: hashed, saltPassword: salt } });

    // Remove the code from Redis
    await redisClient.del(`Reset:code:${email}`);

    await utils.RsetResetAttempts(email);

    // Fetch user for notification
    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (user) {
      // Get device & IP info from request
      const { devid, deviceRecord } = await utils.SetDeviceInfo(req, res, email);
      const ip = req.ip || req.headers["x-forwarded-for"] || "unknown";
      const location = await utils.Sendlocation(ip as string);

      // --- EMAIL NOTIFICATION ---
      const emailMessage = `Hello ${user.username},

üîê Your password was just changed!

üìç Location: ${location}
üíª Device info: ${deviceRecord || "unknown"}
üïí Time: ${new Date().toLocaleString()}

If this was not you, immediately secure your account!
‚Äî The Artemisa Team`;

      utils.SendEmailSmtp(res, email, emailMessage).catch(console.error);

      // --- IN-APP / PUSH NOTIFICATION ---
      await addNotification(user.id as UUID, {
        title: "Password Changed",
        body: `Your password was changed from ${deviceRecord || "unknown device"} at ${location}`,
        actorId: user.id,  // system or user themselves
        
      }, (err) => {
        if (err) return next(err);
      });
    }

    return utils.SendRes(res, { message: "Password reset successfully, notification sent" });

  } catch (err) {
    console.error("ResetPassword err:", err);
    return next(err);
  }
}



export async function ReauthPassword(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, password } = req.body;
    if (!email || !password) return next(new Error("missing"));
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return next(new Error("invaild Email"));
    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (!user) return next(new Error("Enter Email or password correctly"));
    // Use utils.CheckPass
    const ok: boolean = await utils.CheckPass(password + user.saltPassword, user.password);
    if (!ok) return next(new Error("Enter Email or password correctly"));
    await redisClient.set(`Reauth:${email}`, "1", { EX: 5 * 60 });
    return utils.SendRes(res, {message:"you can change your cerditional now"});
  } catch (err) {
    console.error("ReauthPassword err:", err);
    return next(err);
  }
}

export async function ReauthTFA(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, code } = req.body;
    if (!email || !code) return next(new Error("missing"));
    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (!user) return next(new Error("email isnot in system"));
    if (!user.tfaVerifed || !user.otp) return next(new Error("you cannot use 2FA method it must be enables first"));
    const ok: boolean = speakeasy.totp.verify({ secret: user.otp, encoding: "base32", token: code, window: 1 });
    if (!ok) return next(new Error("code isnot correct try again"));
    await redisClient.set(`Reauth:${email}`, "1", { EX: 5 * 60 });
    return utils.SendRes(res,{message: "you can change your cerditional now"});
  } catch (err) {
    console.error("ReauthTFA err:", err);
    return next(err);
  }
}

export async function ReauthCode(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email, code } = req.body;
    if (!email || !code) return next(new Error("missing"));
    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (!user) return next(new Error("email isnot in system"));
    if (!user.loginCodesSet) return next(new Error("you cannot use this codes method it must be enables first"));
    const codes: string[] = (user.loginCodes || "").split(",").filter(Boolean);
    let found: boolean = false;
    const copy: string[] = [];
    for (const c of codes) {
      if (c === code) {
        found = true;
        continue;
      }
      copy.push(c);
    }
    if (!found) return next(new Error("Enter code correctly try again"));
    await prisma.user.updateMany({ where: { email }, data: { loginCodes: copy.join(",") } });
    await redisClient.set(`Reauth:${email}`, "1", { EX: 5 * 60 });
    return utils.SendRes(res, {message:"you can change your cerditional now"});
  } catch (err) {
    console.error("ReauthCode err:", err);
    return next(err);
  }
}

export async function ChangePassword(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { password, confirm } = req.body;
    const email: string | undefined =
      (req as any).user?.email || req.body?.email;
    if (!email) return next(new Error("you are unauthorized to enter this route"));
    
    // Use utils.ValidatePassword
    const passValidation: string = await utils.ValidatePassword(password);
    if (passValidation !== "0") return next(new Error(passValidation));
    
    const user = await prisma.user.findUnique({ where: { email } }) as PrismaUser | null;
    if (!user) return next(new Error("something went wrong"));
    
    // Use utils.AnalisePass
    const score: zxcvbn.ZXCVBNResult = utils.AnalisePass(password, user);
    if (score.score < 3) return next(new Error("your password not accepted"));
    if (confirm !== password) return next(new Error("confirm password isnot like the password"));
    
    // Use utils.NotOldPassword
    const oldPassCheck: string = await utils.NotOldPassword(password, user.id);
    if (oldPassCheck !== "0") return next(new Error(oldPassCheck));

    const salt: string = crypto.randomBytes(16).toString("hex");
    // Use utils.HashPassword
    const hashed: string = await utils.HashPassword(password, salt);
    
    await prisma.user.updateMany({ where: { email }, data: { saltPassword:salt, password: hashed }});
    
    // Add new hash to history
    await utils.AddPasswordHistory(hashed, user.id);

    const ip: string = req.ip || (req as any).connection?.remoteAddress || "unknown";
    const username: string =
      (req as any).user?.username || user.username || "user";
    // Use utils.Sendlocation
    const geo: utils.GeoData | null = await utils.Sendlocation(ip).catch(() => null);
    const message: string = `Hi ,${username}

We're letting you know that the password for your account (${email}) was just changed.

üïí Time: ${new Date().toISOString()}
üìç Location: ${geo ? `${geo.Timezone}, ${geo.City}` : "unknown"}
üåê IP Address: ${ip}
üñ•Ô∏è Device: ${req.get("User-Agent") || ""}

If you did NOT change your password, please secure your account immediately.
‚Äî The Artemisa Team
`;
await prisma.user.updateMany({ where: { email }, data: { tokenVersion: (user.tokenVersion || 0) + 1 } });
    try {
  await utils.SendEmailSmtp(res, email, message);
} catch (err) {
  next(err); // <- this will forward it to your error middleware
}

    
    return utils.SendRes(res, { Message: "password updated correctly", Score: score });
  } catch (err) {
    console.error("ChangePassword err:", err);
    return next(err);
  }
}

export async function ChangeEmail(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email: newEmail } = (req as any).body;
    const currentEmail: string | undefined =
      (req as any).user?.email || req.body?.currentEmail;
    if (!newEmail) return next(new Error("email required"));
    if (!currentEmail) return next(new Error("must provide your current email"));
if (newEmail==currentEmail)return next(new Error("new email must be different than the old one"));
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(newEmail)) return next(new Error("input email is not valid"));

    // Use utils.VerifEmailHelper
    const ok: boolean = await utils.VerifEmailHelper(res, currentEmail, newEmail);
    if (!ok) return next(new Error("failed to send verification email"));

    return utils.SendRes(res, {message:"now you can verify your email to change it"});
  } catch (err) {
    console.error("ChangeEmail err:", err);
    return next(err);
  }
}

export async function VerifyNewEmail(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const { email: desiredEmail, code } = (req as any).body;
    const currentEmail: string | undefined =
      (req as any).user?.email || req.body?.currentEmail;
    if (!currentEmail) return next(new Error("you cannot use this codes method it must be enables first"));
    if (!code) return next(new Error("code required"));
    const stored: string | null = await redisClient.get(`ChangeEmail:code:${currentEmail}`);
    if (!stored) return next(new Error("something went wrong:doesnot exist in redis"));
    if (stored !== code) return next(new Error("Enter code correctly"));
    await prisma.user.updateMany({ where: { email: currentEmail }, data: { email: desiredEmail } });
    const updated = await prisma.user.findUnique({ where: { email: desiredEmail } });
    if (!updated) return next(new Error("something went wrong updating user with the new email"));
    await prisma.user.updateMany({ where: { email: desiredEmail }, data: { tokenVersion: (updated.tokenVersion || 0) + 1 } });
    return utils.SendRes(res, {message:"email changed correctly"});
  } catch (err) {
    console.error("VerifyNewEmail err:", err);
    return next(err);
  }
}

export async function GetUser(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const email: string | undefined =
      (req as any).user?.email ||
      (req.query?.email as string) ||
      (req.body?.email as string);
    if (!email) return next(new Error("user isnot authorized this route "));
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) return next(new Error("something went wrong"));
    return utils.SendRes(res, { User: user });
  } catch (err) {
    console.error("GetUser err:", err);
    return next(err);
  }
}

export async function LogoutALL(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
try {
const id: number | undefined = (req.user as any)?.id || req.body?.id || (req.query?.id as string);
if (!id) return next(new Error("unauthorized"));
let cursor: string = "0";
const pattern: string = `session:${id}:*`;
do {
const scanRes: { cursor: string, keys: string[] } = await redisClient.scan(cursor, { MATCH: pattern, COUNT: 100 }) as { cursor: string, keys: string[] };
cursor = scanRes.cursor;
const keys: string[] = scanRes.keys || [];
if (keys.length) {
for (const key of keys) {
const parts: string[] = key.split(":");
if (parts.length === 3) {
const jti: string = parts[2];
await redisClient.set(`Blocklist:${jti}`, "1", { EX: 15 * 60 });
}
}
await redisClient.del(keys);
}
} while (cursor !== "0");
return utils.SendRes(res, {message:"you logout all session successfully"});
} catch (err) {
console.error("LogoutALL err:", err);
return next(err);
}
}


export async function GetSession(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const id: string | undefined =
      (req as any).user?.id || (req.query?.id as string) || req.body?.id;
    console.log("GetSession called with id:", id);
    
    if (!id) return next(new Error("unauthorized"));
    
    let cursor: string = "0";
    const pattern: string = `User:sessions:${id}:*`;
    console.log("Searching for pattern:", pattern);
    
    const sessions: any[] = [];
    const allKeys: string[] = [];
    
    // First, collect all matching keys
    do {
      console.log("Scanning with cursor:", cursor);
      const scanRes = await redisClient.scan(cursor, {
        MATCH: pattern,
        COUNT: 100
      }) as { cursor: number | string, keys: string[] };
      
      console.log("Scan result:", scanRes);
      
      cursor = String(scanRes.cursor);
      const keys: string[] = scanRes.keys || [];
      
      if (keys.length > 0) {
        console.log("Found keys in this iteration:", keys);
        allKeys.push(...keys);
      }
    } while (cursor !== "0");
    
    console.log(`Found ${allKeys.length} session keys for user ${id}`, allKeys);
    
    // Then fetch all list items from each key
    for (const key of allKeys) {
      try {
        console.log("Reading from key:", key);
        const listItems = await redisClient.lRange(key, 0, -1);
        console.log("List items:", listItems);
        
        for (const val of listItems) {
          try {
            const session = JSON.parse(val);
            console.log("Parsed session:", session);
            // Optional: filter out expired sessions
            if (new Date(session.ExpireAt) > new Date()) {
              sessions.push(session);
            } else {
              console.log("Session expired, skipping");
            }
          } catch (e) {
           return next(e);
          }
        }
      } catch (e) {
        return next(e);
      }
    }
    
    console.log("Final sessions from GetSession:", sessions);
    return utils.SendRes(res, sessions);
  } catch (err) {
    return next(err);
   
  }
}


// export async function DebugRedis(req: Request, res: Response): Promise<Response | void> {
//   try {
//     const id: string = (req.query?.id as string) || req.body?.id;
//     console.log("Debug: Looking for sessions with id:", id);
    
//     // Get ALL session keys in Redis
//     const allRedisKeys = await redisClient.keys("User:sessions:*");
//     console.log("All session keys in Redis:", allRedisKeys);
    
//     // Try to find keys for this specific user
//     const userKeys = await redisClient.keys(`User:sessions:${id}:*`);
//     console.log(`Keys for user ${id}:`, userKeys);
    
//     // Read data from user keys
//     const data: any = {};
//     for (const key of userKeys) {
//       const listItems = await redisClient.lRange(key, 0, -1);
//       data[key] = listItems.map(item => JSON.parse(item));
//     }
    
//     return utils.SendRes(res, { 
//       searchId: id,
//       allRedisKeys, 
//       userKeys,
//       data 
//     });
//   } catch (err) {
//     console.error("DebugRedis err:", err);
//     return next(err);
//   }
// }



export async function LogoutSession(req: Request, res: Response, next: NextFunction): Promise<Response | void> {
  try {
    const sessionid: string = req.params.sessionid;
    const userId: string | undefined =
      (req as any).user?.id || req.body?.id || (req.query?.id as string);
    if (!sessionid || !userId) return next(new Error("missing"));
    await redisClient.del(`session:${userId}:${sessionid}`);
    await redisClient.set(`Blocklist:${sessionid}`, "1", { EX: 15 * 60 });
    return utils.SendRes(res, { message: "session logged out successfully" });
  } catch (err) {
    console.error("LogoutSession err:", err);
    return next(err);
  }
}


/* --------------------- Export default --------------------- */

////////////////////////////////////////////////////



export async function exchangeGithubCode(code: string){
const params = {
client_id: process.env.GITHUB_CLIENT_ID,
client_secret: process.env.GITHUB_CLIENT_SECRET,
code,
redirect_uri: process.env.GITHUB_RED_URL,
};
const resp = await axios.post('https://github.com/login/oauth/access_token', qs.stringify(params), {
headers: { 'Accept': 'application/json' }
});
return resp.data; // contains access_token
}


export async function fetchGithubEmails(accessToken: string){
const resp = await axios.get('https://api.github.com/user/emails', {
headers: { Authorization: `Bearer ${accessToken}`, Accept: 'application/json' }
});
return resp.data;
}


export async function fetchGithubUser(accessToken: string){
const resp = await axios.get('https://api.github.com/user', {
headers: { Authorization: `Bearer ${accessToken}`, Accept: 'application/json' }
});
return resp.data;
}


export async function exchangeGoogleCode(code: string){
const params = {
code,
client_id: process.env.CLIENT_ID,
client_secret: process.env.CLIENT_SECRET,
redirect_uri: process.env.RED_URL,
grant_type: 'authorization_code'
};
const resp = await axios.post('https://oauth2.googleapis.com/token', qs.stringify(params), {
headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
});
return resp.data; // contains id_token and access_token
}


export async function exchangeLinkedinCode(code: string){
const params = {
grant_type: 'authorization_code',
code,
redirect_uri: process.env.LINKDIN_RED_URL,
client_id: process.env.LINKDIN_CLIENT_ID,
client_secret: process.env.LINKDIN_CLIENT_SECRET,
};
const resp = await axios.post('https://www.linkedin.com/oauth/v2/accessToken', qs.stringify(params), {
headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
});
return resp.data;
}


export async function fetchLinkedinProfile(accessToken: string){
const resp = await axios.get('https://api.linkedin.com/v2/me', {
headers: { Authorization: `Bearer ${accessToken}` }
});
return resp.data;
}


export async function fetchLinkedinEmail(accessToken: string){
const resp = await axios.get('https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))', {
headers: { Authorization: `Bearer ${accessToken}` }
});
return resp.data;
}

///////////////////////////////////////////
export async function Authorize(req: Request, res: Response, next: NextFunction){
const provider = req.params?.provider;
if(provider === 'google'){
const scope = encodeURIComponent('openid email profile');
const url = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${process.env.CLIENT_ID}&redirect_uri=${encodeURIComponent(process.env.RED_URL!)}&response_type=code&scope=${scope}&state=${process.env.GOOGLE_STATE}`;
return res.redirect(url);
}
if(provider === 'github'){
const url = `https://github.com/login/oauth/authorize?client_id=${process.env.GITHUB_CLIENT_ID}&redirect_uri=${encodeURIComponent(process.env.GITHUB_RED_URL!)}&scope=user%20user:email&state=${process.env.GITHUB_STATE}&prompt=select_account`;
return res.redirect(url);
}
// if(provider === 'linkedin'){
// const scope = encodeURIComponent('r_liteprofile r_emailaddress');
// const url = `https://www.linkedin.com/oauth/v2/authorization?client_id=${process.env.LINKDIN_CLIENT_ID}&redirect_uri=${encodeURIComponent(
// if(provider === 'linkedin'){
// const scope = encodeURIComponent('r_liteprofile r_emailaddress');
// const url = `https://www.linkedin.com/oauth/v2/authorization?client_id=${process.env.LINKDIN_CLIENT_ID}&redirect_uri=${encodeURIComponent(process.env.LINKDIN_RED_URL!)}&state=${process.env.LINKDIN_STATE}&scope=${scope}&response_type=code`;
// return res.redirect(url);
// }
return next(new Error('Unsupported provider'));
}

////////////////////////////////////////////////////////////////////////////
export async function CallbackGithub(req: Request, res: Response, next: NextFunction) {
  try {
    const code = req.query.code as string;
    const tokenResp = await exchangeGithubCode(code);
    const accessToken = tokenResp.access_token as string;

    const emails = await fetchGithubEmails(accessToken);
    const primary = emails.find((e: any) => e.primary && e.verified);
    if (!primary) return next(new Error('No primary verified email found in GitHub account'));

    const email = primary.email as string;
    const userProfile = await fetchGithubUser(accessToken);
    const name = userProfile.name || userProfile.login;
    const providerId = userProfile.id.toString();

    // check if OAuth account exists
    let oauth = await prisma.oAuthAccount.findFirst({
      where: { provider: 'github', providerId },
      include: { user: true },
    });

    let user;
    if (oauth) {
      user = oauth.user;
    } else {
      user = await prisma.user.findUnique({ where: { email } });
      if (!user) {
        user = await prisma.user.create({
          data: {
            email,
            username: utils.generateUsername(name),
            name,
            password: '',
            saltPassword: '',
            dateOfBirth: '2001-11-03T00:00:00.000Z',
            oAuthAccount: {
              create: {
                provider: 'github',
                providerId,
              },
            },
          },
        });
      } else {
        await prisma.oAuthAccount.create({
          data: {
            provider: 'github',
            providerId,
            userId: user.id,
          },
        });
      }
    }

    const deviceId = Math.floor(Math.random() * 100000);
    const payload = { username: user.username, email: user.email, id: user.id, role: 'user' };
    const token = await utils.GenerateJwt(payload);
    const refreshToken = await utils.GenerateJwt(payload);

    await redisClient.set(`refresh-token:${user.email}:${deviceId}`, refreshToken.token, { EX: 60 * 60 * 24 * 30 });
    res.cookie('refresh-token', refreshToken, {
      maxAge: 1000 * 60 * 60 * 24 * 30,
      httpOnly: true,
      secure: true,
      domain: process.env.FRONTEND_HOST,
    });

    await prisma.user.update({ where: { email }, data: { tokenVersion: (user.tokenVersion || 0) + 1 } });
    const userRefreshed = await prisma.user.findUnique({ where: { email } });
    return res.json({ token, user: userRefreshed, device: { id: deviceId } });
  } catch (err: any) {
    return next(err);
  }
}

export async function CallbackGoogle(req: Request, res: Response, next: NextFunction) {
  try {
    const code = req.query.code as string;
    const tokenObj = await exchangeGoogleCode(code);
    const idToken = tokenObj.id_token as string;

    const parts = idToken.split('.');
    if (parts.length < 2) return next(new Error('invalid id_token'));

    const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
    const email = payload.email as string;
    const name = payload.given_name || payload.name || 'unknown';
    const providerId = payload.sub.toString();

    let oauth = await prisma.oAuthAccount.findFirst({
      where: { provider: 'google', providerId },
      include: { user: true },
    });

    let user;
    if (oauth) {
      user = oauth.user;
    } else {
      user = await prisma.user.findUnique({ where: { email } });
      if (!user) {
        user = await prisma.user.create({
          data: {
            email,
            username: utils.generateUsername(name),
            name,
            password: '',
            saltPassword: '',
            dateOfBirth: '2001-11-03T00:00:00.000Z',
            oAuthAccount: {
              create: {
                provider: 'google',
                providerId,
              },
            },
          },
        });
      } else {
        await prisma.oAuthAccount.create({
          data: {
            provider: 'google',
            providerId,
            userId: user.id,
          },
        });
      }
    }

    const deviceId = Math.floor(Math.random() * 100000);
    const payloadJwt = { username: user.username, email: user.email, id: user.id, role: 'user' };
    const token = await utils.GenerateJwt(payloadJwt);
    const refreshToken = await utils.GenerateJwt(payloadJwt);

    await redisClient.set(`refresh-token:${user.email}:${deviceId}`, refreshToken.token, { EX: 60 * 60 * 24 * 30 });
    res.cookie('refresh-token', refreshToken, {
      maxAge: 1000 * 60 * 60 * 24 * 30,
      httpOnly: true,
      secure: true,
      domain: process.env.FRONTEND_HOST,
    });

    await prisma.user.update({
      where: { email },
      data: { tokenVersion: (user.tokenVersion || 0) + 1 },
    });

    const userRefreshed = await prisma.user.findUnique({ where: { email } });
    return res.json({ token, user: userRefreshed, device: { id: deviceId } });
  } catch (err: any) {
    return next(err);
  }
}

export const UpdateUsername = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user?.id; // assuming you have user info in req.user (from auth middleware)
    const { username } = req.body;

    if (!userId) {
      return next(new Error("Unauthorized: Missing user ID"));
    }

    if (!username || typeof username !== 'string' || username.trim() === '') {
      return next(new Error("Invalid username"));
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { username },
    });

   utils.SendRes(res,{
      message: 'Username updated successfully ‚úÖ',
      user: {
        id: updatedUser.id,
        username: updatedUser.username,
      },
    });
  } catch (error: any) {
    console.error('Error updating username:', error);
   return next(new Error('Internal server error'));
  }
};
const authController = {
¬† Create,
¬† Verify_signup_email,
  UpdateUsername,
¬† Login,

// ¬† Create_2fA,
// ¬† Verify_2fA,
// ¬† GenerteLoginCodes,
// ¬† VerifyLoginCode,
¬† ForgetPassword,
¬† ResetPassword,
FinalizeSignup,
¬† Refresh,
¬† Logout,
¬† Captcha,
¬† ReauthPassword,
¬† ReauthTFA,
¬† ReauthCode,
¬† ChangePassword,
¬† ChangeEmail,
¬† VerifyNewEmail,
¬† GetUser,
¬† LogoutALL,
¬† GetSession,
¬† LogoutSession,
SignupCaptcha,

};
const oauthController = {
¬† Authorize,
¬† CallbackGoogle,
¬† CallbackGithub,
¬† // callbackLinkedin, // Implement similarly if needed
};
export { authController, oauthController };