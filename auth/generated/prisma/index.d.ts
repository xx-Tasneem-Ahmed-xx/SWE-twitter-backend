
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Mention
 * 
 */
export type Mention = $Result.DefaultSelection<Prisma.$MentionPayload>
/**
 * Model MessageMedia
 * 
 */
export type MessageMedia = $Result.DefaultSelection<Prisma.$MessageMediaPayload>
/**
 * Model Mute
 * 
 */
export type Mute = $Result.DefaultSelection<Prisma.$MutePayload>
/**
 * Model Retweet
 * 
 */
export type Retweet = $Result.DefaultSelection<Prisma.$RetweetPayload>
/**
 * Model TweetLike
 * 
 */
export type TweetLike = $Result.DefaultSelection<Prisma.$TweetLikePayload>
/**
 * Model TweetMedia
 * 
 */
export type TweetMedia = $Result.DefaultSelection<Prisma.$TweetMediaPayload>
/**
 * Model TweetSummary
 * 
 */
export type TweetSummary = $Result.DefaultSelection<Prisma.$TweetSummaryPayload>
/**
 * Model chatGroups
 * 
 */
export type chatGroups = $Result.DefaultSelection<Prisma.$chatGroupsPayload>
/**
 * Model chats
 * 
 */
export type chats = $Result.DefaultSelection<Prisma.$chatsPayload>
/**
 * Model chatusers
 * 
 */
export type chatusers = $Result.DefaultSelection<Prisma.$chatusersPayload>
/**
 * Model hashes
 * 
 */
export type hashes = $Result.DefaultSelection<Prisma.$hashesPayload>
/**
 * Model medias
 * 
 */
export type medias = $Result.DefaultSelection<Prisma.$mediasPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model spatial_ref_sys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type spatial_ref_sys = $Result.DefaultSelection<Prisma.$spatial_ref_sysPayload>
/**
 * Model tweetHashes
 * 
 */
export type tweetHashes = $Result.DefaultSelection<Prisma.$tweetHashesPayload>
/**
 * Model tweetbookmarks
 * 
 */
export type tweetbookmarks = $Result.DefaultSelection<Prisma.$tweetbookmarksPayload>
/**
 * Model tweets
 * 
 */
export type tweets = $Result.DefaultSelection<Prisma.$tweetsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model DeviceRecord
 * 
 */
export type DeviceRecord = $Result.DefaultSelection<Prisma.$DeviceRecordPayload>
/**
 * Model OldPassword
 * 
 */
export type OldPassword = $Result.DefaultSelection<Prisma.$OldPasswordPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FollowStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED'
};

export type FollowStatus = (typeof FollowStatus)[keyof typeof FollowStatus]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  GIF: 'GIF'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const MessageStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  READ: 'READ'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const NotificationType: {
  LIKE: 'LIKE',
  RETWEET: 'RETWEET',
  REPLY: 'REPLY',
  QUOTE: 'QUOTE',
  FOLLOW: 'FOLLOW',
  RequestToFollow: 'RequestToFollow',
  AcceptedFollow: 'AcceptedFollow',
  MENTION: 'MENTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ReplyControl: {
  EVERYONE: 'EVERYONE',
  FOLLOWINGS: 'FOLLOWINGS',
  VERIFIED: 'VERIFIED',
  MENTIONED: 'MENTIONED'
};

export type ReplyControl = (typeof ReplyControl)[keyof typeof ReplyControl]


export const TweetType: {
  TWEET: 'TWEET',
  REPLY: 'REPLY',
  QUOTE: 'QUOTE'
};

export type TweetType = (typeof TweetType)[keyof typeof TweetType]

}

export type FollowStatus = $Enums.FollowStatus

export const FollowStatus: typeof $Enums.FollowStatus

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ReplyControl = $Enums.ReplyControl

export const ReplyControl: typeof $Enums.ReplyControl

export type TweetType = $Enums.TweetType

export const TweetType: typeof $Enums.TweetType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Blocks
 * const blocks = await prisma.block.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Blocks
   * const blocks = await prisma.block.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mention`: Exposes CRUD operations for the **Mention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentions
    * const mentions = await prisma.mention.findMany()
    * ```
    */
  get mention(): Prisma.MentionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageMedia`: Exposes CRUD operations for the **MessageMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageMedias
    * const messageMedias = await prisma.messageMedia.findMany()
    * ```
    */
  get messageMedia(): Prisma.MessageMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mute`: Exposes CRUD operations for the **Mute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mutes
    * const mutes = await prisma.mute.findMany()
    * ```
    */
  get mute(): Prisma.MuteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.retweet`: Exposes CRUD operations for the **Retweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Retweets
    * const retweets = await prisma.retweet.findMany()
    * ```
    */
  get retweet(): Prisma.RetweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetLike`: Exposes CRUD operations for the **TweetLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TweetLikes
    * const tweetLikes = await prisma.tweetLike.findMany()
    * ```
    */
  get tweetLike(): Prisma.TweetLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetMedia`: Exposes CRUD operations for the **TweetMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TweetMedias
    * const tweetMedias = await prisma.tweetMedia.findMany()
    * ```
    */
  get tweetMedia(): Prisma.TweetMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetSummary`: Exposes CRUD operations for the **TweetSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TweetSummaries
    * const tweetSummaries = await prisma.tweetSummary.findMany()
    * ```
    */
  get tweetSummary(): Prisma.TweetSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatGroups`: Exposes CRUD operations for the **chatGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatGroups
    * const chatGroups = await prisma.chatGroups.findMany()
    * ```
    */
  get chatGroups(): Prisma.chatGroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chats`: Exposes CRUD operations for the **chats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chats.findMany()
    * ```
    */
  get chats(): Prisma.chatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatusers`: Exposes CRUD operations for the **chatusers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatusers
    * const chatusers = await prisma.chatusers.findMany()
    * ```
    */
  get chatusers(): Prisma.chatusersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hashes`: Exposes CRUD operations for the **hashes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hashes
    * const hashes = await prisma.hashes.findMany()
    * ```
    */
  get hashes(): Prisma.hashesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medias`: Exposes CRUD operations for the **medias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medias
    * const medias = await prisma.medias.findMany()
    * ```
    */
  get medias(): Prisma.mediasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spatial_ref_sys`: Exposes CRUD operations for the **spatial_ref_sys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spatial_ref_sys
    * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
    * ```
    */
  get spatial_ref_sys(): Prisma.spatial_ref_sysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetHashes`: Exposes CRUD operations for the **tweetHashes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TweetHashes
    * const tweetHashes = await prisma.tweetHashes.findMany()
    * ```
    */
  get tweetHashes(): Prisma.tweetHashesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetbookmarks`: Exposes CRUD operations for the **tweetbookmarks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweetbookmarks
    * const tweetbookmarks = await prisma.tweetbookmarks.findMany()
    * ```
    */
  get tweetbookmarks(): Prisma.tweetbookmarksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweets`: Exposes CRUD operations for the **tweets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweets
    * const tweets = await prisma.tweets.findMany()
    * ```
    */
  get tweets(): Prisma.tweetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceRecord`: Exposes CRUD operations for the **DeviceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceRecords
    * const deviceRecords = await prisma.deviceRecord.findMany()
    * ```
    */
  get deviceRecord(): Prisma.DeviceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oldPassword`: Exposes CRUD operations for the **OldPassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OldPasswords
    * const oldPasswords = await prisma.oldPassword.findMany()
    * ```
    */
  get oldPassword(): Prisma.OldPasswordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.0
   * Query Engine version: c0aafc03b8ef6cdced8654b9a817999e02457d6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Block: 'Block',
    Follow: 'Follow',
    Mention: 'Mention',
    MessageMedia: 'MessageMedia',
    Mute: 'Mute',
    Retweet: 'Retweet',
    TweetLike: 'TweetLike',
    TweetMedia: 'TweetMedia',
    TweetSummary: 'TweetSummary',
    chatGroups: 'chatGroups',
    chats: 'chats',
    chatusers: 'chatusers',
    hashes: 'hashes',
    medias: 'medias',
    messages: 'messages',
    notifications: 'notifications',
    spatial_ref_sys: 'spatial_ref_sys',
    tweetHashes: 'tweetHashes',
    tweetbookmarks: 'tweetbookmarks',
    tweets: 'tweets',
    users: 'users',
    DeviceRecord: 'DeviceRecord',
    OldPassword: 'OldPassword',
    Session: 'Session'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "block" | "follow" | "mention" | "messageMedia" | "mute" | "retweet" | "tweetLike" | "tweetMedia" | "tweetSummary" | "chatGroups" | "chats" | "chatusers" | "hashes" | "medias" | "messages" | "notifications" | "spatial_ref_sys" | "tweetHashes" | "tweetbookmarks" | "tweets" | "users" | "deviceRecord" | "oldPassword" | "session"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Mention: {
        payload: Prisma.$MentionPayload<ExtArgs>
        fields: Prisma.MentionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findFirst: {
            args: Prisma.MentionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findMany: {
            args: Prisma.MentionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          create: {
            args: Prisma.MentionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          createMany: {
            args: Prisma.MentionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          delete: {
            args: Prisma.MentionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          update: {
            args: Prisma.MentionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          deleteMany: {
            args: Prisma.MentionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MentionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          upsert: {
            args: Prisma.MentionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          aggregate: {
            args: Prisma.MentionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMention>
          }
          groupBy: {
            args: Prisma.MentionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentionCountArgs<ExtArgs>
            result: $Utils.Optional<MentionCountAggregateOutputType> | number
          }
        }
      }
      MessageMedia: {
        payload: Prisma.$MessageMediaPayload<ExtArgs>
        fields: Prisma.MessageMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          findFirst: {
            args: Prisma.MessageMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          findMany: {
            args: Prisma.MessageMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>[]
          }
          create: {
            args: Prisma.MessageMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          createMany: {
            args: Prisma.MessageMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>[]
          }
          delete: {
            args: Prisma.MessageMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          update: {
            args: Prisma.MessageMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          deleteMany: {
            args: Prisma.MessageMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>[]
          }
          upsert: {
            args: Prisma.MessageMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageMediaPayload>
          }
          aggregate: {
            args: Prisma.MessageMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageMedia>
          }
          groupBy: {
            args: Prisma.MessageMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageMediaCountArgs<ExtArgs>
            result: $Utils.Optional<MessageMediaCountAggregateOutputType> | number
          }
        }
      }
      Mute: {
        payload: Prisma.$MutePayload<ExtArgs>
        fields: Prisma.MuteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findFirst: {
            args: Prisma.MuteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findMany: {
            args: Prisma.MuteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          create: {
            args: Prisma.MuteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          createMany: {
            args: Prisma.MuteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MuteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          delete: {
            args: Prisma.MuteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          update: {
            args: Prisma.MuteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          deleteMany: {
            args: Prisma.MuteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MuteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MuteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          upsert: {
            args: Prisma.MuteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          aggregate: {
            args: Prisma.MuteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMute>
          }
          groupBy: {
            args: Prisma.MuteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MuteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuteCountArgs<ExtArgs>
            result: $Utils.Optional<MuteCountAggregateOutputType> | number
          }
        }
      }
      Retweet: {
        payload: Prisma.$RetweetPayload<ExtArgs>
        fields: Prisma.RetweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          findFirst: {
            args: Prisma.RetweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          findMany: {
            args: Prisma.RetweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>[]
          }
          create: {
            args: Prisma.RetweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          createMany: {
            args: Prisma.RetweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>[]
          }
          delete: {
            args: Prisma.RetweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          update: {
            args: Prisma.RetweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          deleteMany: {
            args: Prisma.RetweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RetweetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>[]
          }
          upsert: {
            args: Prisma.RetweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetweetPayload>
          }
          aggregate: {
            args: Prisma.RetweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetweet>
          }
          groupBy: {
            args: Prisma.RetweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetweetCountArgs<ExtArgs>
            result: $Utils.Optional<RetweetCountAggregateOutputType> | number
          }
        }
      }
      TweetLike: {
        payload: Prisma.$TweetLikePayload<ExtArgs>
        fields: Prisma.TweetLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          findFirst: {
            args: Prisma.TweetLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          findMany: {
            args: Prisma.TweetLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>[]
          }
          create: {
            args: Prisma.TweetLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          createMany: {
            args: Prisma.TweetLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>[]
          }
          delete: {
            args: Prisma.TweetLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          update: {
            args: Prisma.TweetLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          deleteMany: {
            args: Prisma.TweetLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>[]
          }
          upsert: {
            args: Prisma.TweetLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetLikePayload>
          }
          aggregate: {
            args: Prisma.TweetLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetLike>
          }
          groupBy: {
            args: Prisma.TweetLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetLikeCountArgs<ExtArgs>
            result: $Utils.Optional<TweetLikeCountAggregateOutputType> | number
          }
        }
      }
      TweetMedia: {
        payload: Prisma.$TweetMediaPayload<ExtArgs>
        fields: Prisma.TweetMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          findFirst: {
            args: Prisma.TweetMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          findMany: {
            args: Prisma.TweetMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          create: {
            args: Prisma.TweetMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          createMany: {
            args: Prisma.TweetMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          delete: {
            args: Prisma.TweetMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          update: {
            args: Prisma.TweetMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          deleteMany: {
            args: Prisma.TweetMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          upsert: {
            args: Prisma.TweetMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          aggregate: {
            args: Prisma.TweetMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetMedia>
          }
          groupBy: {
            args: Prisma.TweetMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetMediaCountArgs<ExtArgs>
            result: $Utils.Optional<TweetMediaCountAggregateOutputType> | number
          }
        }
      }
      TweetSummary: {
        payload: Prisma.$TweetSummaryPayload<ExtArgs>
        fields: Prisma.TweetSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          findFirst: {
            args: Prisma.TweetSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          findMany: {
            args: Prisma.TweetSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>[]
          }
          create: {
            args: Prisma.TweetSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          createMany: {
            args: Prisma.TweetSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>[]
          }
          delete: {
            args: Prisma.TweetSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          update: {
            args: Prisma.TweetSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          deleteMany: {
            args: Prisma.TweetSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>[]
          }
          upsert: {
            args: Prisma.TweetSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetSummaryPayload>
          }
          aggregate: {
            args: Prisma.TweetSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetSummary>
          }
          groupBy: {
            args: Prisma.TweetSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<TweetSummaryCountAggregateOutputType> | number
          }
        }
      }
      chatGroups: {
        payload: Prisma.$chatGroupsPayload<ExtArgs>
        fields: Prisma.chatGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatGroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatGroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          findFirst: {
            args: Prisma.chatGroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatGroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          findMany: {
            args: Prisma.chatGroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>[]
          }
          create: {
            args: Prisma.chatGroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          createMany: {
            args: Prisma.chatGroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatGroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>[]
          }
          delete: {
            args: Prisma.chatGroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          update: {
            args: Prisma.chatGroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          deleteMany: {
            args: Prisma.chatGroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatGroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatGroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>[]
          }
          upsert: {
            args: Prisma.chatGroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatGroupsPayload>
          }
          aggregate: {
            args: Prisma.ChatGroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatGroups>
          }
          groupBy: {
            args: Prisma.chatGroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatGroupsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupsCountAggregateOutputType> | number
          }
        }
      }
      chats: {
        payload: Prisma.$chatsPayload<ExtArgs>
        fields: Prisma.chatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findFirst: {
            args: Prisma.chatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findMany: {
            args: Prisma.chatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          create: {
            args: Prisma.chatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          createMany: {
            args: Prisma.chatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          delete: {
            args: Prisma.chatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          update: {
            args: Prisma.chatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          deleteMany: {
            args: Prisma.chatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          upsert: {
            args: Prisma.chatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          aggregate: {
            args: Prisma.ChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChats>
          }
          groupBy: {
            args: Prisma.chatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatsCountAggregateOutputType> | number
          }
        }
      }
      chatusers: {
        payload: Prisma.$chatusersPayload<ExtArgs>
        fields: Prisma.chatusersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatusersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatusersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          findFirst: {
            args: Prisma.chatusersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatusersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          findMany: {
            args: Prisma.chatusersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>[]
          }
          create: {
            args: Prisma.chatusersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          createMany: {
            args: Prisma.chatusersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatusersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>[]
          }
          delete: {
            args: Prisma.chatusersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          update: {
            args: Prisma.chatusersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          deleteMany: {
            args: Prisma.chatusersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatusersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatusersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>[]
          }
          upsert: {
            args: Prisma.chatusersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatusersPayload>
          }
          aggregate: {
            args: Prisma.ChatusersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatusers>
          }
          groupBy: {
            args: Prisma.chatusersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatusersGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatusersCountArgs<ExtArgs>
            result: $Utils.Optional<ChatusersCountAggregateOutputType> | number
          }
        }
      }
      hashes: {
        payload: Prisma.$hashesPayload<ExtArgs>
        fields: Prisma.hashesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hashesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hashesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          findFirst: {
            args: Prisma.hashesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hashesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          findMany: {
            args: Prisma.hashesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>[]
          }
          create: {
            args: Prisma.hashesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          createMany: {
            args: Prisma.hashesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.hashesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>[]
          }
          delete: {
            args: Prisma.hashesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          update: {
            args: Prisma.hashesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          deleteMany: {
            args: Prisma.hashesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hashesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.hashesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>[]
          }
          upsert: {
            args: Prisma.hashesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashesPayload>
          }
          aggregate: {
            args: Prisma.HashesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHashes>
          }
          groupBy: {
            args: Prisma.hashesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HashesGroupByOutputType>[]
          }
          count: {
            args: Prisma.hashesCountArgs<ExtArgs>
            result: $Utils.Optional<HashesCountAggregateOutputType> | number
          }
        }
      }
      medias: {
        payload: Prisma.$mediasPayload<ExtArgs>
        fields: Prisma.mediasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mediasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mediasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          findFirst: {
            args: Prisma.mediasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mediasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          findMany: {
            args: Prisma.mediasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>[]
          }
          create: {
            args: Prisma.mediasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          createMany: {
            args: Prisma.mediasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mediasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>[]
          }
          delete: {
            args: Prisma.mediasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          update: {
            args: Prisma.mediasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          deleteMany: {
            args: Prisma.mediasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mediasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mediasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>[]
          }
          upsert: {
            args: Prisma.mediasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mediasPayload>
          }
          aggregate: {
            args: Prisma.MediasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedias>
          }
          groupBy: {
            args: Prisma.mediasGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediasGroupByOutputType>[]
          }
          count: {
            args: Prisma.mediasCountArgs<ExtArgs>
            result: $Utils.Optional<MediasCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      spatial_ref_sys: {
        payload: Prisma.$spatial_ref_sysPayload<ExtArgs>
        fields: Prisma.spatial_ref_sysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spatial_ref_sysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findFirst: {
            args: Prisma.spatial_ref_sysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findMany: {
            args: Prisma.spatial_ref_sysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          create: {
            args: Prisma.spatial_ref_sysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          createMany: {
            args: Prisma.spatial_ref_sysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          delete: {
            args: Prisma.spatial_ref_sysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          update: {
            args: Prisma.spatial_ref_sysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          deleteMany: {
            args: Prisma.spatial_ref_sysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.spatial_ref_sysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          upsert: {
            args: Prisma.spatial_ref_sysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          aggregate: {
            args: Prisma.Spatial_ref_sysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpatial_ref_sys>
          }
          groupBy: {
            args: Prisma.spatial_ref_sysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysGroupByOutputType>[]
          }
          count: {
            args: Prisma.spatial_ref_sysCountArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysCountAggregateOutputType> | number
          }
        }
      }
      tweetHashes: {
        payload: Prisma.$tweetHashesPayload<ExtArgs>
        fields: Prisma.tweetHashesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tweetHashesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tweetHashesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          findFirst: {
            args: Prisma.tweetHashesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tweetHashesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          findMany: {
            args: Prisma.tweetHashesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>[]
          }
          create: {
            args: Prisma.tweetHashesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          createMany: {
            args: Prisma.tweetHashesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tweetHashesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>[]
          }
          delete: {
            args: Prisma.tweetHashesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          update: {
            args: Prisma.tweetHashesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          deleteMany: {
            args: Prisma.tweetHashesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tweetHashesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tweetHashesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>[]
          }
          upsert: {
            args: Prisma.tweetHashesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetHashesPayload>
          }
          aggregate: {
            args: Prisma.TweetHashesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetHashes>
          }
          groupBy: {
            args: Prisma.tweetHashesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetHashesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tweetHashesCountArgs<ExtArgs>
            result: $Utils.Optional<TweetHashesCountAggregateOutputType> | number
          }
        }
      }
      tweetbookmarks: {
        payload: Prisma.$tweetbookmarksPayload<ExtArgs>
        fields: Prisma.tweetbookmarksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tweetbookmarksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tweetbookmarksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          findFirst: {
            args: Prisma.tweetbookmarksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tweetbookmarksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          findMany: {
            args: Prisma.tweetbookmarksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>[]
          }
          create: {
            args: Prisma.tweetbookmarksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          createMany: {
            args: Prisma.tweetbookmarksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tweetbookmarksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>[]
          }
          delete: {
            args: Prisma.tweetbookmarksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          update: {
            args: Prisma.tweetbookmarksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          deleteMany: {
            args: Prisma.tweetbookmarksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tweetbookmarksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tweetbookmarksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>[]
          }
          upsert: {
            args: Prisma.tweetbookmarksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetbookmarksPayload>
          }
          aggregate: {
            args: Prisma.TweetbookmarksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetbookmarks>
          }
          groupBy: {
            args: Prisma.tweetbookmarksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetbookmarksGroupByOutputType>[]
          }
          count: {
            args: Prisma.tweetbookmarksCountArgs<ExtArgs>
            result: $Utils.Optional<TweetbookmarksCountAggregateOutputType> | number
          }
        }
      }
      tweets: {
        payload: Prisma.$tweetsPayload<ExtArgs>
        fields: Prisma.tweetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tweetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tweetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          findFirst: {
            args: Prisma.tweetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tweetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          findMany: {
            args: Prisma.tweetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>[]
          }
          create: {
            args: Prisma.tweetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          createMany: {
            args: Prisma.tweetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tweetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>[]
          }
          delete: {
            args: Prisma.tweetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          update: {
            args: Prisma.tweetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          deleteMany: {
            args: Prisma.tweetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tweetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tweetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>[]
          }
          upsert: {
            args: Prisma.tweetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tweetsPayload>
          }
          aggregate: {
            args: Prisma.TweetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweets>
          }
          groupBy: {
            args: Prisma.tweetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tweetsCountArgs<ExtArgs>
            result: $Utils.Optional<TweetsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      DeviceRecord: {
        payload: Prisma.$DeviceRecordPayload<ExtArgs>
        fields: Prisma.DeviceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          findFirst: {
            args: Prisma.DeviceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          findMany: {
            args: Prisma.DeviceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>[]
          }
          create: {
            args: Prisma.DeviceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          createMany: {
            args: Prisma.DeviceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>[]
          }
          delete: {
            args: Prisma.DeviceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          update: {
            args: Prisma.DeviceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          deleteMany: {
            args: Prisma.DeviceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>[]
          }
          upsert: {
            args: Prisma.DeviceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceRecordPayload>
          }
          aggregate: {
            args: Prisma.DeviceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceRecord>
          }
          groupBy: {
            args: Prisma.DeviceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceRecordCountAggregateOutputType> | number
          }
        }
      }
      OldPassword: {
        payload: Prisma.$OldPasswordPayload<ExtArgs>
        fields: Prisma.OldPasswordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OldPasswordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OldPasswordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          findFirst: {
            args: Prisma.OldPasswordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OldPasswordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          findMany: {
            args: Prisma.OldPasswordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>[]
          }
          create: {
            args: Prisma.OldPasswordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          createMany: {
            args: Prisma.OldPasswordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OldPasswordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>[]
          }
          delete: {
            args: Prisma.OldPasswordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          update: {
            args: Prisma.OldPasswordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          deleteMany: {
            args: Prisma.OldPasswordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OldPasswordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OldPasswordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>[]
          }
          upsert: {
            args: Prisma.OldPasswordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OldPasswordPayload>
          }
          aggregate: {
            args: Prisma.OldPasswordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOldPassword>
          }
          groupBy: {
            args: Prisma.OldPasswordGroupByArgs<ExtArgs>
            result: $Utils.Optional<OldPasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.OldPasswordCountArgs<ExtArgs>
            result: $Utils.Optional<OldPasswordCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    block?: BlockOmit
    follow?: FollowOmit
    mention?: MentionOmit
    messageMedia?: MessageMediaOmit
    mute?: MuteOmit
    retweet?: RetweetOmit
    tweetLike?: TweetLikeOmit
    tweetMedia?: TweetMediaOmit
    tweetSummary?: TweetSummaryOmit
    chatGroups?: chatGroupsOmit
    chats?: chatsOmit
    chatusers?: chatusersOmit
    hashes?: hashesOmit
    medias?: mediasOmit
    messages?: messagesOmit
    notifications?: notificationsOmit
    spatial_ref_sys?: spatial_ref_sysOmit
    tweetHashes?: tweetHashesOmit
    tweetbookmarks?: tweetbookmarksOmit
    tweets?: tweetsOmit
    users?: usersOmit
    deviceRecord?: DeviceRecordOmit
    oldPassword?: OldPasswordOmit
    session?: SessionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChatsCountOutputType
   */

  export type ChatsCountOutputType = {
    chatusers: number
    messages: number
  }

  export type ChatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatusers?: boolean | ChatsCountOutputTypeCountChatusersArgs
    messages?: boolean | ChatsCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatsCountOutputType
     */
    select?: ChatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountChatusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatusersWhereInput
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }


  /**
   * Count Type HashesCountOutputType
   */

  export type HashesCountOutputType = {
    tweetHashes: number
  }

  export type HashesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweetHashes?: boolean | HashesCountOutputTypeCountTweetHashesArgs
  }

  // Custom InputTypes
  /**
   * HashesCountOutputType without action
   */
  export type HashesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashesCountOutputType
     */
    select?: HashesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HashesCountOutputType without action
   */
  export type HashesCountOutputTypeCountTweetHashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetHashesWhereInput
  }


  /**
   * Count Type MediasCountOutputType
   */

  export type MediasCountOutputType = {
    MessageMedia: number
    TweetMedia: number
  }

  export type MediasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageMedia?: boolean | MediasCountOutputTypeCountMessageMediaArgs
    TweetMedia?: boolean | MediasCountOutputTypeCountTweetMediaArgs
  }

  // Custom InputTypes
  /**
   * MediasCountOutputType without action
   */
  export type MediasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediasCountOutputType
     */
    select?: MediasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediasCountOutputType without action
   */
  export type MediasCountOutputTypeCountMessageMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageMediaWhereInput
  }

  /**
   * MediasCountOutputType without action
   */
  export type MediasCountOutputTypeCountTweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetMediaWhereInput
  }


  /**
   * Count Type MessagesCountOutputType
   */

  export type MessagesCountOutputType = {
    MessageMedia: number
  }

  export type MessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageMedia?: boolean | MessagesCountOutputTypeCountMessageMediaArgs
  }

  // Custom InputTypes
  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesCountOutputType
     */
    select?: MessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountMessageMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageMediaWhereInput
  }


  /**
   * Count Type TweetsCountOutputType
   */

  export type TweetsCountOutputType = {
    Mention: number
    Retweet: number
    TweetLike: number
    TweetMedia: number
    notifications: number
    tweetHashes: number
    tweetbookmarks: number
    other_tweets: number
  }

  export type TweetsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mention?: boolean | TweetsCountOutputTypeCountMentionArgs
    Retweet?: boolean | TweetsCountOutputTypeCountRetweetArgs
    TweetLike?: boolean | TweetsCountOutputTypeCountTweetLikeArgs
    TweetMedia?: boolean | TweetsCountOutputTypeCountTweetMediaArgs
    notifications?: boolean | TweetsCountOutputTypeCountNotificationsArgs
    tweetHashes?: boolean | TweetsCountOutputTypeCountTweetHashesArgs
    tweetbookmarks?: boolean | TweetsCountOutputTypeCountTweetbookmarksArgs
    other_tweets?: boolean | TweetsCountOutputTypeCountOther_tweetsArgs
  }

  // Custom InputTypes
  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetsCountOutputType
     */
    select?: TweetsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountMentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountRetweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetweetWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountTweetLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetLikeWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountTweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetMediaWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountTweetHashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetHashesWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountTweetbookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetbookmarksWhereInput
  }

  /**
   * TweetsCountOutputType without action
   */
  export type TweetsCountOutputTypeCountOther_tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    device_record: number
    old_passwords: number
    Block_Block_blockedIdTousers: number
    Block_Block_blockerIdTousers: number
    Follow_Follow_followerIdTousers: number
    Follow_Follow_followingIdTousers: number
    Mention_Mention_mentionedIdTousers: number
    Mention_Mention_mentionerIdTousers: number
    Mute_Mute_mutedIdTousers: number
    Mute_Mute_muterIdTousers: number
    Retweet: number
    TweetLike: number
    chatusers: number
    messages: number
    notifications_notifications_actorIdTousers: number
    notifications_notifications_userIdTousers: number
    tweetbookmarks: number
    tweets: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device_record?: boolean | UsersCountOutputTypeCountDevice_recordArgs
    old_passwords?: boolean | UsersCountOutputTypeCountOld_passwordsArgs
    Block_Block_blockedIdTousers?: boolean | UsersCountOutputTypeCountBlock_Block_blockedIdTousersArgs
    Block_Block_blockerIdTousers?: boolean | UsersCountOutputTypeCountBlock_Block_blockerIdTousersArgs
    Follow_Follow_followerIdTousers?: boolean | UsersCountOutputTypeCountFollow_Follow_followerIdTousersArgs
    Follow_Follow_followingIdTousers?: boolean | UsersCountOutputTypeCountFollow_Follow_followingIdTousersArgs
    Mention_Mention_mentionedIdTousers?: boolean | UsersCountOutputTypeCountMention_Mention_mentionedIdTousersArgs
    Mention_Mention_mentionerIdTousers?: boolean | UsersCountOutputTypeCountMention_Mention_mentionerIdTousersArgs
    Mute_Mute_mutedIdTousers?: boolean | UsersCountOutputTypeCountMute_Mute_mutedIdTousersArgs
    Mute_Mute_muterIdTousers?: boolean | UsersCountOutputTypeCountMute_Mute_muterIdTousersArgs
    Retweet?: boolean | UsersCountOutputTypeCountRetweetArgs
    TweetLike?: boolean | UsersCountOutputTypeCountTweetLikeArgs
    chatusers?: boolean | UsersCountOutputTypeCountChatusersArgs
    messages?: boolean | UsersCountOutputTypeCountMessagesArgs
    notifications_notifications_actorIdTousers?: boolean | UsersCountOutputTypeCountNotifications_notifications_actorIdTousersArgs
    notifications_notifications_userIdTousers?: boolean | UsersCountOutputTypeCountNotifications_notifications_userIdTousersArgs
    tweetbookmarks?: boolean | UsersCountOutputTypeCountTweetbookmarksArgs
    tweets?: boolean | UsersCountOutputTypeCountTweetsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDevice_recordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceRecordWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOld_passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OldPasswordWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlock_Block_blockedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlock_Block_blockerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollow_Follow_followerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollow_Follow_followingIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMention_Mention_mentionedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMention_Mention_mentionerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMute_Mute_mutedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMute_Mute_muterIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRetweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetweetWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTweetLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetLikeWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChatusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatusersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotifications_notifications_actorIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotifications_notifications_userIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTweetbookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetbookmarksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    blockedId: string | null
    blockerId: string | null
  }

  export type BlockMaxAggregateOutputType = {
    blockedId: string | null
    blockerId: string | null
  }

  export type BlockCountAggregateOutputType = {
    blockedId: number
    blockerId: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    blockedId?: true
    blockerId?: true
  }

  export type BlockMaxAggregateInputType = {
    blockedId?: true
    blockerId?: true
  }

  export type BlockCountAggregateInputType = {
    blockedId?: true
    blockerId?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    blockedId: string
    blockerId: string
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blockedId?: boolean
    blockerId?: boolean
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blockedId?: boolean
    blockerId?: boolean
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    blockedId?: boolean
    blockerId?: boolean
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    blockedId?: boolean
    blockerId?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"blockedId" | "blockerId", ExtArgs["result"]["block"]>
  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type BlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Block_blockedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Block_blockerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      users_Block_blockedIdTousers: Prisma.$usersPayload<ExtArgs>
      users_Block_blockerIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      blockedId: string
      blockerId: string
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `blockedId`
     * const blockWithBlockedIdOnly = await prisma.block.findMany({ select: { blockedId: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `blockedId`
     * const blockWithBlockedIdOnly = await prisma.block.createManyAndReturn({
     *   select: { blockedId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `blockedId`
     * const blockWithBlockedIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { blockedId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_Block_blockedIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_Block_blockerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly blockedId: FieldRef<"Block", 'String'>
    readonly blockerId: FieldRef<"Block", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block updateManyAndReturn
   */
  export type BlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    followerId: string | null
    followingId: string | null
    status: $Enums.FollowStatus | null
  }

  export type FollowMaxAggregateOutputType = {
    followerId: string | null
    followingId: string | null
    status: $Enums.FollowStatus | null
  }

  export type FollowCountAggregateOutputType = {
    followerId: number
    followingId: number
    status: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    followerId?: true
    followingId?: true
    status?: true
  }

  export type FollowMaxAggregateInputType = {
    followerId?: true
    followingId?: true
    status?: true
  }

  export type FollowCountAggregateInputType = {
    followerId?: true
    followingId?: true
    status?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    followerId: string
    followingId: string
    status: $Enums.FollowStatus
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    status?: boolean
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    status?: boolean
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerId?: boolean
    followingId?: boolean
    status?: boolean
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    followerId?: boolean
    followingId?: boolean
    status?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"followerId" | "followingId" | "status", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Follow_followerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Follow_followingIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      users_Follow_followerIdTousers: Prisma.$usersPayload<ExtArgs>
      users_Follow_followingIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      followerId: string
      followingId: string
      status: $Enums.FollowStatus
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `followerId`
     * const followWithFollowerIdOnly = await prisma.follow.findMany({ select: { followerId: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `followerId`
     * const followWithFollowerIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { followerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `followerId`
     * const followWithFollowerIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { followerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_Follow_followerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_Follow_followingIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly status: FieldRef<"Follow", 'FollowStatus'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Mention
   */

  export type AggregateMention = {
    _count: MentionCountAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  export type MentionMinAggregateOutputType = {
    tweetId: string | null
    mentionerId: string | null
    mentionedId: string | null
  }

  export type MentionMaxAggregateOutputType = {
    tweetId: string | null
    mentionerId: string | null
    mentionedId: string | null
  }

  export type MentionCountAggregateOutputType = {
    tweetId: number
    mentionerId: number
    mentionedId: number
    _all: number
  }


  export type MentionMinAggregateInputType = {
    tweetId?: true
    mentionerId?: true
    mentionedId?: true
  }

  export type MentionMaxAggregateInputType = {
    tweetId?: true
    mentionerId?: true
    mentionedId?: true
  }

  export type MentionCountAggregateInputType = {
    tweetId?: true
    mentionerId?: true
    mentionedId?: true
    _all?: true
  }

  export type MentionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mention to aggregate.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentions
    **/
    _count?: true | MentionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentionMaxAggregateInputType
  }

  export type GetMentionAggregateType<T extends MentionAggregateArgs> = {
        [P in keyof T & keyof AggregateMention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMention[P]>
      : GetScalarType<T[P], AggregateMention[P]>
  }




  export type MentionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithAggregationInput | MentionOrderByWithAggregationInput[]
    by: MentionScalarFieldEnum[] | MentionScalarFieldEnum
    having?: MentionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentionCountAggregateInputType | true
    _min?: MentionMinAggregateInputType
    _max?: MentionMaxAggregateInputType
  }

  export type MentionGroupByOutputType = {
    tweetId: string
    mentionerId: string
    mentionedId: string
    _count: MentionCountAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  type GetMentionGroupByPayload<T extends MentionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentionGroupByOutputType[P]>
            : GetScalarType<T[P], MentionGroupByOutputType[P]>
        }
      >
    >


  export type MentionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mentionerId?: boolean
    mentionedId?: boolean
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mentionerId?: boolean
    mentionedId?: boolean
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mentionerId?: boolean
    mentionedId?: boolean
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectScalar = {
    tweetId?: boolean
    mentionerId?: boolean
    mentionedId?: boolean
  }

  export type MentionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tweetId" | "mentionerId" | "mentionedId", ExtArgs["result"]["mention"]>
  export type MentionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type MentionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type MentionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mention_mentionedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mention_mentionerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }

  export type $MentionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mention"
    objects: {
      users_Mention_mentionedIdTousers: Prisma.$usersPayload<ExtArgs>
      users_Mention_mentionerIdTousers: Prisma.$usersPayload<ExtArgs>
      tweets: Prisma.$tweetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tweetId: string
      mentionerId: string
      mentionedId: string
    }, ExtArgs["result"]["mention"]>
    composites: {}
  }

  type MentionGetPayload<S extends boolean | null | undefined | MentionDefaultArgs> = $Result.GetResult<Prisma.$MentionPayload, S>

  type MentionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MentionCountAggregateInputType | true
    }

  export interface MentionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mention'], meta: { name: 'Mention' } }
    /**
     * Find zero or one Mention that matches the filter.
     * @param {MentionFindUniqueArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentionFindUniqueArgs>(args: SelectSubset<T, MentionFindUniqueArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentionFindUniqueOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentionFindUniqueOrThrowArgs>(args: SelectSubset<T, MentionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentionFindFirstArgs>(args?: SelectSubset<T, MentionFindFirstArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentionFindFirstOrThrowArgs>(args?: SelectSubset<T, MentionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentions
     * const mentions = await prisma.mention.findMany()
     * 
     * // Get first 10 Mentions
     * const mentions = await prisma.mention.findMany({ take: 10 })
     * 
     * // Only select the `tweetId`
     * const mentionWithTweetIdOnly = await prisma.mention.findMany({ select: { tweetId: true } })
     * 
     */
    findMany<T extends MentionFindManyArgs>(args?: SelectSubset<T, MentionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mention.
     * @param {MentionCreateArgs} args - Arguments to create a Mention.
     * @example
     * // Create one Mention
     * const Mention = await prisma.mention.create({
     *   data: {
     *     // ... data to create a Mention
     *   }
     * })
     * 
     */
    create<T extends MentionCreateArgs>(args: SelectSubset<T, MentionCreateArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mentions.
     * @param {MentionCreateManyArgs} args - Arguments to create many Mentions.
     * @example
     * // Create many Mentions
     * const mention = await prisma.mention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentionCreateManyArgs>(args?: SelectSubset<T, MentionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentions and returns the data saved in the database.
     * @param {MentionCreateManyAndReturnArgs} args - Arguments to create many Mentions.
     * @example
     * // Create many Mentions
     * const mention = await prisma.mention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentions and only return the `tweetId`
     * const mentionWithTweetIdOnly = await prisma.mention.createManyAndReturn({
     *   select: { tweetId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentionCreateManyAndReturnArgs>(args?: SelectSubset<T, MentionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mention.
     * @param {MentionDeleteArgs} args - Arguments to delete one Mention.
     * @example
     * // Delete one Mention
     * const Mention = await prisma.mention.delete({
     *   where: {
     *     // ... filter to delete one Mention
     *   }
     * })
     * 
     */
    delete<T extends MentionDeleteArgs>(args: SelectSubset<T, MentionDeleteArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mention.
     * @param {MentionUpdateArgs} args - Arguments to update one Mention.
     * @example
     * // Update one Mention
     * const mention = await prisma.mention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentionUpdateArgs>(args: SelectSubset<T, MentionUpdateArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mentions.
     * @param {MentionDeleteManyArgs} args - Arguments to filter Mentions to delete.
     * @example
     * // Delete a few Mentions
     * const { count } = await prisma.mention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentionDeleteManyArgs>(args?: SelectSubset<T, MentionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentions
     * const mention = await prisma.mention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentionUpdateManyArgs>(args: SelectSubset<T, MentionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentions and returns the data updated in the database.
     * @param {MentionUpdateManyAndReturnArgs} args - Arguments to update many Mentions.
     * @example
     * // Update many Mentions
     * const mention = await prisma.mention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mentions and only return the `tweetId`
     * const mentionWithTweetIdOnly = await prisma.mention.updateManyAndReturn({
     *   select: { tweetId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MentionUpdateManyAndReturnArgs>(args: SelectSubset<T, MentionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mention.
     * @param {MentionUpsertArgs} args - Arguments to update or create a Mention.
     * @example
     * // Update or create a Mention
     * const mention = await prisma.mention.upsert({
     *   create: {
     *     // ... data to create a Mention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mention we want to update
     *   }
     * })
     */
    upsert<T extends MentionUpsertArgs>(args: SelectSubset<T, MentionUpsertArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionCountArgs} args - Arguments to filter Mentions to count.
     * @example
     * // Count the number of Mentions
     * const count = await prisma.mention.count({
     *   where: {
     *     // ... the filter for the Mentions we want to count
     *   }
     * })
    **/
    count<T extends MentionCountArgs>(
      args?: Subset<T, MentionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentionAggregateArgs>(args: Subset<T, MentionAggregateArgs>): Prisma.PrismaPromise<GetMentionAggregateType<T>>

    /**
     * Group by Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentionGroupByArgs['orderBy'] }
        : { orderBy?: MentionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mention model
   */
  readonly fields: MentionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_Mention_mentionedIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_Mention_mentionerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mention model
   */
  interface MentionFieldRefs {
    readonly tweetId: FieldRef<"Mention", 'String'>
    readonly mentionerId: FieldRef<"Mention", 'String'>
    readonly mentionedId: FieldRef<"Mention", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mention findUnique
   */
  export type MentionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention findUniqueOrThrow
   */
  export type MentionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention findFirst
   */
  export type MentionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention findFirstOrThrow
   */
  export type MentionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention findMany
   */
  export type MentionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mentions to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention create
   */
  export type MentionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mention.
     */
    data: XOR<MentionCreateInput, MentionUncheckedCreateInput>
  }

  /**
   * Mention createMany
   */
  export type MentionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentions.
     */
    data: MentionCreateManyInput | MentionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mention createManyAndReturn
   */
  export type MentionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * The data used to create many Mentions.
     */
    data: MentionCreateManyInput | MentionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mention update
   */
  export type MentionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mention.
     */
    data: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
    /**
     * Choose, which Mention to update.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention updateMany
   */
  export type MentionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentions.
     */
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyInput>
    /**
     * Filter which Mentions to update
     */
    where?: MentionWhereInput
    /**
     * Limit how many Mentions to update.
     */
    limit?: number
  }

  /**
   * Mention updateManyAndReturn
   */
  export type MentionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * The data used to update Mentions.
     */
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyInput>
    /**
     * Filter which Mentions to update
     */
    where?: MentionWhereInput
    /**
     * Limit how many Mentions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mention upsert
   */
  export type MentionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mention to update in case it exists.
     */
    where: MentionWhereUniqueInput
    /**
     * In case the Mention found by the `where` argument doesn't exist, create a new Mention with this data.
     */
    create: XOR<MentionCreateInput, MentionUncheckedCreateInput>
    /**
     * In case the Mention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
  }

  /**
   * Mention delete
   */
  export type MentionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter which Mention to delete.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention deleteMany
   */
  export type MentionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentions to delete
     */
    where?: MentionWhereInput
    /**
     * Limit how many Mentions to delete.
     */
    limit?: number
  }

  /**
   * Mention without action
   */
  export type MentionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
  }


  /**
   * Model MessageMedia
   */

  export type AggregateMessageMedia = {
    _count: MessageMediaCountAggregateOutputType | null
    _min: MessageMediaMinAggregateOutputType | null
    _max: MessageMediaMaxAggregateOutputType | null
  }

  export type MessageMediaMinAggregateOutputType = {
    messageId: string | null
    mediaId: string | null
  }

  export type MessageMediaMaxAggregateOutputType = {
    messageId: string | null
    mediaId: string | null
  }

  export type MessageMediaCountAggregateOutputType = {
    messageId: number
    mediaId: number
    _all: number
  }


  export type MessageMediaMinAggregateInputType = {
    messageId?: true
    mediaId?: true
  }

  export type MessageMediaMaxAggregateInputType = {
    messageId?: true
    mediaId?: true
  }

  export type MessageMediaCountAggregateInputType = {
    messageId?: true
    mediaId?: true
    _all?: true
  }

  export type MessageMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageMedia to aggregate.
     */
    where?: MessageMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageMedias to fetch.
     */
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageMedias
    **/
    _count?: true | MessageMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMediaMaxAggregateInputType
  }

  export type GetMessageMediaAggregateType<T extends MessageMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageMedia[P]>
      : GetScalarType<T[P], AggregateMessageMedia[P]>
  }




  export type MessageMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageMediaWhereInput
    orderBy?: MessageMediaOrderByWithAggregationInput | MessageMediaOrderByWithAggregationInput[]
    by: MessageMediaScalarFieldEnum[] | MessageMediaScalarFieldEnum
    having?: MessageMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageMediaCountAggregateInputType | true
    _min?: MessageMediaMinAggregateInputType
    _max?: MessageMediaMaxAggregateInputType
  }

  export type MessageMediaGroupByOutputType = {
    messageId: string
    mediaId: string
    _count: MessageMediaCountAggregateOutputType | null
    _min: MessageMediaMinAggregateOutputType | null
    _max: MessageMediaMaxAggregateOutputType | null
  }

  type GetMessageMediaGroupByPayload<T extends MessageMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageMediaGroupByOutputType[P]>
            : GetScalarType<T[P], MessageMediaGroupByOutputType[P]>
        }
      >
    >


  export type MessageMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageMedia"]>

  export type MessageMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageMedia"]>

  export type MessageMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageMedia"]>

  export type MessageMediaSelectScalar = {
    messageId?: boolean
    mediaId?: boolean
  }

  export type MessageMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "mediaId", ExtArgs["result"]["messageMedia"]>
  export type MessageMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type MessageMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type MessageMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }

  export type $MessageMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageMedia"
    objects: {
      medias: Prisma.$mediasPayload<ExtArgs>
      messages: Prisma.$messagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      mediaId: string
    }, ExtArgs["result"]["messageMedia"]>
    composites: {}
  }

  type MessageMediaGetPayload<S extends boolean | null | undefined | MessageMediaDefaultArgs> = $Result.GetResult<Prisma.$MessageMediaPayload, S>

  type MessageMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageMediaCountAggregateInputType | true
    }

  export interface MessageMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageMedia'], meta: { name: 'MessageMedia' } }
    /**
     * Find zero or one MessageMedia that matches the filter.
     * @param {MessageMediaFindUniqueArgs} args - Arguments to find a MessageMedia
     * @example
     * // Get one MessageMedia
     * const messageMedia = await prisma.messageMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageMediaFindUniqueArgs>(args: SelectSubset<T, MessageMediaFindUniqueArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageMediaFindUniqueOrThrowArgs} args - Arguments to find a MessageMedia
     * @example
     * // Get one MessageMedia
     * const messageMedia = await prisma.messageMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaFindFirstArgs} args - Arguments to find a MessageMedia
     * @example
     * // Get one MessageMedia
     * const messageMedia = await prisma.messageMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageMediaFindFirstArgs>(args?: SelectSubset<T, MessageMediaFindFirstArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaFindFirstOrThrowArgs} args - Arguments to find a MessageMedia
     * @example
     * // Get one MessageMedia
     * const messageMedia = await prisma.messageMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageMedias
     * const messageMedias = await prisma.messageMedia.findMany()
     * 
     * // Get first 10 MessageMedias
     * const messageMedias = await prisma.messageMedia.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageMediaWithMessageIdOnly = await prisma.messageMedia.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends MessageMediaFindManyArgs>(args?: SelectSubset<T, MessageMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageMedia.
     * @param {MessageMediaCreateArgs} args - Arguments to create a MessageMedia.
     * @example
     * // Create one MessageMedia
     * const MessageMedia = await prisma.messageMedia.create({
     *   data: {
     *     // ... data to create a MessageMedia
     *   }
     * })
     * 
     */
    create<T extends MessageMediaCreateArgs>(args: SelectSubset<T, MessageMediaCreateArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageMedias.
     * @param {MessageMediaCreateManyArgs} args - Arguments to create many MessageMedias.
     * @example
     * // Create many MessageMedias
     * const messageMedia = await prisma.messageMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageMediaCreateManyArgs>(args?: SelectSubset<T, MessageMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageMedias and returns the data saved in the database.
     * @param {MessageMediaCreateManyAndReturnArgs} args - Arguments to create many MessageMedias.
     * @example
     * // Create many MessageMedias
     * const messageMedia = await prisma.messageMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageMedias and only return the `messageId`
     * const messageMediaWithMessageIdOnly = await prisma.messageMedia.createManyAndReturn({
     *   select: { messageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageMedia.
     * @param {MessageMediaDeleteArgs} args - Arguments to delete one MessageMedia.
     * @example
     * // Delete one MessageMedia
     * const MessageMedia = await prisma.messageMedia.delete({
     *   where: {
     *     // ... filter to delete one MessageMedia
     *   }
     * })
     * 
     */
    delete<T extends MessageMediaDeleteArgs>(args: SelectSubset<T, MessageMediaDeleteArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageMedia.
     * @param {MessageMediaUpdateArgs} args - Arguments to update one MessageMedia.
     * @example
     * // Update one MessageMedia
     * const messageMedia = await prisma.messageMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageMediaUpdateArgs>(args: SelectSubset<T, MessageMediaUpdateArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageMedias.
     * @param {MessageMediaDeleteManyArgs} args - Arguments to filter MessageMedias to delete.
     * @example
     * // Delete a few MessageMedias
     * const { count } = await prisma.messageMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageMediaDeleteManyArgs>(args?: SelectSubset<T, MessageMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageMedias
     * const messageMedia = await prisma.messageMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageMediaUpdateManyArgs>(args: SelectSubset<T, MessageMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageMedias and returns the data updated in the database.
     * @param {MessageMediaUpdateManyAndReturnArgs} args - Arguments to update many MessageMedias.
     * @example
     * // Update many MessageMedias
     * const messageMedia = await prisma.messageMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageMedias and only return the `messageId`
     * const messageMediaWithMessageIdOnly = await prisma.messageMedia.updateManyAndReturn({
     *   select: { messageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageMedia.
     * @param {MessageMediaUpsertArgs} args - Arguments to update or create a MessageMedia.
     * @example
     * // Update or create a MessageMedia
     * const messageMedia = await prisma.messageMedia.upsert({
     *   create: {
     *     // ... data to create a MessageMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageMedia we want to update
     *   }
     * })
     */
    upsert<T extends MessageMediaUpsertArgs>(args: SelectSubset<T, MessageMediaUpsertArgs<ExtArgs>>): Prisma__MessageMediaClient<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaCountArgs} args - Arguments to filter MessageMedias to count.
     * @example
     * // Count the number of MessageMedias
     * const count = await prisma.messageMedia.count({
     *   where: {
     *     // ... the filter for the MessageMedias we want to count
     *   }
     * })
    **/
    count<T extends MessageMediaCountArgs>(
      args?: Subset<T, MessageMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageMediaAggregateArgs>(args: Subset<T, MessageMediaAggregateArgs>): Prisma.PrismaPromise<GetMessageMediaAggregateType<T>>

    /**
     * Group by MessageMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageMediaGroupByArgs['orderBy'] }
        : { orderBy?: MessageMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageMedia model
   */
  readonly fields: MessageMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medias<T extends mediasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mediasDefaultArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends messagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, messagesDefaultArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageMedia model
   */
  interface MessageMediaFieldRefs {
    readonly messageId: FieldRef<"MessageMedia", 'String'>
    readonly mediaId: FieldRef<"MessageMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageMedia findUnique
   */
  export type MessageMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter, which MessageMedia to fetch.
     */
    where: MessageMediaWhereUniqueInput
  }

  /**
   * MessageMedia findUniqueOrThrow
   */
  export type MessageMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter, which MessageMedia to fetch.
     */
    where: MessageMediaWhereUniqueInput
  }

  /**
   * MessageMedia findFirst
   */
  export type MessageMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter, which MessageMedia to fetch.
     */
    where?: MessageMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageMedias to fetch.
     */
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageMedias.
     */
    cursor?: MessageMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageMedias.
     */
    distinct?: MessageMediaScalarFieldEnum | MessageMediaScalarFieldEnum[]
  }

  /**
   * MessageMedia findFirstOrThrow
   */
  export type MessageMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter, which MessageMedia to fetch.
     */
    where?: MessageMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageMedias to fetch.
     */
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageMedias.
     */
    cursor?: MessageMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageMedias.
     */
    distinct?: MessageMediaScalarFieldEnum | MessageMediaScalarFieldEnum[]
  }

  /**
   * MessageMedia findMany
   */
  export type MessageMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter, which MessageMedias to fetch.
     */
    where?: MessageMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageMedias to fetch.
     */
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageMedias.
     */
    cursor?: MessageMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageMedias.
     */
    skip?: number
    distinct?: MessageMediaScalarFieldEnum | MessageMediaScalarFieldEnum[]
  }

  /**
   * MessageMedia create
   */
  export type MessageMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageMedia.
     */
    data: XOR<MessageMediaCreateInput, MessageMediaUncheckedCreateInput>
  }

  /**
   * MessageMedia createMany
   */
  export type MessageMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageMedias.
     */
    data: MessageMediaCreateManyInput | MessageMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageMedia createManyAndReturn
   */
  export type MessageMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * The data used to create many MessageMedias.
     */
    data: MessageMediaCreateManyInput | MessageMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageMedia update
   */
  export type MessageMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageMedia.
     */
    data: XOR<MessageMediaUpdateInput, MessageMediaUncheckedUpdateInput>
    /**
     * Choose, which MessageMedia to update.
     */
    where: MessageMediaWhereUniqueInput
  }

  /**
   * MessageMedia updateMany
   */
  export type MessageMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageMedias.
     */
    data: XOR<MessageMediaUpdateManyMutationInput, MessageMediaUncheckedUpdateManyInput>
    /**
     * Filter which MessageMedias to update
     */
    where?: MessageMediaWhereInput
    /**
     * Limit how many MessageMedias to update.
     */
    limit?: number
  }

  /**
   * MessageMedia updateManyAndReturn
   */
  export type MessageMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * The data used to update MessageMedias.
     */
    data: XOR<MessageMediaUpdateManyMutationInput, MessageMediaUncheckedUpdateManyInput>
    /**
     * Filter which MessageMedias to update
     */
    where?: MessageMediaWhereInput
    /**
     * Limit how many MessageMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageMedia upsert
   */
  export type MessageMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageMedia to update in case it exists.
     */
    where: MessageMediaWhereUniqueInput
    /**
     * In case the MessageMedia found by the `where` argument doesn't exist, create a new MessageMedia with this data.
     */
    create: XOR<MessageMediaCreateInput, MessageMediaUncheckedCreateInput>
    /**
     * In case the MessageMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageMediaUpdateInput, MessageMediaUncheckedUpdateInput>
  }

  /**
   * MessageMedia delete
   */
  export type MessageMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    /**
     * Filter which MessageMedia to delete.
     */
    where: MessageMediaWhereUniqueInput
  }

  /**
   * MessageMedia deleteMany
   */
  export type MessageMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageMedias to delete
     */
    where?: MessageMediaWhereInput
    /**
     * Limit how many MessageMedias to delete.
     */
    limit?: number
  }

  /**
   * MessageMedia without action
   */
  export type MessageMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
  }


  /**
   * Model Mute
   */

  export type AggregateMute = {
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  export type MuteMinAggregateOutputType = {
    mutedId: string | null
    muterId: string | null
  }

  export type MuteMaxAggregateOutputType = {
    mutedId: string | null
    muterId: string | null
  }

  export type MuteCountAggregateOutputType = {
    mutedId: number
    muterId: number
    _all: number
  }


  export type MuteMinAggregateInputType = {
    mutedId?: true
    muterId?: true
  }

  export type MuteMaxAggregateInputType = {
    mutedId?: true
    muterId?: true
  }

  export type MuteCountAggregateInputType = {
    mutedId?: true
    muterId?: true
    _all?: true
  }

  export type MuteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mute to aggregate.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mutes
    **/
    _count?: true | MuteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuteMaxAggregateInputType
  }

  export type GetMuteAggregateType<T extends MuteAggregateArgs> = {
        [P in keyof T & keyof AggregateMute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMute[P]>
      : GetScalarType<T[P], AggregateMute[P]>
  }




  export type MuteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithAggregationInput | MuteOrderByWithAggregationInput[]
    by: MuteScalarFieldEnum[] | MuteScalarFieldEnum
    having?: MuteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuteCountAggregateInputType | true
    _min?: MuteMinAggregateInputType
    _max?: MuteMaxAggregateInputType
  }

  export type MuteGroupByOutputType = {
    mutedId: string
    muterId: string
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  type GetMuteGroupByPayload<T extends MuteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuteGroupByOutputType[P]>
            : GetScalarType<T[P], MuteGroupByOutputType[P]>
        }
      >
    >


  export type MuteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mutedId?: boolean
    muterId?: boolean
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mutedId?: boolean
    muterId?: boolean
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mutedId?: boolean
    muterId?: boolean
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectScalar = {
    mutedId?: boolean
    muterId?: boolean
  }

  export type MuteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mutedId" | "muterId", ExtArgs["result"]["mute"]>
  export type MuteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type MuteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type MuteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_Mute_mutedIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_Mute_muterIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $MutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mute"
    objects: {
      users_Mute_mutedIdTousers: Prisma.$usersPayload<ExtArgs>
      users_Mute_muterIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mutedId: string
      muterId: string
    }, ExtArgs["result"]["mute"]>
    composites: {}
  }

  type MuteGetPayload<S extends boolean | null | undefined | MuteDefaultArgs> = $Result.GetResult<Prisma.$MutePayload, S>

  type MuteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MuteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MuteCountAggregateInputType | true
    }

  export interface MuteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mute'], meta: { name: 'Mute' } }
    /**
     * Find zero or one Mute that matches the filter.
     * @param {MuteFindUniqueArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MuteFindUniqueArgs>(args: SelectSubset<T, MuteFindUniqueArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MuteFindUniqueOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MuteFindUniqueOrThrowArgs>(args: SelectSubset<T, MuteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MuteFindFirstArgs>(args?: SelectSubset<T, MuteFindFirstArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MuteFindFirstOrThrowArgs>(args?: SelectSubset<T, MuteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mutes
     * const mutes = await prisma.mute.findMany()
     * 
     * // Get first 10 Mutes
     * const mutes = await prisma.mute.findMany({ take: 10 })
     * 
     * // Only select the `mutedId`
     * const muteWithMutedIdOnly = await prisma.mute.findMany({ select: { mutedId: true } })
     * 
     */
    findMany<T extends MuteFindManyArgs>(args?: SelectSubset<T, MuteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mute.
     * @param {MuteCreateArgs} args - Arguments to create a Mute.
     * @example
     * // Create one Mute
     * const Mute = await prisma.mute.create({
     *   data: {
     *     // ... data to create a Mute
     *   }
     * })
     * 
     */
    create<T extends MuteCreateArgs>(args: SelectSubset<T, MuteCreateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mutes.
     * @param {MuteCreateManyArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MuteCreateManyArgs>(args?: SelectSubset<T, MuteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mutes and returns the data saved in the database.
     * @param {MuteCreateManyAndReturnArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mutes and only return the `mutedId`
     * const muteWithMutedIdOnly = await prisma.mute.createManyAndReturn({
     *   select: { mutedId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MuteCreateManyAndReturnArgs>(args?: SelectSubset<T, MuteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mute.
     * @param {MuteDeleteArgs} args - Arguments to delete one Mute.
     * @example
     * // Delete one Mute
     * const Mute = await prisma.mute.delete({
     *   where: {
     *     // ... filter to delete one Mute
     *   }
     * })
     * 
     */
    delete<T extends MuteDeleteArgs>(args: SelectSubset<T, MuteDeleteArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mute.
     * @param {MuteUpdateArgs} args - Arguments to update one Mute.
     * @example
     * // Update one Mute
     * const mute = await prisma.mute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MuteUpdateArgs>(args: SelectSubset<T, MuteUpdateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mutes.
     * @param {MuteDeleteManyArgs} args - Arguments to filter Mutes to delete.
     * @example
     * // Delete a few Mutes
     * const { count } = await prisma.mute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MuteDeleteManyArgs>(args?: SelectSubset<T, MuteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MuteUpdateManyArgs>(args: SelectSubset<T, MuteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes and returns the data updated in the database.
     * @param {MuteUpdateManyAndReturnArgs} args - Arguments to update many Mutes.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mutes and only return the `mutedId`
     * const muteWithMutedIdOnly = await prisma.mute.updateManyAndReturn({
     *   select: { mutedId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MuteUpdateManyAndReturnArgs>(args: SelectSubset<T, MuteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mute.
     * @param {MuteUpsertArgs} args - Arguments to update or create a Mute.
     * @example
     * // Update or create a Mute
     * const mute = await prisma.mute.upsert({
     *   create: {
     *     // ... data to create a Mute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mute we want to update
     *   }
     * })
     */
    upsert<T extends MuteUpsertArgs>(args: SelectSubset<T, MuteUpsertArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteCountArgs} args - Arguments to filter Mutes to count.
     * @example
     * // Count the number of Mutes
     * const count = await prisma.mute.count({
     *   where: {
     *     // ... the filter for the Mutes we want to count
     *   }
     * })
    **/
    count<T extends MuteCountArgs>(
      args?: Subset<T, MuteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuteAggregateArgs>(args: Subset<T, MuteAggregateArgs>): Prisma.PrismaPromise<GetMuteAggregateType<T>>

    /**
     * Group by Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuteGroupByArgs['orderBy'] }
        : { orderBy?: MuteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mute model
   */
  readonly fields: MuteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_Mute_mutedIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_Mute_muterIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mute model
   */
  interface MuteFieldRefs {
    readonly mutedId: FieldRef<"Mute", 'String'>
    readonly muterId: FieldRef<"Mute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mute findUnique
   */
  export type MuteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findUniqueOrThrow
   */
  export type MuteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findFirst
   */
  export type MuteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findFirstOrThrow
   */
  export type MuteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findMany
   */
  export type MuteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mutes to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute create
   */
  export type MuteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to create a Mute.
     */
    data: XOR<MuteCreateInput, MuteUncheckedCreateInput>
  }

  /**
   * Mute createMany
   */
  export type MuteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mute createManyAndReturn
   */
  export type MuteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute update
   */
  export type MuteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to update a Mute.
     */
    data: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
    /**
     * Choose, which Mute to update.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute updateMany
   */
  export type MuteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
  }

  /**
   * Mute updateManyAndReturn
   */
  export type MuteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute upsert
   */
  export type MuteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The filter to search for the Mute to update in case it exists.
     */
    where: MuteWhereUniqueInput
    /**
     * In case the Mute found by the `where` argument doesn't exist, create a new Mute with this data.
     */
    create: XOR<MuteCreateInput, MuteUncheckedCreateInput>
    /**
     * In case the Mute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
  }

  /**
   * Mute delete
   */
  export type MuteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter which Mute to delete.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute deleteMany
   */
  export type MuteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mutes to delete
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to delete.
     */
    limit?: number
  }

  /**
   * Mute without action
   */
  export type MuteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
  }


  /**
   * Model Retweet
   */

  export type AggregateRetweet = {
    _count: RetweetCountAggregateOutputType | null
    _min: RetweetMinAggregateOutputType | null
    _max: RetweetMaxAggregateOutputType | null
  }

  export type RetweetMinAggregateOutputType = {
    userId: string | null
    tweetId: string | null
  }

  export type RetweetMaxAggregateOutputType = {
    userId: string | null
    tweetId: string | null
  }

  export type RetweetCountAggregateOutputType = {
    userId: number
    tweetId: number
    _all: number
  }


  export type RetweetMinAggregateInputType = {
    userId?: true
    tweetId?: true
  }

  export type RetweetMaxAggregateInputType = {
    userId?: true
    tweetId?: true
  }

  export type RetweetCountAggregateInputType = {
    userId?: true
    tweetId?: true
    _all?: true
  }

  export type RetweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retweet to aggregate.
     */
    where?: RetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retweets to fetch.
     */
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Retweets
    **/
    _count?: true | RetweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetweetMaxAggregateInputType
  }

  export type GetRetweetAggregateType<T extends RetweetAggregateArgs> = {
        [P in keyof T & keyof AggregateRetweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetweet[P]>
      : GetScalarType<T[P], AggregateRetweet[P]>
  }




  export type RetweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetweetWhereInput
    orderBy?: RetweetOrderByWithAggregationInput | RetweetOrderByWithAggregationInput[]
    by: RetweetScalarFieldEnum[] | RetweetScalarFieldEnum
    having?: RetweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetweetCountAggregateInputType | true
    _min?: RetweetMinAggregateInputType
    _max?: RetweetMaxAggregateInputType
  }

  export type RetweetGroupByOutputType = {
    userId: string
    tweetId: string
    _count: RetweetCountAggregateOutputType | null
    _min: RetweetMinAggregateOutputType | null
    _max: RetweetMaxAggregateOutputType | null
  }

  type GetRetweetGroupByPayload<T extends RetweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetweetGroupByOutputType[P]>
            : GetScalarType<T[P], RetweetGroupByOutputType[P]>
        }
      >
    >


  export type RetweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retweet"]>

  export type RetweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retweet"]>

  export type RetweetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retweet"]>

  export type RetweetSelectScalar = {
    userId?: boolean
    tweetId?: boolean
  }

  export type RetweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "tweetId", ExtArgs["result"]["retweet"]>
  export type RetweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type RetweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type RetweetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $RetweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Retweet"
    objects: {
      tweets: Prisma.$tweetsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      tweetId: string
    }, ExtArgs["result"]["retweet"]>
    composites: {}
  }

  type RetweetGetPayload<S extends boolean | null | undefined | RetweetDefaultArgs> = $Result.GetResult<Prisma.$RetweetPayload, S>

  type RetweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RetweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RetweetCountAggregateInputType | true
    }

  export interface RetweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Retweet'], meta: { name: 'Retweet' } }
    /**
     * Find zero or one Retweet that matches the filter.
     * @param {RetweetFindUniqueArgs} args - Arguments to find a Retweet
     * @example
     * // Get one Retweet
     * const retweet = await prisma.retweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetweetFindUniqueArgs>(args: SelectSubset<T, RetweetFindUniqueArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Retweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RetweetFindUniqueOrThrowArgs} args - Arguments to find a Retweet
     * @example
     * // Get one Retweet
     * const retweet = await prisma.retweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetweetFindUniqueOrThrowArgs>(args: SelectSubset<T, RetweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetFindFirstArgs} args - Arguments to find a Retweet
     * @example
     * // Get one Retweet
     * const retweet = await prisma.retweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetweetFindFirstArgs>(args?: SelectSubset<T, RetweetFindFirstArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetFindFirstOrThrowArgs} args - Arguments to find a Retweet
     * @example
     * // Get one Retweet
     * const retweet = await prisma.retweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetweetFindFirstOrThrowArgs>(args?: SelectSubset<T, RetweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Retweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Retweets
     * const retweets = await prisma.retweet.findMany()
     * 
     * // Get first 10 Retweets
     * const retweets = await prisma.retweet.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const retweetWithUserIdOnly = await prisma.retweet.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends RetweetFindManyArgs>(args?: SelectSubset<T, RetweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Retweet.
     * @param {RetweetCreateArgs} args - Arguments to create a Retweet.
     * @example
     * // Create one Retweet
     * const Retweet = await prisma.retweet.create({
     *   data: {
     *     // ... data to create a Retweet
     *   }
     * })
     * 
     */
    create<T extends RetweetCreateArgs>(args: SelectSubset<T, RetweetCreateArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Retweets.
     * @param {RetweetCreateManyArgs} args - Arguments to create many Retweets.
     * @example
     * // Create many Retweets
     * const retweet = await prisma.retweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetweetCreateManyArgs>(args?: SelectSubset<T, RetweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Retweets and returns the data saved in the database.
     * @param {RetweetCreateManyAndReturnArgs} args - Arguments to create many Retweets.
     * @example
     * // Create many Retweets
     * const retweet = await prisma.retweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Retweets and only return the `userId`
     * const retweetWithUserIdOnly = await prisma.retweet.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetweetCreateManyAndReturnArgs>(args?: SelectSubset<T, RetweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Retweet.
     * @param {RetweetDeleteArgs} args - Arguments to delete one Retweet.
     * @example
     * // Delete one Retweet
     * const Retweet = await prisma.retweet.delete({
     *   where: {
     *     // ... filter to delete one Retweet
     *   }
     * })
     * 
     */
    delete<T extends RetweetDeleteArgs>(args: SelectSubset<T, RetweetDeleteArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Retweet.
     * @param {RetweetUpdateArgs} args - Arguments to update one Retweet.
     * @example
     * // Update one Retweet
     * const retweet = await prisma.retweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetweetUpdateArgs>(args: SelectSubset<T, RetweetUpdateArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Retweets.
     * @param {RetweetDeleteManyArgs} args - Arguments to filter Retweets to delete.
     * @example
     * // Delete a few Retweets
     * const { count } = await prisma.retweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetweetDeleteManyArgs>(args?: SelectSubset<T, RetweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Retweets
     * const retweet = await prisma.retweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetweetUpdateManyArgs>(args: SelectSubset<T, RetweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retweets and returns the data updated in the database.
     * @param {RetweetUpdateManyAndReturnArgs} args - Arguments to update many Retweets.
     * @example
     * // Update many Retweets
     * const retweet = await prisma.retweet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Retweets and only return the `userId`
     * const retweetWithUserIdOnly = await prisma.retweet.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RetweetUpdateManyAndReturnArgs>(args: SelectSubset<T, RetweetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Retweet.
     * @param {RetweetUpsertArgs} args - Arguments to update or create a Retweet.
     * @example
     * // Update or create a Retweet
     * const retweet = await prisma.retweet.upsert({
     *   create: {
     *     // ... data to create a Retweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Retweet we want to update
     *   }
     * })
     */
    upsert<T extends RetweetUpsertArgs>(args: SelectSubset<T, RetweetUpsertArgs<ExtArgs>>): Prisma__RetweetClient<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Retweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetCountArgs} args - Arguments to filter Retweets to count.
     * @example
     * // Count the number of Retweets
     * const count = await prisma.retweet.count({
     *   where: {
     *     // ... the filter for the Retweets we want to count
     *   }
     * })
    **/
    count<T extends RetweetCountArgs>(
      args?: Subset<T, RetweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Retweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetweetAggregateArgs>(args: Subset<T, RetweetAggregateArgs>): Prisma.PrismaPromise<GetRetweetAggregateType<T>>

    /**
     * Group by Retweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetweetGroupByArgs['orderBy'] }
        : { orderBy?: RetweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Retweet model
   */
  readonly fields: RetweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Retweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Retweet model
   */
  interface RetweetFieldRefs {
    readonly userId: FieldRef<"Retweet", 'String'>
    readonly tweetId: FieldRef<"Retweet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Retweet findUnique
   */
  export type RetweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter, which Retweet to fetch.
     */
    where: RetweetWhereUniqueInput
  }

  /**
   * Retweet findUniqueOrThrow
   */
  export type RetweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter, which Retweet to fetch.
     */
    where: RetweetWhereUniqueInput
  }

  /**
   * Retweet findFirst
   */
  export type RetweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter, which Retweet to fetch.
     */
    where?: RetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retweets to fetch.
     */
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retweets.
     */
    cursor?: RetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retweets.
     */
    distinct?: RetweetScalarFieldEnum | RetweetScalarFieldEnum[]
  }

  /**
   * Retweet findFirstOrThrow
   */
  export type RetweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter, which Retweet to fetch.
     */
    where?: RetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retweets to fetch.
     */
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retweets.
     */
    cursor?: RetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retweets.
     */
    distinct?: RetweetScalarFieldEnum | RetweetScalarFieldEnum[]
  }

  /**
   * Retweet findMany
   */
  export type RetweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter, which Retweets to fetch.
     */
    where?: RetweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retweets to fetch.
     */
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Retweets.
     */
    cursor?: RetweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retweets.
     */
    skip?: number
    distinct?: RetweetScalarFieldEnum | RetweetScalarFieldEnum[]
  }

  /**
   * Retweet create
   */
  export type RetweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * The data needed to create a Retweet.
     */
    data: XOR<RetweetCreateInput, RetweetUncheckedCreateInput>
  }

  /**
   * Retweet createMany
   */
  export type RetweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Retweets.
     */
    data: RetweetCreateManyInput | RetweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Retweet createManyAndReturn
   */
  export type RetweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * The data used to create many Retweets.
     */
    data: RetweetCreateManyInput | RetweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Retweet update
   */
  export type RetweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * The data needed to update a Retweet.
     */
    data: XOR<RetweetUpdateInput, RetweetUncheckedUpdateInput>
    /**
     * Choose, which Retweet to update.
     */
    where: RetweetWhereUniqueInput
  }

  /**
   * Retweet updateMany
   */
  export type RetweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Retweets.
     */
    data: XOR<RetweetUpdateManyMutationInput, RetweetUncheckedUpdateManyInput>
    /**
     * Filter which Retweets to update
     */
    where?: RetweetWhereInput
    /**
     * Limit how many Retweets to update.
     */
    limit?: number
  }

  /**
   * Retweet updateManyAndReturn
   */
  export type RetweetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * The data used to update Retweets.
     */
    data: XOR<RetweetUpdateManyMutationInput, RetweetUncheckedUpdateManyInput>
    /**
     * Filter which Retweets to update
     */
    where?: RetweetWhereInput
    /**
     * Limit how many Retweets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Retweet upsert
   */
  export type RetweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * The filter to search for the Retweet to update in case it exists.
     */
    where: RetweetWhereUniqueInput
    /**
     * In case the Retweet found by the `where` argument doesn't exist, create a new Retweet with this data.
     */
    create: XOR<RetweetCreateInput, RetweetUncheckedCreateInput>
    /**
     * In case the Retweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetweetUpdateInput, RetweetUncheckedUpdateInput>
  }

  /**
   * Retweet delete
   */
  export type RetweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    /**
     * Filter which Retweet to delete.
     */
    where: RetweetWhereUniqueInput
  }

  /**
   * Retweet deleteMany
   */
  export type RetweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retweets to delete
     */
    where?: RetweetWhereInput
    /**
     * Limit how many Retweets to delete.
     */
    limit?: number
  }

  /**
   * Retweet without action
   */
  export type RetweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
  }


  /**
   * Model TweetLike
   */

  export type AggregateTweetLike = {
    _count: TweetLikeCountAggregateOutputType | null
    _min: TweetLikeMinAggregateOutputType | null
    _max: TweetLikeMaxAggregateOutputType | null
  }

  export type TweetLikeMinAggregateOutputType = {
    tweetId: string | null
    userId: string | null
  }

  export type TweetLikeMaxAggregateOutputType = {
    tweetId: string | null
    userId: string | null
  }

  export type TweetLikeCountAggregateOutputType = {
    tweetId: number
    userId: number
    _all: number
  }


  export type TweetLikeMinAggregateInputType = {
    tweetId?: true
    userId?: true
  }

  export type TweetLikeMaxAggregateInputType = {
    tweetId?: true
    userId?: true
  }

  export type TweetLikeCountAggregateInputType = {
    tweetId?: true
    userId?: true
    _all?: true
  }

  export type TweetLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetLike to aggregate.
     */
    where?: TweetLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetLikes to fetch.
     */
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TweetLikes
    **/
    _count?: true | TweetLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetLikeMaxAggregateInputType
  }

  export type GetTweetLikeAggregateType<T extends TweetLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetLike[P]>
      : GetScalarType<T[P], AggregateTweetLike[P]>
  }




  export type TweetLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetLikeWhereInput
    orderBy?: TweetLikeOrderByWithAggregationInput | TweetLikeOrderByWithAggregationInput[]
    by: TweetLikeScalarFieldEnum[] | TweetLikeScalarFieldEnum
    having?: TweetLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetLikeCountAggregateInputType | true
    _min?: TweetLikeMinAggregateInputType
    _max?: TweetLikeMaxAggregateInputType
  }

  export type TweetLikeGroupByOutputType = {
    tweetId: string
    userId: string
    _count: TweetLikeCountAggregateOutputType | null
    _min: TweetLikeMinAggregateOutputType | null
    _max: TweetLikeMaxAggregateOutputType | null
  }

  type GetTweetLikeGroupByPayload<T extends TweetLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetLikeGroupByOutputType[P]>
            : GetScalarType<T[P], TweetLikeGroupByOutputType[P]>
        }
      >
    >


  export type TweetLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    userId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetLike"]>

  export type TweetLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    userId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetLike"]>

  export type TweetLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    userId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetLike"]>

  export type TweetLikeSelectScalar = {
    tweetId?: boolean
    userId?: boolean
  }

  export type TweetLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tweetId" | "userId", ExtArgs["result"]["tweetLike"]>
  export type TweetLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type TweetLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type TweetLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $TweetLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TweetLike"
    objects: {
      tweets: Prisma.$tweetsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tweetId: string
      userId: string
    }, ExtArgs["result"]["tweetLike"]>
    composites: {}
  }

  type TweetLikeGetPayload<S extends boolean | null | undefined | TweetLikeDefaultArgs> = $Result.GetResult<Prisma.$TweetLikePayload, S>

  type TweetLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetLikeCountAggregateInputType | true
    }

  export interface TweetLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TweetLike'], meta: { name: 'TweetLike' } }
    /**
     * Find zero or one TweetLike that matches the filter.
     * @param {TweetLikeFindUniqueArgs} args - Arguments to find a TweetLike
     * @example
     * // Get one TweetLike
     * const tweetLike = await prisma.tweetLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetLikeFindUniqueArgs>(args: SelectSubset<T, TweetLikeFindUniqueArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TweetLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetLikeFindUniqueOrThrowArgs} args - Arguments to find a TweetLike
     * @example
     * // Get one TweetLike
     * const tweetLike = await prisma.tweetLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeFindFirstArgs} args - Arguments to find a TweetLike
     * @example
     * // Get one TweetLike
     * const tweetLike = await prisma.tweetLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetLikeFindFirstArgs>(args?: SelectSubset<T, TweetLikeFindFirstArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeFindFirstOrThrowArgs} args - Arguments to find a TweetLike
     * @example
     * // Get one TweetLike
     * const tweetLike = await prisma.tweetLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TweetLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TweetLikes
     * const tweetLikes = await prisma.tweetLike.findMany()
     * 
     * // Get first 10 TweetLikes
     * const tweetLikes = await prisma.tweetLike.findMany({ take: 10 })
     * 
     * // Only select the `tweetId`
     * const tweetLikeWithTweetIdOnly = await prisma.tweetLike.findMany({ select: { tweetId: true } })
     * 
     */
    findMany<T extends TweetLikeFindManyArgs>(args?: SelectSubset<T, TweetLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TweetLike.
     * @param {TweetLikeCreateArgs} args - Arguments to create a TweetLike.
     * @example
     * // Create one TweetLike
     * const TweetLike = await prisma.tweetLike.create({
     *   data: {
     *     // ... data to create a TweetLike
     *   }
     * })
     * 
     */
    create<T extends TweetLikeCreateArgs>(args: SelectSubset<T, TweetLikeCreateArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TweetLikes.
     * @param {TweetLikeCreateManyArgs} args - Arguments to create many TweetLikes.
     * @example
     * // Create many TweetLikes
     * const tweetLike = await prisma.tweetLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetLikeCreateManyArgs>(args?: SelectSubset<T, TweetLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TweetLikes and returns the data saved in the database.
     * @param {TweetLikeCreateManyAndReturnArgs} args - Arguments to create many TweetLikes.
     * @example
     * // Create many TweetLikes
     * const tweetLike = await prisma.tweetLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TweetLikes and only return the `tweetId`
     * const tweetLikeWithTweetIdOnly = await prisma.tweetLike.createManyAndReturn({
     *   select: { tweetId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TweetLike.
     * @param {TweetLikeDeleteArgs} args - Arguments to delete one TweetLike.
     * @example
     * // Delete one TweetLike
     * const TweetLike = await prisma.tweetLike.delete({
     *   where: {
     *     // ... filter to delete one TweetLike
     *   }
     * })
     * 
     */
    delete<T extends TweetLikeDeleteArgs>(args: SelectSubset<T, TweetLikeDeleteArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TweetLike.
     * @param {TweetLikeUpdateArgs} args - Arguments to update one TweetLike.
     * @example
     * // Update one TweetLike
     * const tweetLike = await prisma.tweetLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetLikeUpdateArgs>(args: SelectSubset<T, TweetLikeUpdateArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TweetLikes.
     * @param {TweetLikeDeleteManyArgs} args - Arguments to filter TweetLikes to delete.
     * @example
     * // Delete a few TweetLikes
     * const { count } = await prisma.tweetLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetLikeDeleteManyArgs>(args?: SelectSubset<T, TweetLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TweetLikes
     * const tweetLike = await prisma.tweetLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetLikeUpdateManyArgs>(args: SelectSubset<T, TweetLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetLikes and returns the data updated in the database.
     * @param {TweetLikeUpdateManyAndReturnArgs} args - Arguments to update many TweetLikes.
     * @example
     * // Update many TweetLikes
     * const tweetLike = await prisma.tweetLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TweetLikes and only return the `tweetId`
     * const tweetLikeWithTweetIdOnly = await prisma.tweetLike.updateManyAndReturn({
     *   select: { tweetId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TweetLike.
     * @param {TweetLikeUpsertArgs} args - Arguments to update or create a TweetLike.
     * @example
     * // Update or create a TweetLike
     * const tweetLike = await prisma.tweetLike.upsert({
     *   create: {
     *     // ... data to create a TweetLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TweetLike we want to update
     *   }
     * })
     */
    upsert<T extends TweetLikeUpsertArgs>(args: SelectSubset<T, TweetLikeUpsertArgs<ExtArgs>>): Prisma__TweetLikeClient<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TweetLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeCountArgs} args - Arguments to filter TweetLikes to count.
     * @example
     * // Count the number of TweetLikes
     * const count = await prisma.tweetLike.count({
     *   where: {
     *     // ... the filter for the TweetLikes we want to count
     *   }
     * })
    **/
    count<T extends TweetLikeCountArgs>(
      args?: Subset<T, TweetLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TweetLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetLikeAggregateArgs>(args: Subset<T, TweetLikeAggregateArgs>): Prisma.PrismaPromise<GetTweetLikeAggregateType<T>>

    /**
     * Group by TweetLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetLikeGroupByArgs['orderBy'] }
        : { orderBy?: TweetLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TweetLike model
   */
  readonly fields: TweetLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TweetLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TweetLike model
   */
  interface TweetLikeFieldRefs {
    readonly tweetId: FieldRef<"TweetLike", 'String'>
    readonly userId: FieldRef<"TweetLike", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TweetLike findUnique
   */
  export type TweetLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter, which TweetLike to fetch.
     */
    where: TweetLikeWhereUniqueInput
  }

  /**
   * TweetLike findUniqueOrThrow
   */
  export type TweetLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter, which TweetLike to fetch.
     */
    where: TweetLikeWhereUniqueInput
  }

  /**
   * TweetLike findFirst
   */
  export type TweetLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter, which TweetLike to fetch.
     */
    where?: TweetLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetLikes to fetch.
     */
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetLikes.
     */
    cursor?: TweetLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetLikes.
     */
    distinct?: TweetLikeScalarFieldEnum | TweetLikeScalarFieldEnum[]
  }

  /**
   * TweetLike findFirstOrThrow
   */
  export type TweetLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter, which TweetLike to fetch.
     */
    where?: TweetLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetLikes to fetch.
     */
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetLikes.
     */
    cursor?: TweetLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetLikes.
     */
    distinct?: TweetLikeScalarFieldEnum | TweetLikeScalarFieldEnum[]
  }

  /**
   * TweetLike findMany
   */
  export type TweetLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter, which TweetLikes to fetch.
     */
    where?: TweetLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetLikes to fetch.
     */
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TweetLikes.
     */
    cursor?: TweetLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetLikes.
     */
    skip?: number
    distinct?: TweetLikeScalarFieldEnum | TweetLikeScalarFieldEnum[]
  }

  /**
   * TweetLike create
   */
  export type TweetLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a TweetLike.
     */
    data: XOR<TweetLikeCreateInput, TweetLikeUncheckedCreateInput>
  }

  /**
   * TweetLike createMany
   */
  export type TweetLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TweetLikes.
     */
    data: TweetLikeCreateManyInput | TweetLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TweetLike createManyAndReturn
   */
  export type TweetLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * The data used to create many TweetLikes.
     */
    data: TweetLikeCreateManyInput | TweetLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetLike update
   */
  export type TweetLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a TweetLike.
     */
    data: XOR<TweetLikeUpdateInput, TweetLikeUncheckedUpdateInput>
    /**
     * Choose, which TweetLike to update.
     */
    where: TweetLikeWhereUniqueInput
  }

  /**
   * TweetLike updateMany
   */
  export type TweetLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TweetLikes.
     */
    data: XOR<TweetLikeUpdateManyMutationInput, TweetLikeUncheckedUpdateManyInput>
    /**
     * Filter which TweetLikes to update
     */
    where?: TweetLikeWhereInput
    /**
     * Limit how many TweetLikes to update.
     */
    limit?: number
  }

  /**
   * TweetLike updateManyAndReturn
   */
  export type TweetLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * The data used to update TweetLikes.
     */
    data: XOR<TweetLikeUpdateManyMutationInput, TweetLikeUncheckedUpdateManyInput>
    /**
     * Filter which TweetLikes to update
     */
    where?: TweetLikeWhereInput
    /**
     * Limit how many TweetLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetLike upsert
   */
  export type TweetLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the TweetLike to update in case it exists.
     */
    where: TweetLikeWhereUniqueInput
    /**
     * In case the TweetLike found by the `where` argument doesn't exist, create a new TweetLike with this data.
     */
    create: XOR<TweetLikeCreateInput, TweetLikeUncheckedCreateInput>
    /**
     * In case the TweetLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetLikeUpdateInput, TweetLikeUncheckedUpdateInput>
  }

  /**
   * TweetLike delete
   */
  export type TweetLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    /**
     * Filter which TweetLike to delete.
     */
    where: TweetLikeWhereUniqueInput
  }

  /**
   * TweetLike deleteMany
   */
  export type TweetLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetLikes to delete
     */
    where?: TweetLikeWhereInput
    /**
     * Limit how many TweetLikes to delete.
     */
    limit?: number
  }

  /**
   * TweetLike without action
   */
  export type TweetLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
  }


  /**
   * Model TweetMedia
   */

  export type AggregateTweetMedia = {
    _count: TweetMediaCountAggregateOutputType | null
    _min: TweetMediaMinAggregateOutputType | null
    _max: TweetMediaMaxAggregateOutputType | null
  }

  export type TweetMediaMinAggregateOutputType = {
    tweetId: string | null
    mediaId: string | null
  }

  export type TweetMediaMaxAggregateOutputType = {
    tweetId: string | null
    mediaId: string | null
  }

  export type TweetMediaCountAggregateOutputType = {
    tweetId: number
    mediaId: number
    _all: number
  }


  export type TweetMediaMinAggregateInputType = {
    tweetId?: true
    mediaId?: true
  }

  export type TweetMediaMaxAggregateInputType = {
    tweetId?: true
    mediaId?: true
  }

  export type TweetMediaCountAggregateInputType = {
    tweetId?: true
    mediaId?: true
    _all?: true
  }

  export type TweetMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetMedia to aggregate.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TweetMedias
    **/
    _count?: true | TweetMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMediaMaxAggregateInputType
  }

  export type GetTweetMediaAggregateType<T extends TweetMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetMedia[P]>
      : GetScalarType<T[P], AggregateTweetMedia[P]>
  }




  export type TweetMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetMediaWhereInput
    orderBy?: TweetMediaOrderByWithAggregationInput | TweetMediaOrderByWithAggregationInput[]
    by: TweetMediaScalarFieldEnum[] | TweetMediaScalarFieldEnum
    having?: TweetMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetMediaCountAggregateInputType | true
    _min?: TweetMediaMinAggregateInputType
    _max?: TweetMediaMaxAggregateInputType
  }

  export type TweetMediaGroupByOutputType = {
    tweetId: string
    mediaId: string
    _count: TweetMediaCountAggregateOutputType | null
    _min: TweetMediaMinAggregateOutputType | null
    _max: TweetMediaMaxAggregateOutputType | null
  }

  type GetTweetMediaGroupByPayload<T extends TweetMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetMediaGroupByOutputType[P]>
            : GetScalarType<T[P], TweetMediaGroupByOutputType[P]>
        }
      >
    >


  export type TweetMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    mediaId?: boolean
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectScalar = {
    tweetId?: boolean
    mediaId?: boolean
  }

  export type TweetMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tweetId" | "mediaId", ExtArgs["result"]["tweetMedia"]>
  export type TweetMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type TweetMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type TweetMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | mediasDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }

  export type $TweetMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TweetMedia"
    objects: {
      medias: Prisma.$mediasPayload<ExtArgs>
      tweets: Prisma.$tweetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tweetId: string
      mediaId: string
    }, ExtArgs["result"]["tweetMedia"]>
    composites: {}
  }

  type TweetMediaGetPayload<S extends boolean | null | undefined | TweetMediaDefaultArgs> = $Result.GetResult<Prisma.$TweetMediaPayload, S>

  type TweetMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetMediaCountAggregateInputType | true
    }

  export interface TweetMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TweetMedia'], meta: { name: 'TweetMedia' } }
    /**
     * Find zero or one TweetMedia that matches the filter.
     * @param {TweetMediaFindUniqueArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetMediaFindUniqueArgs>(args: SelectSubset<T, TweetMediaFindUniqueArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TweetMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetMediaFindUniqueOrThrowArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindFirstArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetMediaFindFirstArgs>(args?: SelectSubset<T, TweetMediaFindFirstArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindFirstOrThrowArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TweetMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TweetMedias
     * const tweetMedias = await prisma.tweetMedia.findMany()
     * 
     * // Get first 10 TweetMedias
     * const tweetMedias = await prisma.tweetMedia.findMany({ take: 10 })
     * 
     * // Only select the `tweetId`
     * const tweetMediaWithTweetIdOnly = await prisma.tweetMedia.findMany({ select: { tweetId: true } })
     * 
     */
    findMany<T extends TweetMediaFindManyArgs>(args?: SelectSubset<T, TweetMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TweetMedia.
     * @param {TweetMediaCreateArgs} args - Arguments to create a TweetMedia.
     * @example
     * // Create one TweetMedia
     * const TweetMedia = await prisma.tweetMedia.create({
     *   data: {
     *     // ... data to create a TweetMedia
     *   }
     * })
     * 
     */
    create<T extends TweetMediaCreateArgs>(args: SelectSubset<T, TweetMediaCreateArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TweetMedias.
     * @param {TweetMediaCreateManyArgs} args - Arguments to create many TweetMedias.
     * @example
     * // Create many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetMediaCreateManyArgs>(args?: SelectSubset<T, TweetMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TweetMedias and returns the data saved in the database.
     * @param {TweetMediaCreateManyAndReturnArgs} args - Arguments to create many TweetMedias.
     * @example
     * // Create many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TweetMedias and only return the `tweetId`
     * const tweetMediaWithTweetIdOnly = await prisma.tweetMedia.createManyAndReturn({
     *   select: { tweetId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TweetMedia.
     * @param {TweetMediaDeleteArgs} args - Arguments to delete one TweetMedia.
     * @example
     * // Delete one TweetMedia
     * const TweetMedia = await prisma.tweetMedia.delete({
     *   where: {
     *     // ... filter to delete one TweetMedia
     *   }
     * })
     * 
     */
    delete<T extends TweetMediaDeleteArgs>(args: SelectSubset<T, TweetMediaDeleteArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TweetMedia.
     * @param {TweetMediaUpdateArgs} args - Arguments to update one TweetMedia.
     * @example
     * // Update one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetMediaUpdateArgs>(args: SelectSubset<T, TweetMediaUpdateArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TweetMedias.
     * @param {TweetMediaDeleteManyArgs} args - Arguments to filter TweetMedias to delete.
     * @example
     * // Delete a few TweetMedias
     * const { count } = await prisma.tweetMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetMediaDeleteManyArgs>(args?: SelectSubset<T, TweetMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetMediaUpdateManyArgs>(args: SelectSubset<T, TweetMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetMedias and returns the data updated in the database.
     * @param {TweetMediaUpdateManyAndReturnArgs} args - Arguments to update many TweetMedias.
     * @example
     * // Update many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TweetMedias and only return the `tweetId`
     * const tweetMediaWithTweetIdOnly = await prisma.tweetMedia.updateManyAndReturn({
     *   select: { tweetId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TweetMedia.
     * @param {TweetMediaUpsertArgs} args - Arguments to update or create a TweetMedia.
     * @example
     * // Update or create a TweetMedia
     * const tweetMedia = await prisma.tweetMedia.upsert({
     *   create: {
     *     // ... data to create a TweetMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TweetMedia we want to update
     *   }
     * })
     */
    upsert<T extends TweetMediaUpsertArgs>(args: SelectSubset<T, TweetMediaUpsertArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TweetMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaCountArgs} args - Arguments to filter TweetMedias to count.
     * @example
     * // Count the number of TweetMedias
     * const count = await prisma.tweetMedia.count({
     *   where: {
     *     // ... the filter for the TweetMedias we want to count
     *   }
     * })
    **/
    count<T extends TweetMediaCountArgs>(
      args?: Subset<T, TweetMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TweetMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetMediaAggregateArgs>(args: Subset<T, TweetMediaAggregateArgs>): Prisma.PrismaPromise<GetTweetMediaAggregateType<T>>

    /**
     * Group by TweetMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetMediaGroupByArgs['orderBy'] }
        : { orderBy?: TweetMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TweetMedia model
   */
  readonly fields: TweetMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TweetMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medias<T extends mediasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mediasDefaultArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TweetMedia model
   */
  interface TweetMediaFieldRefs {
    readonly tweetId: FieldRef<"TweetMedia", 'String'>
    readonly mediaId: FieldRef<"TweetMedia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TweetMedia findUnique
   */
  export type TweetMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia findUniqueOrThrow
   */
  export type TweetMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia findFirst
   */
  export type TweetMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetMedias.
     */
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia findFirstOrThrow
   */
  export type TweetMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetMedias.
     */
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia findMany
   */
  export type TweetMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedias to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia create
   */
  export type TweetMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a TweetMedia.
     */
    data: XOR<TweetMediaCreateInput, TweetMediaUncheckedCreateInput>
  }

  /**
   * TweetMedia createMany
   */
  export type TweetMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TweetMedias.
     */
    data: TweetMediaCreateManyInput | TweetMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TweetMedia createManyAndReturn
   */
  export type TweetMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * The data used to create many TweetMedias.
     */
    data: TweetMediaCreateManyInput | TweetMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetMedia update
   */
  export type TweetMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a TweetMedia.
     */
    data: XOR<TweetMediaUpdateInput, TweetMediaUncheckedUpdateInput>
    /**
     * Choose, which TweetMedia to update.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia updateMany
   */
  export type TweetMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TweetMedias.
     */
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyInput>
    /**
     * Filter which TweetMedias to update
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to update.
     */
    limit?: number
  }

  /**
   * TweetMedia updateManyAndReturn
   */
  export type TweetMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * The data used to update TweetMedias.
     */
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyInput>
    /**
     * Filter which TweetMedias to update
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetMedia upsert
   */
  export type TweetMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the TweetMedia to update in case it exists.
     */
    where: TweetMediaWhereUniqueInput
    /**
     * In case the TweetMedia found by the `where` argument doesn't exist, create a new TweetMedia with this data.
     */
    create: XOR<TweetMediaCreateInput, TweetMediaUncheckedCreateInput>
    /**
     * In case the TweetMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetMediaUpdateInput, TweetMediaUncheckedUpdateInput>
  }

  /**
   * TweetMedia delete
   */
  export type TweetMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter which TweetMedia to delete.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia deleteMany
   */
  export type TweetMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetMedias to delete
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to delete.
     */
    limit?: number
  }

  /**
   * TweetMedia without action
   */
  export type TweetMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
  }


  /**
   * Model TweetSummary
   */

  export type AggregateTweetSummary = {
    _count: TweetSummaryCountAggregateOutputType | null
    _min: TweetSummaryMinAggregateOutputType | null
    _max: TweetSummaryMaxAggregateOutputType | null
  }

  export type TweetSummaryMinAggregateOutputType = {
    id: string | null
    tweetId: string | null
    summary: string | null
  }

  export type TweetSummaryMaxAggregateOutputType = {
    id: string | null
    tweetId: string | null
    summary: string | null
  }

  export type TweetSummaryCountAggregateOutputType = {
    id: number
    tweetId: number
    summary: number
    _all: number
  }


  export type TweetSummaryMinAggregateInputType = {
    id?: true
    tweetId?: true
    summary?: true
  }

  export type TweetSummaryMaxAggregateInputType = {
    id?: true
    tweetId?: true
    summary?: true
  }

  export type TweetSummaryCountAggregateInputType = {
    id?: true
    tweetId?: true
    summary?: true
    _all?: true
  }

  export type TweetSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetSummary to aggregate.
     */
    where?: TweetSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetSummaries to fetch.
     */
    orderBy?: TweetSummaryOrderByWithRelationInput | TweetSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TweetSummaries
    **/
    _count?: true | TweetSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetSummaryMaxAggregateInputType
  }

  export type GetTweetSummaryAggregateType<T extends TweetSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetSummary[P]>
      : GetScalarType<T[P], AggregateTweetSummary[P]>
  }




  export type TweetSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetSummaryWhereInput
    orderBy?: TweetSummaryOrderByWithAggregationInput | TweetSummaryOrderByWithAggregationInput[]
    by: TweetSummaryScalarFieldEnum[] | TweetSummaryScalarFieldEnum
    having?: TweetSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetSummaryCountAggregateInputType | true
    _min?: TweetSummaryMinAggregateInputType
    _max?: TweetSummaryMaxAggregateInputType
  }

  export type TweetSummaryGroupByOutputType = {
    id: string
    tweetId: string
    summary: string
    _count: TweetSummaryCountAggregateOutputType | null
    _min: TweetSummaryMinAggregateOutputType | null
    _max: TweetSummaryMaxAggregateOutputType | null
  }

  type GetTweetSummaryGroupByPayload<T extends TweetSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], TweetSummaryGroupByOutputType[P]>
        }
      >
    >


  export type TweetSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    summary?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetSummary"]>

  export type TweetSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    summary?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetSummary"]>

  export type TweetSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    summary?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetSummary"]>

  export type TweetSummarySelectScalar = {
    id?: boolean
    tweetId?: boolean
    summary?: boolean
  }

  export type TweetSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tweetId" | "summary", ExtArgs["result"]["tweetSummary"]>
  export type TweetSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type TweetSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type TweetSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }

  export type $TweetSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TweetSummary"
    objects: {
      tweets: Prisma.$tweetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tweetId: string
      summary: string
    }, ExtArgs["result"]["tweetSummary"]>
    composites: {}
  }

  type TweetSummaryGetPayload<S extends boolean | null | undefined | TweetSummaryDefaultArgs> = $Result.GetResult<Prisma.$TweetSummaryPayload, S>

  type TweetSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetSummaryCountAggregateInputType | true
    }

  export interface TweetSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TweetSummary'], meta: { name: 'TweetSummary' } }
    /**
     * Find zero or one TweetSummary that matches the filter.
     * @param {TweetSummaryFindUniqueArgs} args - Arguments to find a TweetSummary
     * @example
     * // Get one TweetSummary
     * const tweetSummary = await prisma.tweetSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetSummaryFindUniqueArgs>(args: SelectSubset<T, TweetSummaryFindUniqueArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TweetSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetSummaryFindUniqueOrThrowArgs} args - Arguments to find a TweetSummary
     * @example
     * // Get one TweetSummary
     * const tweetSummary = await prisma.tweetSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryFindFirstArgs} args - Arguments to find a TweetSummary
     * @example
     * // Get one TweetSummary
     * const tweetSummary = await prisma.tweetSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetSummaryFindFirstArgs>(args?: SelectSubset<T, TweetSummaryFindFirstArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryFindFirstOrThrowArgs} args - Arguments to find a TweetSummary
     * @example
     * // Get one TweetSummary
     * const tweetSummary = await prisma.tweetSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TweetSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TweetSummaries
     * const tweetSummaries = await prisma.tweetSummary.findMany()
     * 
     * // Get first 10 TweetSummaries
     * const tweetSummaries = await prisma.tweetSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetSummaryWithIdOnly = await prisma.tweetSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TweetSummaryFindManyArgs>(args?: SelectSubset<T, TweetSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TweetSummary.
     * @param {TweetSummaryCreateArgs} args - Arguments to create a TweetSummary.
     * @example
     * // Create one TweetSummary
     * const TweetSummary = await prisma.tweetSummary.create({
     *   data: {
     *     // ... data to create a TweetSummary
     *   }
     * })
     * 
     */
    create<T extends TweetSummaryCreateArgs>(args: SelectSubset<T, TweetSummaryCreateArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TweetSummaries.
     * @param {TweetSummaryCreateManyArgs} args - Arguments to create many TweetSummaries.
     * @example
     * // Create many TweetSummaries
     * const tweetSummary = await prisma.tweetSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetSummaryCreateManyArgs>(args?: SelectSubset<T, TweetSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TweetSummaries and returns the data saved in the database.
     * @param {TweetSummaryCreateManyAndReturnArgs} args - Arguments to create many TweetSummaries.
     * @example
     * // Create many TweetSummaries
     * const tweetSummary = await prisma.tweetSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TweetSummaries and only return the `id`
     * const tweetSummaryWithIdOnly = await prisma.tweetSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TweetSummary.
     * @param {TweetSummaryDeleteArgs} args - Arguments to delete one TweetSummary.
     * @example
     * // Delete one TweetSummary
     * const TweetSummary = await prisma.tweetSummary.delete({
     *   where: {
     *     // ... filter to delete one TweetSummary
     *   }
     * })
     * 
     */
    delete<T extends TweetSummaryDeleteArgs>(args: SelectSubset<T, TweetSummaryDeleteArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TweetSummary.
     * @param {TweetSummaryUpdateArgs} args - Arguments to update one TweetSummary.
     * @example
     * // Update one TweetSummary
     * const tweetSummary = await prisma.tweetSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetSummaryUpdateArgs>(args: SelectSubset<T, TweetSummaryUpdateArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TweetSummaries.
     * @param {TweetSummaryDeleteManyArgs} args - Arguments to filter TweetSummaries to delete.
     * @example
     * // Delete a few TweetSummaries
     * const { count } = await prisma.tweetSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetSummaryDeleteManyArgs>(args?: SelectSubset<T, TweetSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TweetSummaries
     * const tweetSummary = await prisma.tweetSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetSummaryUpdateManyArgs>(args: SelectSubset<T, TweetSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetSummaries and returns the data updated in the database.
     * @param {TweetSummaryUpdateManyAndReturnArgs} args - Arguments to update many TweetSummaries.
     * @example
     * // Update many TweetSummaries
     * const tweetSummary = await prisma.tweetSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TweetSummaries and only return the `id`
     * const tweetSummaryWithIdOnly = await prisma.tweetSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TweetSummary.
     * @param {TweetSummaryUpsertArgs} args - Arguments to update or create a TweetSummary.
     * @example
     * // Update or create a TweetSummary
     * const tweetSummary = await prisma.tweetSummary.upsert({
     *   create: {
     *     // ... data to create a TweetSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TweetSummary we want to update
     *   }
     * })
     */
    upsert<T extends TweetSummaryUpsertArgs>(args: SelectSubset<T, TweetSummaryUpsertArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TweetSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryCountArgs} args - Arguments to filter TweetSummaries to count.
     * @example
     * // Count the number of TweetSummaries
     * const count = await prisma.tweetSummary.count({
     *   where: {
     *     // ... the filter for the TweetSummaries we want to count
     *   }
     * })
    **/
    count<T extends TweetSummaryCountArgs>(
      args?: Subset<T, TweetSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TweetSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetSummaryAggregateArgs>(args: Subset<T, TweetSummaryAggregateArgs>): Prisma.PrismaPromise<GetTweetSummaryAggregateType<T>>

    /**
     * Group by TweetSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetSummaryGroupByArgs['orderBy'] }
        : { orderBy?: TweetSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TweetSummary model
   */
  readonly fields: TweetSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TweetSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TweetSummary model
   */
  interface TweetSummaryFieldRefs {
    readonly id: FieldRef<"TweetSummary", 'String'>
    readonly tweetId: FieldRef<"TweetSummary", 'String'>
    readonly summary: FieldRef<"TweetSummary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TweetSummary findUnique
   */
  export type TweetSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TweetSummary to fetch.
     */
    where: TweetSummaryWhereUniqueInput
  }

  /**
   * TweetSummary findUniqueOrThrow
   */
  export type TweetSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TweetSummary to fetch.
     */
    where: TweetSummaryWhereUniqueInput
  }

  /**
   * TweetSummary findFirst
   */
  export type TweetSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TweetSummary to fetch.
     */
    where?: TweetSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetSummaries to fetch.
     */
    orderBy?: TweetSummaryOrderByWithRelationInput | TweetSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetSummaries.
     */
    cursor?: TweetSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetSummaries.
     */
    distinct?: TweetSummaryScalarFieldEnum | TweetSummaryScalarFieldEnum[]
  }

  /**
   * TweetSummary findFirstOrThrow
   */
  export type TweetSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TweetSummary to fetch.
     */
    where?: TweetSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetSummaries to fetch.
     */
    orderBy?: TweetSummaryOrderByWithRelationInput | TweetSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetSummaries.
     */
    cursor?: TweetSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetSummaries.
     */
    distinct?: TweetSummaryScalarFieldEnum | TweetSummaryScalarFieldEnum[]
  }

  /**
   * TweetSummary findMany
   */
  export type TweetSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TweetSummaries to fetch.
     */
    where?: TweetSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetSummaries to fetch.
     */
    orderBy?: TweetSummaryOrderByWithRelationInput | TweetSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TweetSummaries.
     */
    cursor?: TweetSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetSummaries.
     */
    skip?: number
    distinct?: TweetSummaryScalarFieldEnum | TweetSummaryScalarFieldEnum[]
  }

  /**
   * TweetSummary create
   */
  export type TweetSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a TweetSummary.
     */
    data: XOR<TweetSummaryCreateInput, TweetSummaryUncheckedCreateInput>
  }

  /**
   * TweetSummary createMany
   */
  export type TweetSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TweetSummaries.
     */
    data: TweetSummaryCreateManyInput | TweetSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TweetSummary createManyAndReturn
   */
  export type TweetSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many TweetSummaries.
     */
    data: TweetSummaryCreateManyInput | TweetSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetSummary update
   */
  export type TweetSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a TweetSummary.
     */
    data: XOR<TweetSummaryUpdateInput, TweetSummaryUncheckedUpdateInput>
    /**
     * Choose, which TweetSummary to update.
     */
    where: TweetSummaryWhereUniqueInput
  }

  /**
   * TweetSummary updateMany
   */
  export type TweetSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TweetSummaries.
     */
    data: XOR<TweetSummaryUpdateManyMutationInput, TweetSummaryUncheckedUpdateManyInput>
    /**
     * Filter which TweetSummaries to update
     */
    where?: TweetSummaryWhereInput
    /**
     * Limit how many TweetSummaries to update.
     */
    limit?: number
  }

  /**
   * TweetSummary updateManyAndReturn
   */
  export type TweetSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * The data used to update TweetSummaries.
     */
    data: XOR<TweetSummaryUpdateManyMutationInput, TweetSummaryUncheckedUpdateManyInput>
    /**
     * Filter which TweetSummaries to update
     */
    where?: TweetSummaryWhereInput
    /**
     * Limit how many TweetSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetSummary upsert
   */
  export type TweetSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the TweetSummary to update in case it exists.
     */
    where: TweetSummaryWhereUniqueInput
    /**
     * In case the TweetSummary found by the `where` argument doesn't exist, create a new TweetSummary with this data.
     */
    create: XOR<TweetSummaryCreateInput, TweetSummaryUncheckedCreateInput>
    /**
     * In case the TweetSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetSummaryUpdateInput, TweetSummaryUncheckedUpdateInput>
  }

  /**
   * TweetSummary delete
   */
  export type TweetSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    /**
     * Filter which TweetSummary to delete.
     */
    where: TweetSummaryWhereUniqueInput
  }

  /**
   * TweetSummary deleteMany
   */
  export type TweetSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetSummaries to delete
     */
    where?: TweetSummaryWhereInput
    /**
     * Limit how many TweetSummaries to delete.
     */
    limit?: number
  }

  /**
   * TweetSummary without action
   */
  export type TweetSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
  }


  /**
   * Model chatGroups
   */

  export type AggregateChatGroups = {
    _count: ChatGroupsCountAggregateOutputType | null
    _min: ChatGroupsMinAggregateOutputType | null
    _max: ChatGroupsMaxAggregateOutputType | null
  }

  export type ChatGroupsMinAggregateOutputType = {
    name: string | null
    description: string | null
    photo: string | null
    chatId: string | null
  }

  export type ChatGroupsMaxAggregateOutputType = {
    name: string | null
    description: string | null
    photo: string | null
    chatId: string | null
  }

  export type ChatGroupsCountAggregateOutputType = {
    name: number
    description: number
    photo: number
    chatId: number
    _all: number
  }


  export type ChatGroupsMinAggregateInputType = {
    name?: true
    description?: true
    photo?: true
    chatId?: true
  }

  export type ChatGroupsMaxAggregateInputType = {
    name?: true
    description?: true
    photo?: true
    chatId?: true
  }

  export type ChatGroupsCountAggregateInputType = {
    name?: true
    description?: true
    photo?: true
    chatId?: true
    _all?: true
  }

  export type ChatGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatGroups to aggregate.
     */
    where?: chatGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatGroups to fetch.
     */
    orderBy?: chatGroupsOrderByWithRelationInput | chatGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatGroups
    **/
    _count?: true | ChatGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatGroupsMaxAggregateInputType
  }

  export type GetChatGroupsAggregateType<T extends ChatGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateChatGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatGroups[P]>
      : GetScalarType<T[P], AggregateChatGroups[P]>
  }




  export type chatGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatGroupsWhereInput
    orderBy?: chatGroupsOrderByWithAggregationInput | chatGroupsOrderByWithAggregationInput[]
    by: ChatGroupsScalarFieldEnum[] | ChatGroupsScalarFieldEnum
    having?: chatGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatGroupsCountAggregateInputType | true
    _min?: ChatGroupsMinAggregateInputType
    _max?: ChatGroupsMaxAggregateInputType
  }

  export type ChatGroupsGroupByOutputType = {
    name: string | null
    description: string | null
    photo: string | null
    chatId: string
    _count: ChatGroupsCountAggregateOutputType | null
    _min: ChatGroupsMinAggregateOutputType | null
    _max: ChatGroupsMaxAggregateOutputType | null
  }

  type GetChatGroupsGroupByPayload<T extends chatGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupsGroupByOutputType[P]>
        }
      >
    >


  export type chatGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    photo?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroups"]>

  export type chatGroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    photo?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroups"]>

  export type chatGroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    photo?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroups"]>

  export type chatGroupsSelectScalar = {
    name?: boolean
    description?: boolean
    photo?: boolean
    chatId?: boolean
  }

  export type chatGroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "photo" | "chatId", ExtArgs["result"]["chatGroups"]>
  export type chatGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }
  export type chatGroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }
  export type chatGroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }

  export type $chatGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatGroups"
    objects: {
      chats: Prisma.$chatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string | null
      description: string | null
      photo: string | null
      chatId: string
    }, ExtArgs["result"]["chatGroups"]>
    composites: {}
  }

  type chatGroupsGetPayload<S extends boolean | null | undefined | chatGroupsDefaultArgs> = $Result.GetResult<Prisma.$chatGroupsPayload, S>

  type chatGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatGroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatGroupsCountAggregateInputType | true
    }

  export interface chatGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatGroups'], meta: { name: 'chatGroups' } }
    /**
     * Find zero or one ChatGroups that matches the filter.
     * @param {chatGroupsFindUniqueArgs} args - Arguments to find a ChatGroups
     * @example
     * // Get one ChatGroups
     * const chatGroups = await prisma.chatGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatGroupsFindUniqueArgs>(args: SelectSubset<T, chatGroupsFindUniqueArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatGroups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatGroupsFindUniqueOrThrowArgs} args - Arguments to find a ChatGroups
     * @example
     * // Get one ChatGroups
     * const chatGroups = await prisma.chatGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatGroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatGroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsFindFirstArgs} args - Arguments to find a ChatGroups
     * @example
     * // Get one ChatGroups
     * const chatGroups = await prisma.chatGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatGroupsFindFirstArgs>(args?: SelectSubset<T, chatGroupsFindFirstArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsFindFirstOrThrowArgs} args - Arguments to find a ChatGroups
     * @example
     * // Get one ChatGroups
     * const chatGroups = await prisma.chatGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatGroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatGroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatGroups
     * const chatGroups = await prisma.chatGroups.findMany()
     * 
     * // Get first 10 ChatGroups
     * const chatGroups = await prisma.chatGroups.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const chatGroupsWithNameOnly = await prisma.chatGroups.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends chatGroupsFindManyArgs>(args?: SelectSubset<T, chatGroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatGroups.
     * @param {chatGroupsCreateArgs} args - Arguments to create a ChatGroups.
     * @example
     * // Create one ChatGroups
     * const ChatGroups = await prisma.chatGroups.create({
     *   data: {
     *     // ... data to create a ChatGroups
     *   }
     * })
     * 
     */
    create<T extends chatGroupsCreateArgs>(args: SelectSubset<T, chatGroupsCreateArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatGroups.
     * @param {chatGroupsCreateManyArgs} args - Arguments to create many ChatGroups.
     * @example
     * // Create many ChatGroups
     * const chatGroups = await prisma.chatGroups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatGroupsCreateManyArgs>(args?: SelectSubset<T, chatGroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatGroups and returns the data saved in the database.
     * @param {chatGroupsCreateManyAndReturnArgs} args - Arguments to create many ChatGroups.
     * @example
     * // Create many ChatGroups
     * const chatGroups = await prisma.chatGroups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatGroups and only return the `name`
     * const chatGroupsWithNameOnly = await prisma.chatGroups.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatGroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatGroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatGroups.
     * @param {chatGroupsDeleteArgs} args - Arguments to delete one ChatGroups.
     * @example
     * // Delete one ChatGroups
     * const ChatGroups = await prisma.chatGroups.delete({
     *   where: {
     *     // ... filter to delete one ChatGroups
     *   }
     * })
     * 
     */
    delete<T extends chatGroupsDeleteArgs>(args: SelectSubset<T, chatGroupsDeleteArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatGroups.
     * @param {chatGroupsUpdateArgs} args - Arguments to update one ChatGroups.
     * @example
     * // Update one ChatGroups
     * const chatGroups = await prisma.chatGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatGroupsUpdateArgs>(args: SelectSubset<T, chatGroupsUpdateArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatGroups.
     * @param {chatGroupsDeleteManyArgs} args - Arguments to filter ChatGroups to delete.
     * @example
     * // Delete a few ChatGroups
     * const { count } = await prisma.chatGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatGroupsDeleteManyArgs>(args?: SelectSubset<T, chatGroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatGroups
     * const chatGroups = await prisma.chatGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatGroupsUpdateManyArgs>(args: SelectSubset<T, chatGroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroups and returns the data updated in the database.
     * @param {chatGroupsUpdateManyAndReturnArgs} args - Arguments to update many ChatGroups.
     * @example
     * // Update many ChatGroups
     * const chatGroups = await prisma.chatGroups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatGroups and only return the `name`
     * const chatGroupsWithNameOnly = await prisma.chatGroups.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatGroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatGroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatGroups.
     * @param {chatGroupsUpsertArgs} args - Arguments to update or create a ChatGroups.
     * @example
     * // Update or create a ChatGroups
     * const chatGroups = await prisma.chatGroups.upsert({
     *   create: {
     *     // ... data to create a ChatGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatGroups we want to update
     *   }
     * })
     */
    upsert<T extends chatGroupsUpsertArgs>(args: SelectSubset<T, chatGroupsUpsertArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsCountArgs} args - Arguments to filter ChatGroups to count.
     * @example
     * // Count the number of ChatGroups
     * const count = await prisma.chatGroups.count({
     *   where: {
     *     // ... the filter for the ChatGroups we want to count
     *   }
     * })
    **/
    count<T extends chatGroupsCountArgs>(
      args?: Subset<T, chatGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatGroupsAggregateArgs>(args: Subset<T, ChatGroupsAggregateArgs>): Prisma.PrismaPromise<GetChatGroupsAggregateType<T>>

    /**
     * Group by ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatGroupsGroupByArgs['orderBy'] }
        : { orderBy?: chatGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatGroups model
   */
  readonly fields: chatGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatGroups model
   */
  interface chatGroupsFieldRefs {
    readonly name: FieldRef<"chatGroups", 'String'>
    readonly description: FieldRef<"chatGroups", 'String'>
    readonly photo: FieldRef<"chatGroups", 'String'>
    readonly chatId: FieldRef<"chatGroups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatGroups findUnique
   */
  export type chatGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter, which chatGroups to fetch.
     */
    where: chatGroupsWhereUniqueInput
  }

  /**
   * chatGroups findUniqueOrThrow
   */
  export type chatGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter, which chatGroups to fetch.
     */
    where: chatGroupsWhereUniqueInput
  }

  /**
   * chatGroups findFirst
   */
  export type chatGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter, which chatGroups to fetch.
     */
    where?: chatGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatGroups to fetch.
     */
    orderBy?: chatGroupsOrderByWithRelationInput | chatGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatGroups.
     */
    cursor?: chatGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatGroups.
     */
    distinct?: ChatGroupsScalarFieldEnum | ChatGroupsScalarFieldEnum[]
  }

  /**
   * chatGroups findFirstOrThrow
   */
  export type chatGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter, which chatGroups to fetch.
     */
    where?: chatGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatGroups to fetch.
     */
    orderBy?: chatGroupsOrderByWithRelationInput | chatGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatGroups.
     */
    cursor?: chatGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatGroups.
     */
    distinct?: ChatGroupsScalarFieldEnum | ChatGroupsScalarFieldEnum[]
  }

  /**
   * chatGroups findMany
   */
  export type chatGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter, which chatGroups to fetch.
     */
    where?: chatGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatGroups to fetch.
     */
    orderBy?: chatGroupsOrderByWithRelationInput | chatGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatGroups.
     */
    cursor?: chatGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatGroups.
     */
    skip?: number
    distinct?: ChatGroupsScalarFieldEnum | ChatGroupsScalarFieldEnum[]
  }

  /**
   * chatGroups create
   */
  export type chatGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a chatGroups.
     */
    data: XOR<chatGroupsCreateInput, chatGroupsUncheckedCreateInput>
  }

  /**
   * chatGroups createMany
   */
  export type chatGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatGroups.
     */
    data: chatGroupsCreateManyInput | chatGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatGroups createManyAndReturn
   */
  export type chatGroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * The data used to create many chatGroups.
     */
    data: chatGroupsCreateManyInput | chatGroupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatGroups update
   */
  export type chatGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a chatGroups.
     */
    data: XOR<chatGroupsUpdateInput, chatGroupsUncheckedUpdateInput>
    /**
     * Choose, which chatGroups to update.
     */
    where: chatGroupsWhereUniqueInput
  }

  /**
   * chatGroups updateMany
   */
  export type chatGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatGroups.
     */
    data: XOR<chatGroupsUpdateManyMutationInput, chatGroupsUncheckedUpdateManyInput>
    /**
     * Filter which chatGroups to update
     */
    where?: chatGroupsWhereInput
    /**
     * Limit how many chatGroups to update.
     */
    limit?: number
  }

  /**
   * chatGroups updateManyAndReturn
   */
  export type chatGroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * The data used to update chatGroups.
     */
    data: XOR<chatGroupsUpdateManyMutationInput, chatGroupsUncheckedUpdateManyInput>
    /**
     * Filter which chatGroups to update
     */
    where?: chatGroupsWhereInput
    /**
     * Limit how many chatGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatGroups upsert
   */
  export type chatGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the chatGroups to update in case it exists.
     */
    where: chatGroupsWhereUniqueInput
    /**
     * In case the chatGroups found by the `where` argument doesn't exist, create a new chatGroups with this data.
     */
    create: XOR<chatGroupsCreateInput, chatGroupsUncheckedCreateInput>
    /**
     * In case the chatGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatGroupsUpdateInput, chatGroupsUncheckedUpdateInput>
  }

  /**
   * chatGroups delete
   */
  export type chatGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    /**
     * Filter which chatGroups to delete.
     */
    where: chatGroupsWhereUniqueInput
  }

  /**
   * chatGroups deleteMany
   */
  export type chatGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatGroups to delete
     */
    where?: chatGroupsWhereInput
    /**
     * Limit how many chatGroups to delete.
     */
    limit?: number
  }

  /**
   * chatGroups without action
   */
  export type chatGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
  }


  /**
   * Model chats
   */

  export type AggregateChats = {
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  export type ChatsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    DMChat: boolean | null
  }

  export type ChatsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    DMChat: boolean | null
  }

  export type ChatsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    DMChat: number
    _all: number
  }


  export type ChatsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    DMChat?: true
  }

  export type ChatsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    DMChat?: true
  }

  export type ChatsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    DMChat?: true
    _all?: true
  }

  export type ChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to aggregate.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatsMaxAggregateInputType
  }

  export type GetChatsAggregateType<T extends ChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChats[P]>
      : GetScalarType<T[P], AggregateChats[P]>
  }




  export type chatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatsWhereInput
    orderBy?: chatsOrderByWithAggregationInput | chatsOrderByWithAggregationInput[]
    by: ChatsScalarFieldEnum[] | ChatsScalarFieldEnum
    having?: chatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatsCountAggregateInputType | true
    _min?: ChatsMinAggregateInputType
    _max?: ChatsMaxAggregateInputType
  }

  export type ChatsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    DMChat: boolean
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  type GetChatsGroupByPayload<T extends chatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatsGroupByOutputType[P]>
        }
      >
    >


  export type chatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DMChat?: boolean
    chatGroups?: boolean | chats$chatGroupsArgs<ExtArgs>
    chatusers?: boolean | chats$chatusersArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DMChat?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DMChat?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DMChat?: boolean
  }

  export type chatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "DMChat", ExtArgs["result"]["chats"]>
  export type chatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatGroups?: boolean | chats$chatGroupsArgs<ExtArgs>
    chatusers?: boolean | chats$chatusersArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type chatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chats"
    objects: {
      chatGroups: Prisma.$chatGroupsPayload<ExtArgs> | null
      chatusers: Prisma.$chatusersPayload<ExtArgs>[]
      messages: Prisma.$messagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      DMChat: boolean
    }, ExtArgs["result"]["chats"]>
    composites: {}
  }

  type chatsGetPayload<S extends boolean | null | undefined | chatsDefaultArgs> = $Result.GetResult<Prisma.$chatsPayload, S>

  type chatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatsCountAggregateInputType | true
    }

  export interface chatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chats'], meta: { name: 'chats' } }
    /**
     * Find zero or one Chats that matches the filter.
     * @param {chatsFindUniqueArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatsFindUniqueArgs>(args: SelectSubset<T, chatsFindUniqueArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatsFindUniqueOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatsFindFirstArgs>(args?: SelectSubset<T, chatsFindFirstArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chats.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatsWithIdOnly = await prisma.chats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatsFindManyArgs>(args?: SelectSubset<T, chatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chats.
     * @param {chatsCreateArgs} args - Arguments to create a Chats.
     * @example
     * // Create one Chats
     * const Chats = await prisma.chats.create({
     *   data: {
     *     // ... data to create a Chats
     *   }
     * })
     * 
     */
    create<T extends chatsCreateArgs>(args: SelectSubset<T, chatsCreateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {chatsCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatsCreateManyArgs>(args?: SelectSubset<T, chatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {chatsCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chats.
     * @param {chatsDeleteArgs} args - Arguments to delete one Chats.
     * @example
     * // Delete one Chats
     * const Chats = await prisma.chats.delete({
     *   where: {
     *     // ... filter to delete one Chats
     *   }
     * })
     * 
     */
    delete<T extends chatsDeleteArgs>(args: SelectSubset<T, chatsDeleteArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chats.
     * @param {chatsUpdateArgs} args - Arguments to update one Chats.
     * @example
     * // Update one Chats
     * const chats = await prisma.chats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatsUpdateArgs>(args: SelectSubset<T, chatsUpdateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {chatsDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatsDeleteManyArgs>(args?: SelectSubset<T, chatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatsUpdateManyArgs>(args: SelectSubset<T, chatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {chatsUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chats.
     * @param {chatsUpsertArgs} args - Arguments to update or create a Chats.
     * @example
     * // Update or create a Chats
     * const chats = await prisma.chats.upsert({
     *   create: {
     *     // ... data to create a Chats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chats we want to update
     *   }
     * })
     */
    upsert<T extends chatsUpsertArgs>(args: SelectSubset<T, chatsUpsertArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chats.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatsCountArgs>(
      args?: Subset<T, chatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatsAggregateArgs>(args: Subset<T, ChatsAggregateArgs>): Prisma.PrismaPromise<GetChatsAggregateType<T>>

    /**
     * Group by Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatsGroupByArgs['orderBy'] }
        : { orderBy?: chatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chats model
   */
  readonly fields: chatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatGroups<T extends chats$chatGroupsArgs<ExtArgs> = {}>(args?: Subset<T, chats$chatGroupsArgs<ExtArgs>>): Prisma__chatGroupsClient<$Result.GetResult<Prisma.$chatGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chatusers<T extends chats$chatusersArgs<ExtArgs> = {}>(args?: Subset<T, chats$chatusersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends chats$messagesArgs<ExtArgs> = {}>(args?: Subset<T, chats$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chats model
   */
  interface chatsFieldRefs {
    readonly id: FieldRef<"chats", 'String'>
    readonly createdAt: FieldRef<"chats", 'DateTime'>
    readonly updatedAt: FieldRef<"chats", 'DateTime'>
    readonly DMChat: FieldRef<"chats", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * chats findUnique
   */
  export type chatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findUniqueOrThrow
   */
  export type chatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findFirst
   */
  export type chatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findFirstOrThrow
   */
  export type chatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findMany
   */
  export type chatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats create
   */
  export type chatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to create a chats.
     */
    data: XOR<chatsCreateInput, chatsUncheckedCreateInput>
  }

  /**
   * chats createMany
   */
  export type chatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats createManyAndReturn
   */
  export type chatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats update
   */
  export type chatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to update a chats.
     */
    data: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
    /**
     * Choose, which chats to update.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats updateMany
   */
  export type chatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
  }

  /**
   * chats updateManyAndReturn
   */
  export type chatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
  }

  /**
   * chats upsert
   */
  export type chatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The filter to search for the chats to update in case it exists.
     */
    where: chatsWhereUniqueInput
    /**
     * In case the chats found by the `where` argument doesn't exist, create a new chats with this data.
     */
    create: XOR<chatsCreateInput, chatsUncheckedCreateInput>
    /**
     * In case the chats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
  }

  /**
   * chats delete
   */
  export type chatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter which chats to delete.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats deleteMany
   */
  export type chatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to delete.
     */
    limit?: number
  }

  /**
   * chats.chatGroups
   */
  export type chats$chatGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatGroups
     */
    select?: chatGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatGroups
     */
    omit?: chatGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatGroupsInclude<ExtArgs> | null
    where?: chatGroupsWhereInput
  }

  /**
   * chats.chatusers
   */
  export type chats$chatusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    where?: chatusersWhereInput
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    cursor?: chatusersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatusersScalarFieldEnum | ChatusersScalarFieldEnum[]
  }

  /**
   * chats.messages
   */
  export type chats$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * chats without action
   */
  export type chatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
  }


  /**
   * Model chatusers
   */

  export type AggregateChatusers = {
    _count: ChatusersCountAggregateOutputType | null
    _min: ChatusersMinAggregateOutputType | null
    _max: ChatusersMaxAggregateOutputType | null
  }

  export type ChatusersMinAggregateOutputType = {
    id: string | null
    userId: string | null
    chatId: string | null
  }

  export type ChatusersMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    chatId: string | null
  }

  export type ChatusersCountAggregateOutputType = {
    id: number
    userId: number
    chatId: number
    _all: number
  }


  export type ChatusersMinAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
  }

  export type ChatusersMaxAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
  }

  export type ChatusersCountAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    _all?: true
  }

  export type ChatusersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatusers to aggregate.
     */
    where?: chatusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatusers to fetch.
     */
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatusers
    **/
    _count?: true | ChatusersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatusersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatusersMaxAggregateInputType
  }

  export type GetChatusersAggregateType<T extends ChatusersAggregateArgs> = {
        [P in keyof T & keyof AggregateChatusers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatusers[P]>
      : GetScalarType<T[P], AggregateChatusers[P]>
  }




  export type chatusersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatusersWhereInput
    orderBy?: chatusersOrderByWithAggregationInput | chatusersOrderByWithAggregationInput[]
    by: ChatusersScalarFieldEnum[] | ChatusersScalarFieldEnum
    having?: chatusersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatusersCountAggregateInputType | true
    _min?: ChatusersMinAggregateInputType
    _max?: ChatusersMaxAggregateInputType
  }

  export type ChatusersGroupByOutputType = {
    id: string
    userId: string
    chatId: string
    _count: ChatusersCountAggregateOutputType | null
    _min: ChatusersMinAggregateOutputType | null
    _max: ChatusersMaxAggregateOutputType | null
  }

  type GetChatusersGroupByPayload<T extends chatusersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatusersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatusersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatusersGroupByOutputType[P]>
            : GetScalarType<T[P], ChatusersGroupByOutputType[P]>
        }
      >
    >


  export type chatusersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatusers"]>

  export type chatusersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatusers"]>

  export type chatusersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chatId?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatusers"]>

  export type chatusersSelectScalar = {
    id?: boolean
    userId?: boolean
    chatId?: boolean
  }

  export type chatusersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "chatId", ExtArgs["result"]["chatusers"]>
  export type chatusersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type chatusersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type chatusersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $chatusersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatusers"
    objects: {
      chats: Prisma.$chatsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      chatId: string
    }, ExtArgs["result"]["chatusers"]>
    composites: {}
  }

  type chatusersGetPayload<S extends boolean | null | undefined | chatusersDefaultArgs> = $Result.GetResult<Prisma.$chatusersPayload, S>

  type chatusersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatusersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatusersCountAggregateInputType | true
    }

  export interface chatusersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatusers'], meta: { name: 'chatusers' } }
    /**
     * Find zero or one Chatusers that matches the filter.
     * @param {chatusersFindUniqueArgs} args - Arguments to find a Chatusers
     * @example
     * // Get one Chatusers
     * const chatusers = await prisma.chatusers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatusersFindUniqueArgs>(args: SelectSubset<T, chatusersFindUniqueArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatusers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatusersFindUniqueOrThrowArgs} args - Arguments to find a Chatusers
     * @example
     * // Get one Chatusers
     * const chatusers = await prisma.chatusers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatusersFindUniqueOrThrowArgs>(args: SelectSubset<T, chatusersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersFindFirstArgs} args - Arguments to find a Chatusers
     * @example
     * // Get one Chatusers
     * const chatusers = await prisma.chatusers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatusersFindFirstArgs>(args?: SelectSubset<T, chatusersFindFirstArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatusers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersFindFirstOrThrowArgs} args - Arguments to find a Chatusers
     * @example
     * // Get one Chatusers
     * const chatusers = await prisma.chatusers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatusersFindFirstOrThrowArgs>(args?: SelectSubset<T, chatusersFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatusers
     * const chatusers = await prisma.chatusers.findMany()
     * 
     * // Get first 10 Chatusers
     * const chatusers = await prisma.chatusers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatusersWithIdOnly = await prisma.chatusers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatusersFindManyArgs>(args?: SelectSubset<T, chatusersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatusers.
     * @param {chatusersCreateArgs} args - Arguments to create a Chatusers.
     * @example
     * // Create one Chatusers
     * const Chatusers = await prisma.chatusers.create({
     *   data: {
     *     // ... data to create a Chatusers
     *   }
     * })
     * 
     */
    create<T extends chatusersCreateArgs>(args: SelectSubset<T, chatusersCreateArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatusers.
     * @param {chatusersCreateManyArgs} args - Arguments to create many Chatusers.
     * @example
     * // Create many Chatusers
     * const chatusers = await prisma.chatusers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatusersCreateManyArgs>(args?: SelectSubset<T, chatusersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatusers and returns the data saved in the database.
     * @param {chatusersCreateManyAndReturnArgs} args - Arguments to create many Chatusers.
     * @example
     * // Create many Chatusers
     * const chatusers = await prisma.chatusers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatusers and only return the `id`
     * const chatusersWithIdOnly = await prisma.chatusers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatusersCreateManyAndReturnArgs>(args?: SelectSubset<T, chatusersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatusers.
     * @param {chatusersDeleteArgs} args - Arguments to delete one Chatusers.
     * @example
     * // Delete one Chatusers
     * const Chatusers = await prisma.chatusers.delete({
     *   where: {
     *     // ... filter to delete one Chatusers
     *   }
     * })
     * 
     */
    delete<T extends chatusersDeleteArgs>(args: SelectSubset<T, chatusersDeleteArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatusers.
     * @param {chatusersUpdateArgs} args - Arguments to update one Chatusers.
     * @example
     * // Update one Chatusers
     * const chatusers = await prisma.chatusers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatusersUpdateArgs>(args: SelectSubset<T, chatusersUpdateArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatusers.
     * @param {chatusersDeleteManyArgs} args - Arguments to filter Chatusers to delete.
     * @example
     * // Delete a few Chatusers
     * const { count } = await prisma.chatusers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatusersDeleteManyArgs>(args?: SelectSubset<T, chatusersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatusers
     * const chatusers = await prisma.chatusers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatusersUpdateManyArgs>(args: SelectSubset<T, chatusersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatusers and returns the data updated in the database.
     * @param {chatusersUpdateManyAndReturnArgs} args - Arguments to update many Chatusers.
     * @example
     * // Update many Chatusers
     * const chatusers = await prisma.chatusers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatusers and only return the `id`
     * const chatusersWithIdOnly = await prisma.chatusers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatusersUpdateManyAndReturnArgs>(args: SelectSubset<T, chatusersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatusers.
     * @param {chatusersUpsertArgs} args - Arguments to update or create a Chatusers.
     * @example
     * // Update or create a Chatusers
     * const chatusers = await prisma.chatusers.upsert({
     *   create: {
     *     // ... data to create a Chatusers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatusers we want to update
     *   }
     * })
     */
    upsert<T extends chatusersUpsertArgs>(args: SelectSubset<T, chatusersUpsertArgs<ExtArgs>>): Prisma__chatusersClient<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersCountArgs} args - Arguments to filter Chatusers to count.
     * @example
     * // Count the number of Chatusers
     * const count = await prisma.chatusers.count({
     *   where: {
     *     // ... the filter for the Chatusers we want to count
     *   }
     * })
    **/
    count<T extends chatusersCountArgs>(
      args?: Subset<T, chatusersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatusersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatusersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatusersAggregateArgs>(args: Subset<T, ChatusersAggregateArgs>): Prisma.PrismaPromise<GetChatusersAggregateType<T>>

    /**
     * Group by Chatusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatusersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatusersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatusersGroupByArgs['orderBy'] }
        : { orderBy?: chatusersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatusersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatusersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatusers model
   */
  readonly fields: chatusersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatusers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatusersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatusers model
   */
  interface chatusersFieldRefs {
    readonly id: FieldRef<"chatusers", 'String'>
    readonly userId: FieldRef<"chatusers", 'String'>
    readonly chatId: FieldRef<"chatusers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatusers findUnique
   */
  export type chatusersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter, which chatusers to fetch.
     */
    where: chatusersWhereUniqueInput
  }

  /**
   * chatusers findUniqueOrThrow
   */
  export type chatusersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter, which chatusers to fetch.
     */
    where: chatusersWhereUniqueInput
  }

  /**
   * chatusers findFirst
   */
  export type chatusersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter, which chatusers to fetch.
     */
    where?: chatusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatusers to fetch.
     */
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatusers.
     */
    cursor?: chatusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatusers.
     */
    distinct?: ChatusersScalarFieldEnum | ChatusersScalarFieldEnum[]
  }

  /**
   * chatusers findFirstOrThrow
   */
  export type chatusersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter, which chatusers to fetch.
     */
    where?: chatusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatusers to fetch.
     */
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatusers.
     */
    cursor?: chatusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatusers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatusers.
     */
    distinct?: ChatusersScalarFieldEnum | ChatusersScalarFieldEnum[]
  }

  /**
   * chatusers findMany
   */
  export type chatusersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter, which chatusers to fetch.
     */
    where?: chatusersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatusers to fetch.
     */
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatusers.
     */
    cursor?: chatusersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatusers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatusers.
     */
    skip?: number
    distinct?: ChatusersScalarFieldEnum | ChatusersScalarFieldEnum[]
  }

  /**
   * chatusers create
   */
  export type chatusersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * The data needed to create a chatusers.
     */
    data: XOR<chatusersCreateInput, chatusersUncheckedCreateInput>
  }

  /**
   * chatusers createMany
   */
  export type chatusersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatusers.
     */
    data: chatusersCreateManyInput | chatusersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatusers createManyAndReturn
   */
  export type chatusersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * The data used to create many chatusers.
     */
    data: chatusersCreateManyInput | chatusersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatusers update
   */
  export type chatusersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * The data needed to update a chatusers.
     */
    data: XOR<chatusersUpdateInput, chatusersUncheckedUpdateInput>
    /**
     * Choose, which chatusers to update.
     */
    where: chatusersWhereUniqueInput
  }

  /**
   * chatusers updateMany
   */
  export type chatusersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatusers.
     */
    data: XOR<chatusersUpdateManyMutationInput, chatusersUncheckedUpdateManyInput>
    /**
     * Filter which chatusers to update
     */
    where?: chatusersWhereInput
    /**
     * Limit how many chatusers to update.
     */
    limit?: number
  }

  /**
   * chatusers updateManyAndReturn
   */
  export type chatusersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * The data used to update chatusers.
     */
    data: XOR<chatusersUpdateManyMutationInput, chatusersUncheckedUpdateManyInput>
    /**
     * Filter which chatusers to update
     */
    where?: chatusersWhereInput
    /**
     * Limit how many chatusers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatusers upsert
   */
  export type chatusersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * The filter to search for the chatusers to update in case it exists.
     */
    where: chatusersWhereUniqueInput
    /**
     * In case the chatusers found by the `where` argument doesn't exist, create a new chatusers with this data.
     */
    create: XOR<chatusersCreateInput, chatusersUncheckedCreateInput>
    /**
     * In case the chatusers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatusersUpdateInput, chatusersUncheckedUpdateInput>
  }

  /**
   * chatusers delete
   */
  export type chatusersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    /**
     * Filter which chatusers to delete.
     */
    where: chatusersWhereUniqueInput
  }

  /**
   * chatusers deleteMany
   */
  export type chatusersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatusers to delete
     */
    where?: chatusersWhereInput
    /**
     * Limit how many chatusers to delete.
     */
    limit?: number
  }

  /**
   * chatusers without action
   */
  export type chatusersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
  }


  /**
   * Model hashes
   */

  export type AggregateHashes = {
    _count: HashesCountAggregateOutputType | null
    _min: HashesMinAggregateOutputType | null
    _max: HashesMaxAggregateOutputType | null
  }

  export type HashesMinAggregateOutputType = {
    id: string | null
    tag_text: string | null
  }

  export type HashesMaxAggregateOutputType = {
    id: string | null
    tag_text: string | null
  }

  export type HashesCountAggregateOutputType = {
    id: number
    tag_text: number
    _all: number
  }


  export type HashesMinAggregateInputType = {
    id?: true
    tag_text?: true
  }

  export type HashesMaxAggregateInputType = {
    id?: true
    tag_text?: true
  }

  export type HashesCountAggregateInputType = {
    id?: true
    tag_text?: true
    _all?: true
  }

  export type HashesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hashes to aggregate.
     */
    where?: hashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashes to fetch.
     */
    orderBy?: hashesOrderByWithRelationInput | hashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hashes
    **/
    _count?: true | HashesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashesMaxAggregateInputType
  }

  export type GetHashesAggregateType<T extends HashesAggregateArgs> = {
        [P in keyof T & keyof AggregateHashes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashes[P]>
      : GetScalarType<T[P], AggregateHashes[P]>
  }




  export type hashesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hashesWhereInput
    orderBy?: hashesOrderByWithAggregationInput | hashesOrderByWithAggregationInput[]
    by: HashesScalarFieldEnum[] | HashesScalarFieldEnum
    having?: hashesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashesCountAggregateInputType | true
    _min?: HashesMinAggregateInputType
    _max?: HashesMaxAggregateInputType
  }

  export type HashesGroupByOutputType = {
    id: string
    tag_text: string
    _count: HashesCountAggregateOutputType | null
    _min: HashesMinAggregateOutputType | null
    _max: HashesMaxAggregateOutputType | null
  }

  type GetHashesGroupByPayload<T extends hashesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HashesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashesGroupByOutputType[P]>
            : GetScalarType<T[P], HashesGroupByOutputType[P]>
        }
      >
    >


  export type hashesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_text?: boolean
    tweetHashes?: boolean | hashes$tweetHashesArgs<ExtArgs>
    _count?: boolean | HashesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hashes"]>

  export type hashesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_text?: boolean
  }, ExtArgs["result"]["hashes"]>

  export type hashesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_text?: boolean
  }, ExtArgs["result"]["hashes"]>

  export type hashesSelectScalar = {
    id?: boolean
    tag_text?: boolean
  }

  export type hashesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag_text", ExtArgs["result"]["hashes"]>
  export type hashesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweetHashes?: boolean | hashes$tweetHashesArgs<ExtArgs>
    _count?: boolean | HashesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type hashesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type hashesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $hashesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hashes"
    objects: {
      tweetHashes: Prisma.$tweetHashesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag_text: string
    }, ExtArgs["result"]["hashes"]>
    composites: {}
  }

  type hashesGetPayload<S extends boolean | null | undefined | hashesDefaultArgs> = $Result.GetResult<Prisma.$hashesPayload, S>

  type hashesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hashesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HashesCountAggregateInputType | true
    }

  export interface hashesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hashes'], meta: { name: 'hashes' } }
    /**
     * Find zero or one Hashes that matches the filter.
     * @param {hashesFindUniqueArgs} args - Arguments to find a Hashes
     * @example
     * // Get one Hashes
     * const hashes = await prisma.hashes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hashesFindUniqueArgs>(args: SelectSubset<T, hashesFindUniqueArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hashes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hashesFindUniqueOrThrowArgs} args - Arguments to find a Hashes
     * @example
     * // Get one Hashes
     * const hashes = await prisma.hashes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hashesFindUniqueOrThrowArgs>(args: SelectSubset<T, hashesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesFindFirstArgs} args - Arguments to find a Hashes
     * @example
     * // Get one Hashes
     * const hashes = await prisma.hashes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hashesFindFirstArgs>(args?: SelectSubset<T, hashesFindFirstArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesFindFirstOrThrowArgs} args - Arguments to find a Hashes
     * @example
     * // Get one Hashes
     * const hashes = await prisma.hashes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hashesFindFirstOrThrowArgs>(args?: SelectSubset<T, hashesFindFirstOrThrowArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hashes
     * const hashes = await prisma.hashes.findMany()
     * 
     * // Get first 10 Hashes
     * const hashes = await prisma.hashes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hashesWithIdOnly = await prisma.hashes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hashesFindManyArgs>(args?: SelectSubset<T, hashesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hashes.
     * @param {hashesCreateArgs} args - Arguments to create a Hashes.
     * @example
     * // Create one Hashes
     * const Hashes = await prisma.hashes.create({
     *   data: {
     *     // ... data to create a Hashes
     *   }
     * })
     * 
     */
    create<T extends hashesCreateArgs>(args: SelectSubset<T, hashesCreateArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hashes.
     * @param {hashesCreateManyArgs} args - Arguments to create many Hashes.
     * @example
     * // Create many Hashes
     * const hashes = await prisma.hashes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hashesCreateManyArgs>(args?: SelectSubset<T, hashesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hashes and returns the data saved in the database.
     * @param {hashesCreateManyAndReturnArgs} args - Arguments to create many Hashes.
     * @example
     * // Create many Hashes
     * const hashes = await prisma.hashes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hashes and only return the `id`
     * const hashesWithIdOnly = await prisma.hashes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends hashesCreateManyAndReturnArgs>(args?: SelectSubset<T, hashesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hashes.
     * @param {hashesDeleteArgs} args - Arguments to delete one Hashes.
     * @example
     * // Delete one Hashes
     * const Hashes = await prisma.hashes.delete({
     *   where: {
     *     // ... filter to delete one Hashes
     *   }
     * })
     * 
     */
    delete<T extends hashesDeleteArgs>(args: SelectSubset<T, hashesDeleteArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hashes.
     * @param {hashesUpdateArgs} args - Arguments to update one Hashes.
     * @example
     * // Update one Hashes
     * const hashes = await prisma.hashes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hashesUpdateArgs>(args: SelectSubset<T, hashesUpdateArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hashes.
     * @param {hashesDeleteManyArgs} args - Arguments to filter Hashes to delete.
     * @example
     * // Delete a few Hashes
     * const { count } = await prisma.hashes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hashesDeleteManyArgs>(args?: SelectSubset<T, hashesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hashes
     * const hashes = await prisma.hashes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hashesUpdateManyArgs>(args: SelectSubset<T, hashesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hashes and returns the data updated in the database.
     * @param {hashesUpdateManyAndReturnArgs} args - Arguments to update many Hashes.
     * @example
     * // Update many Hashes
     * const hashes = await prisma.hashes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hashes and only return the `id`
     * const hashesWithIdOnly = await prisma.hashes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends hashesUpdateManyAndReturnArgs>(args: SelectSubset<T, hashesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hashes.
     * @param {hashesUpsertArgs} args - Arguments to update or create a Hashes.
     * @example
     * // Update or create a Hashes
     * const hashes = await prisma.hashes.upsert({
     *   create: {
     *     // ... data to create a Hashes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hashes we want to update
     *   }
     * })
     */
    upsert<T extends hashesUpsertArgs>(args: SelectSubset<T, hashesUpsertArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesCountArgs} args - Arguments to filter Hashes to count.
     * @example
     * // Count the number of Hashes
     * const count = await prisma.hashes.count({
     *   where: {
     *     // ... the filter for the Hashes we want to count
     *   }
     * })
    **/
    count<T extends hashesCountArgs>(
      args?: Subset<T, hashesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashesAggregateArgs>(args: Subset<T, HashesAggregateArgs>): Prisma.PrismaPromise<GetHashesAggregateType<T>>

    /**
     * Group by Hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hashesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hashesGroupByArgs['orderBy'] }
        : { orderBy?: hashesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hashesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hashes model
   */
  readonly fields: hashesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hashes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hashesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweetHashes<T extends hashes$tweetHashesArgs<ExtArgs> = {}>(args?: Subset<T, hashes$tweetHashesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hashes model
   */
  interface hashesFieldRefs {
    readonly id: FieldRef<"hashes", 'String'>
    readonly tag_text: FieldRef<"hashes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * hashes findUnique
   */
  export type hashesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter, which hashes to fetch.
     */
    where: hashesWhereUniqueInput
  }

  /**
   * hashes findUniqueOrThrow
   */
  export type hashesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter, which hashes to fetch.
     */
    where: hashesWhereUniqueInput
  }

  /**
   * hashes findFirst
   */
  export type hashesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter, which hashes to fetch.
     */
    where?: hashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashes to fetch.
     */
    orderBy?: hashesOrderByWithRelationInput | hashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hashes.
     */
    cursor?: hashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hashes.
     */
    distinct?: HashesScalarFieldEnum | HashesScalarFieldEnum[]
  }

  /**
   * hashes findFirstOrThrow
   */
  export type hashesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter, which hashes to fetch.
     */
    where?: hashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashes to fetch.
     */
    orderBy?: hashesOrderByWithRelationInput | hashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hashes.
     */
    cursor?: hashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hashes.
     */
    distinct?: HashesScalarFieldEnum | HashesScalarFieldEnum[]
  }

  /**
   * hashes findMany
   */
  export type hashesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter, which hashes to fetch.
     */
    where?: hashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashes to fetch.
     */
    orderBy?: hashesOrderByWithRelationInput | hashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hashes.
     */
    cursor?: hashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashes.
     */
    skip?: number
    distinct?: HashesScalarFieldEnum | HashesScalarFieldEnum[]
  }

  /**
   * hashes create
   */
  export type hashesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * The data needed to create a hashes.
     */
    data: XOR<hashesCreateInput, hashesUncheckedCreateInput>
  }

  /**
   * hashes createMany
   */
  export type hashesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hashes.
     */
    data: hashesCreateManyInput | hashesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hashes createManyAndReturn
   */
  export type hashesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * The data used to create many hashes.
     */
    data: hashesCreateManyInput | hashesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hashes update
   */
  export type hashesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * The data needed to update a hashes.
     */
    data: XOR<hashesUpdateInput, hashesUncheckedUpdateInput>
    /**
     * Choose, which hashes to update.
     */
    where: hashesWhereUniqueInput
  }

  /**
   * hashes updateMany
   */
  export type hashesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hashes.
     */
    data: XOR<hashesUpdateManyMutationInput, hashesUncheckedUpdateManyInput>
    /**
     * Filter which hashes to update
     */
    where?: hashesWhereInput
    /**
     * Limit how many hashes to update.
     */
    limit?: number
  }

  /**
   * hashes updateManyAndReturn
   */
  export type hashesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * The data used to update hashes.
     */
    data: XOR<hashesUpdateManyMutationInput, hashesUncheckedUpdateManyInput>
    /**
     * Filter which hashes to update
     */
    where?: hashesWhereInput
    /**
     * Limit how many hashes to update.
     */
    limit?: number
  }

  /**
   * hashes upsert
   */
  export type hashesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * The filter to search for the hashes to update in case it exists.
     */
    where: hashesWhereUniqueInput
    /**
     * In case the hashes found by the `where` argument doesn't exist, create a new hashes with this data.
     */
    create: XOR<hashesCreateInput, hashesUncheckedCreateInput>
    /**
     * In case the hashes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hashesUpdateInput, hashesUncheckedUpdateInput>
  }

  /**
   * hashes delete
   */
  export type hashesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
    /**
     * Filter which hashes to delete.
     */
    where: hashesWhereUniqueInput
  }

  /**
   * hashes deleteMany
   */
  export type hashesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hashes to delete
     */
    where?: hashesWhereInput
    /**
     * Limit how many hashes to delete.
     */
    limit?: number
  }

  /**
   * hashes.tweetHashes
   */
  export type hashes$tweetHashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    where?: tweetHashesWhereInput
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    cursor?: tweetHashesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetHashesScalarFieldEnum | TweetHashesScalarFieldEnum[]
  }

  /**
   * hashes without action
   */
  export type hashesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashes
     */
    select?: hashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashes
     */
    omit?: hashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hashesInclude<ExtArgs> | null
  }


  /**
   * Model medias
   */

  export type AggregateMedias = {
    _count: MediasCountAggregateOutputType | null
    _avg: MediasAvgAggregateOutputType | null
    _sum: MediasSumAggregateOutputType | null
    _min: MediasMinAggregateOutputType | null
    _max: MediasMaxAggregateOutputType | null
  }

  export type MediasAvgAggregateOutputType = {
    size: number | null
  }

  export type MediasSumAggregateOutputType = {
    size: number | null
  }

  export type MediasMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: $Enums.MediaType | null
    size: number | null
  }

  export type MediasMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: $Enums.MediaType | null
    size: number | null
  }

  export type MediasCountAggregateOutputType = {
    id: number
    name: number
    url: number
    type: number
    size: number
    _all: number
  }


  export type MediasAvgAggregateInputType = {
    size?: true
  }

  export type MediasSumAggregateInputType = {
    size?: true
  }

  export type MediasMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    size?: true
  }

  export type MediasMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    size?: true
  }

  export type MediasCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    size?: true
    _all?: true
  }

  export type MediasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medias to aggregate.
     */
    where?: mediasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medias to fetch.
     */
    orderBy?: mediasOrderByWithRelationInput | mediasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mediasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medias
    **/
    _count?: true | MediasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediasMaxAggregateInputType
  }

  export type GetMediasAggregateType<T extends MediasAggregateArgs> = {
        [P in keyof T & keyof AggregateMedias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedias[P]>
      : GetScalarType<T[P], AggregateMedias[P]>
  }




  export type mediasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mediasWhereInput
    orderBy?: mediasOrderByWithAggregationInput | mediasOrderByWithAggregationInput[]
    by: MediasScalarFieldEnum[] | MediasScalarFieldEnum
    having?: mediasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediasCountAggregateInputType | true
    _avg?: MediasAvgAggregateInputType
    _sum?: MediasSumAggregateInputType
    _min?: MediasMinAggregateInputType
    _max?: MediasMaxAggregateInputType
  }

  export type MediasGroupByOutputType = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size: number | null
    _count: MediasCountAggregateOutputType | null
    _avg: MediasAvgAggregateOutputType | null
    _sum: MediasSumAggregateOutputType | null
    _min: MediasMinAggregateOutputType | null
    _max: MediasMaxAggregateOutputType | null
  }

  type GetMediasGroupByPayload<T extends mediasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediasGroupByOutputType[P]>
            : GetScalarType<T[P], MediasGroupByOutputType[P]>
        }
      >
    >


  export type mediasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
    MessageMedia?: boolean | medias$MessageMediaArgs<ExtArgs>
    TweetMedia?: boolean | medias$TweetMediaArgs<ExtArgs>
    _count?: boolean | MediasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medias"]>

  export type mediasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
  }, ExtArgs["result"]["medias"]>

  export type mediasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
  }, ExtArgs["result"]["medias"]>

  export type mediasSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
  }

  export type mediasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "type" | "size", ExtArgs["result"]["medias"]>
  export type mediasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageMedia?: boolean | medias$MessageMediaArgs<ExtArgs>
    TweetMedia?: boolean | medias$TweetMediaArgs<ExtArgs>
    _count?: boolean | MediasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mediasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type mediasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $mediasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medias"
    objects: {
      MessageMedia: Prisma.$MessageMediaPayload<ExtArgs>[]
      TweetMedia: Prisma.$TweetMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      type: $Enums.MediaType
      size: number | null
    }, ExtArgs["result"]["medias"]>
    composites: {}
  }

  type mediasGetPayload<S extends boolean | null | undefined | mediasDefaultArgs> = $Result.GetResult<Prisma.$mediasPayload, S>

  type mediasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mediasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediasCountAggregateInputType | true
    }

  export interface mediasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medias'], meta: { name: 'medias' } }
    /**
     * Find zero or one Medias that matches the filter.
     * @param {mediasFindUniqueArgs} args - Arguments to find a Medias
     * @example
     * // Get one Medias
     * const medias = await prisma.medias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mediasFindUniqueArgs>(args: SelectSubset<T, mediasFindUniqueArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mediasFindUniqueOrThrowArgs} args - Arguments to find a Medias
     * @example
     * // Get one Medias
     * const medias = await prisma.medias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mediasFindUniqueOrThrowArgs>(args: SelectSubset<T, mediasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasFindFirstArgs} args - Arguments to find a Medias
     * @example
     * // Get one Medias
     * const medias = await prisma.medias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mediasFindFirstArgs>(args?: SelectSubset<T, mediasFindFirstArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasFindFirstOrThrowArgs} args - Arguments to find a Medias
     * @example
     * // Get one Medias
     * const medias = await prisma.medias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mediasFindFirstOrThrowArgs>(args?: SelectSubset<T, mediasFindFirstOrThrowArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medias
     * const medias = await prisma.medias.findMany()
     * 
     * // Get first 10 Medias
     * const medias = await prisma.medias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediasWithIdOnly = await prisma.medias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mediasFindManyArgs>(args?: SelectSubset<T, mediasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medias.
     * @param {mediasCreateArgs} args - Arguments to create a Medias.
     * @example
     * // Create one Medias
     * const Medias = await prisma.medias.create({
     *   data: {
     *     // ... data to create a Medias
     *   }
     * })
     * 
     */
    create<T extends mediasCreateArgs>(args: SelectSubset<T, mediasCreateArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medias.
     * @param {mediasCreateManyArgs} args - Arguments to create many Medias.
     * @example
     * // Create many Medias
     * const medias = await prisma.medias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mediasCreateManyArgs>(args?: SelectSubset<T, mediasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medias and returns the data saved in the database.
     * @param {mediasCreateManyAndReturnArgs} args - Arguments to create many Medias.
     * @example
     * // Create many Medias
     * const medias = await prisma.medias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medias and only return the `id`
     * const mediasWithIdOnly = await prisma.medias.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mediasCreateManyAndReturnArgs>(args?: SelectSubset<T, mediasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medias.
     * @param {mediasDeleteArgs} args - Arguments to delete one Medias.
     * @example
     * // Delete one Medias
     * const Medias = await prisma.medias.delete({
     *   where: {
     *     // ... filter to delete one Medias
     *   }
     * })
     * 
     */
    delete<T extends mediasDeleteArgs>(args: SelectSubset<T, mediasDeleteArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medias.
     * @param {mediasUpdateArgs} args - Arguments to update one Medias.
     * @example
     * // Update one Medias
     * const medias = await prisma.medias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mediasUpdateArgs>(args: SelectSubset<T, mediasUpdateArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medias.
     * @param {mediasDeleteManyArgs} args - Arguments to filter Medias to delete.
     * @example
     * // Delete a few Medias
     * const { count } = await prisma.medias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mediasDeleteManyArgs>(args?: SelectSubset<T, mediasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medias
     * const medias = await prisma.medias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mediasUpdateManyArgs>(args: SelectSubset<T, mediasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medias and returns the data updated in the database.
     * @param {mediasUpdateManyAndReturnArgs} args - Arguments to update many Medias.
     * @example
     * // Update many Medias
     * const medias = await prisma.medias.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medias and only return the `id`
     * const mediasWithIdOnly = await prisma.medias.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mediasUpdateManyAndReturnArgs>(args: SelectSubset<T, mediasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medias.
     * @param {mediasUpsertArgs} args - Arguments to update or create a Medias.
     * @example
     * // Update or create a Medias
     * const medias = await prisma.medias.upsert({
     *   create: {
     *     // ... data to create a Medias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medias we want to update
     *   }
     * })
     */
    upsert<T extends mediasUpsertArgs>(args: SelectSubset<T, mediasUpsertArgs<ExtArgs>>): Prisma__mediasClient<$Result.GetResult<Prisma.$mediasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasCountArgs} args - Arguments to filter Medias to count.
     * @example
     * // Count the number of Medias
     * const count = await prisma.medias.count({
     *   where: {
     *     // ... the filter for the Medias we want to count
     *   }
     * })
    **/
    count<T extends mediasCountArgs>(
      args?: Subset<T, mediasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediasAggregateArgs>(args: Subset<T, MediasAggregateArgs>): Prisma.PrismaPromise<GetMediasAggregateType<T>>

    /**
     * Group by Medias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mediasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mediasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mediasGroupByArgs['orderBy'] }
        : { orderBy?: mediasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mediasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medias model
   */
  readonly fields: mediasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mediasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageMedia<T extends medias$MessageMediaArgs<ExtArgs> = {}>(args?: Subset<T, medias$MessageMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TweetMedia<T extends medias$TweetMediaArgs<ExtArgs> = {}>(args?: Subset<T, medias$TweetMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medias model
   */
  interface mediasFieldRefs {
    readonly id: FieldRef<"medias", 'String'>
    readonly name: FieldRef<"medias", 'String'>
    readonly url: FieldRef<"medias", 'String'>
    readonly type: FieldRef<"medias", 'MediaType'>
    readonly size: FieldRef<"medias", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * medias findUnique
   */
  export type mediasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter, which medias to fetch.
     */
    where: mediasWhereUniqueInput
  }

  /**
   * medias findUniqueOrThrow
   */
  export type mediasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter, which medias to fetch.
     */
    where: mediasWhereUniqueInput
  }

  /**
   * medias findFirst
   */
  export type mediasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter, which medias to fetch.
     */
    where?: mediasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medias to fetch.
     */
    orderBy?: mediasOrderByWithRelationInput | mediasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medias.
     */
    cursor?: mediasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medias.
     */
    distinct?: MediasScalarFieldEnum | MediasScalarFieldEnum[]
  }

  /**
   * medias findFirstOrThrow
   */
  export type mediasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter, which medias to fetch.
     */
    where?: mediasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medias to fetch.
     */
    orderBy?: mediasOrderByWithRelationInput | mediasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medias.
     */
    cursor?: mediasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medias.
     */
    distinct?: MediasScalarFieldEnum | MediasScalarFieldEnum[]
  }

  /**
   * medias findMany
   */
  export type mediasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter, which medias to fetch.
     */
    where?: mediasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medias to fetch.
     */
    orderBy?: mediasOrderByWithRelationInput | mediasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medias.
     */
    cursor?: mediasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medias.
     */
    skip?: number
    distinct?: MediasScalarFieldEnum | MediasScalarFieldEnum[]
  }

  /**
   * medias create
   */
  export type mediasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * The data needed to create a medias.
     */
    data: XOR<mediasCreateInput, mediasUncheckedCreateInput>
  }

  /**
   * medias createMany
   */
  export type mediasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medias.
     */
    data: mediasCreateManyInput | mediasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medias createManyAndReturn
   */
  export type mediasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * The data used to create many medias.
     */
    data: mediasCreateManyInput | mediasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medias update
   */
  export type mediasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * The data needed to update a medias.
     */
    data: XOR<mediasUpdateInput, mediasUncheckedUpdateInput>
    /**
     * Choose, which medias to update.
     */
    where: mediasWhereUniqueInput
  }

  /**
   * medias updateMany
   */
  export type mediasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medias.
     */
    data: XOR<mediasUpdateManyMutationInput, mediasUncheckedUpdateManyInput>
    /**
     * Filter which medias to update
     */
    where?: mediasWhereInput
    /**
     * Limit how many medias to update.
     */
    limit?: number
  }

  /**
   * medias updateManyAndReturn
   */
  export type mediasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * The data used to update medias.
     */
    data: XOR<mediasUpdateManyMutationInput, mediasUncheckedUpdateManyInput>
    /**
     * Filter which medias to update
     */
    where?: mediasWhereInput
    /**
     * Limit how many medias to update.
     */
    limit?: number
  }

  /**
   * medias upsert
   */
  export type mediasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * The filter to search for the medias to update in case it exists.
     */
    where: mediasWhereUniqueInput
    /**
     * In case the medias found by the `where` argument doesn't exist, create a new medias with this data.
     */
    create: XOR<mediasCreateInput, mediasUncheckedCreateInput>
    /**
     * In case the medias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mediasUpdateInput, mediasUncheckedUpdateInput>
  }

  /**
   * medias delete
   */
  export type mediasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
    /**
     * Filter which medias to delete.
     */
    where: mediasWhereUniqueInput
  }

  /**
   * medias deleteMany
   */
  export type mediasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medias to delete
     */
    where?: mediasWhereInput
    /**
     * Limit how many medias to delete.
     */
    limit?: number
  }

  /**
   * medias.MessageMedia
   */
  export type medias$MessageMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    where?: MessageMediaWhereInput
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    cursor?: MessageMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageMediaScalarFieldEnum | MessageMediaScalarFieldEnum[]
  }

  /**
   * medias.TweetMedia
   */
  export type medias$TweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    where?: TweetMediaWhereInput
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    cursor?: TweetMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * medias without action
   */
  export type mediasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medias
     */
    select?: mediasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medias
     */
    omit?: mediasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mediasInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    status: $Enums.MessageStatus | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    status: $Enums.MessageStatus | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    chatId: number
    userId: number
    content: number
    createdAt: number
    status: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
    status?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
    status?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    content?: true
    createdAt?: true
    status?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    chatId: string
    userId: string
    content: string
    createdAt: Date
    status: $Enums.MessageStatus
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    status?: boolean
    MessageMedia?: boolean | messages$MessageMediaArgs<ExtArgs>
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    status?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    status?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectScalar = {
    id?: boolean
    chatId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    status?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "userId" | "content" | "createdAt" | "status", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageMedia?: boolean | messages$MessageMediaArgs<ExtArgs>
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      MessageMedia: Prisma.$MessageMediaPayload<ExtArgs>[]
      chats: Prisma.$chatsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      userId: string
      content: string
      createdAt: Date
      status: $Enums.MessageStatus
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageMedia<T extends messages$MessageMediaArgs<ExtArgs> = {}>(args?: Subset<T, messages$MessageMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'String'>
    readonly chatId: FieldRef<"messages", 'String'>
    readonly userId: FieldRef<"messages", 'String'>
    readonly content: FieldRef<"messages", 'String'>
    readonly createdAt: FieldRef<"messages", 'DateTime'>
    readonly status: FieldRef<"messages", 'MessageStatus'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages createManyAndReturn
   */
  export type messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * messages updateManyAndReturn
   */
  export type messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * messages.MessageMedia
   */
  export type messages$MessageMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageMedia
     */
    select?: MessageMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageMedia
     */
    omit?: MessageMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageMediaInclude<ExtArgs> | null
    where?: MessageMediaWhereInput
    orderBy?: MessageMediaOrderByWithRelationInput | MessageMediaOrderByWithRelationInput[]
    cursor?: MessageMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageMediaScalarFieldEnum | MessageMediaScalarFieldEnum[]
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
    tweetId: string | null
    actorId: string | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
    tweetId: string | null
    actorId: string | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    type: number
    content: number
    isRead: number
    createdAt: number
    userId: number
    tweetId: number
    actorId: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    tweetId?: true
    actorId?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    tweetId?: true
    actorId?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    tweetId?: true
    actorId?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead: boolean
    createdAt: Date
    userId: string
    tweetId: string | null
    actorId: string | null
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    tweetId?: boolean
    actorId?: boolean
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    tweetId?: boolean
    actorId?: boolean
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    tweetId?: boolean
    actorId?: boolean
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    tweetId?: boolean
    actorId?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "isRead" | "createdAt" | "userId" | "tweetId" | "actorId", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_notifications_actorIdTousers?: boolean | notifications$users_notifications_actorIdTousersArgs<ExtArgs>
    tweets?: boolean | notifications$tweetsArgs<ExtArgs>
    users_notifications_userIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users_notifications_actorIdTousers: Prisma.$usersPayload<ExtArgs> | null
      tweets: Prisma.$tweetsPayload<ExtArgs> | null
      users_notifications_userIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      content: string
      isRead: boolean
      createdAt: Date
      userId: string
      tweetId: string | null
      actorId: string | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_notifications_actorIdTousers<T extends notifications$users_notifications_actorIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, notifications$users_notifications_actorIdTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tweets<T extends notifications$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, notifications$tweetsArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_notifications_userIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'NotificationType'>
    readonly content: FieldRef<"notifications", 'String'>
    readonly isRead: FieldRef<"notifications", 'Boolean'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly tweetId: FieldRef<"notifications", 'String'>
    readonly actorId: FieldRef<"notifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications.users_notifications_actorIdTousers
   */
  export type notifications$users_notifications_actorIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * notifications.tweets
   */
  export type notifications$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    where?: tweetsWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model spatial_ref_sys
   */

  export type AggregateSpatial_ref_sys = {
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  export type Spatial_ref_sysAvgAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysSumAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysMinAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysMaxAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysCountAggregateOutputType = {
    srid: number
    auth_name: number
    auth_srid: number
    srtext: number
    proj4text: number
    _all: number
  }


  export type Spatial_ref_sysAvgAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysSumAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysMinAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysMaxAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysCountAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
    _all?: true
  }

  export type Spatial_ref_sysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to aggregate.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spatial_ref_sys
    **/
    _count?: true | Spatial_ref_sysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Spatial_ref_sysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Spatial_ref_sysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Spatial_ref_sysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type GetSpatial_ref_sysAggregateType<T extends Spatial_ref_sysAggregateArgs> = {
        [P in keyof T & keyof AggregateSpatial_ref_sys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
      : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
  }




  export type spatial_ref_sysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: spatial_ref_sysWhereInput
    orderBy?: spatial_ref_sysOrderByWithAggregationInput | spatial_ref_sysOrderByWithAggregationInput[]
    by: Spatial_ref_sysScalarFieldEnum[] | Spatial_ref_sysScalarFieldEnum
    having?: spatial_ref_sysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Spatial_ref_sysCountAggregateInputType | true
    _avg?: Spatial_ref_sysAvgAggregateInputType
    _sum?: Spatial_ref_sysSumAggregateInputType
    _min?: Spatial_ref_sysMinAggregateInputType
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type Spatial_ref_sysGroupByOutputType = {
    srid: number
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  type GetSpatial_ref_sysGroupByPayload<T extends spatial_ref_sysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Spatial_ref_sysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Spatial_ref_sysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
            : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
        }
      >
    >


  export type spatial_ref_sysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectScalar = {
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }

  export type spatial_ref_sysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"srid" | "auth_name" | "auth_srid" | "srtext" | "proj4text", ExtArgs["result"]["spatial_ref_sys"]>

  export type $spatial_ref_sysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "spatial_ref_sys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      srid: number
      auth_name: string | null
      auth_srid: number | null
      srtext: string | null
      proj4text: string | null
    }, ExtArgs["result"]["spatial_ref_sys"]>
    composites: {}
  }

  type spatial_ref_sysGetPayload<S extends boolean | null | undefined | spatial_ref_sysDefaultArgs> = $Result.GetResult<Prisma.$spatial_ref_sysPayload, S>

  type spatial_ref_sysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<spatial_ref_sysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Spatial_ref_sysCountAggregateInputType | true
    }

  export interface spatial_ref_sysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spatial_ref_sys'], meta: { name: 'spatial_ref_sys' } }
    /**
     * Find zero or one Spatial_ref_sys that matches the filter.
     * @param {spatial_ref_sysFindUniqueArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends spatial_ref_sysFindUniqueArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spatial_ref_sys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {spatial_ref_sysFindUniqueOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends spatial_ref_sysFindUniqueOrThrowArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends spatial_ref_sysFindFirstArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spatial_ref_sys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends spatial_ref_sysFindFirstOrThrowArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
     * 
     * // Get first 10 Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany({ take: 10 })
     * 
     * // Only select the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.findMany({ select: { srid: true } })
     * 
     */
    findMany<T extends spatial_ref_sysFindManyArgs>(args?: SelectSubset<T, spatial_ref_sysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spatial_ref_sys.
     * @param {spatial_ref_sysCreateArgs} args - Arguments to create a Spatial_ref_sys.
     * @example
     * // Create one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.create({
     *   data: {
     *     // ... data to create a Spatial_ref_sys
     *   }
     * })
     * 
     */
    create<T extends spatial_ref_sysCreateArgs>(args: SelectSubset<T, spatial_ref_sysCreateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spatial_ref_sys.
     * @param {spatial_ref_sysCreateManyArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends spatial_ref_sysCreateManyArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spatial_ref_sys and returns the data saved in the database.
     * @param {spatial_ref_sysCreateManyAndReturnArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.createManyAndReturn({
     *   select: { srid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends spatial_ref_sysCreateManyAndReturnArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteArgs} args - Arguments to delete one Spatial_ref_sys.
     * @example
     * // Delete one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.delete({
     *   where: {
     *     // ... filter to delete one Spatial_ref_sys
     *   }
     * })
     * 
     */
    delete<T extends spatial_ref_sysDeleteArgs>(args: SelectSubset<T, spatial_ref_sysDeleteArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpdateArgs} args - Arguments to update one Spatial_ref_sys.
     * @example
     * // Update one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends spatial_ref_sysUpdateArgs>(args: SelectSubset<T, spatial_ref_sysUpdateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteManyArgs} args - Arguments to filter Spatial_ref_sys to delete.
     * @example
     * // Delete a few Spatial_ref_sys
     * const { count } = await prisma.spatial_ref_sys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends spatial_ref_sysDeleteManyArgs>(args?: SelectSubset<T, spatial_ref_sysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends spatial_ref_sysUpdateManyArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys and returns the data updated in the database.
     * @param {spatial_ref_sysUpdateManyAndReturnArgs} args - Arguments to update many Spatial_ref_sys.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.updateManyAndReturn({
     *   select: { srid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends spatial_ref_sysUpdateManyAndReturnArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpsertArgs} args - Arguments to update or create a Spatial_ref_sys.
     * @example
     * // Update or create a Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.upsert({
     *   create: {
     *     // ... data to create a Spatial_ref_sys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to update
     *   }
     * })
     */
    upsert<T extends spatial_ref_sysUpsertArgs>(args: SelectSubset<T, spatial_ref_sysUpsertArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysCountArgs} args - Arguments to filter Spatial_ref_sys to count.
     * @example
     * // Count the number of Spatial_ref_sys
     * const count = await prisma.spatial_ref_sys.count({
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to count
     *   }
     * })
    **/
    count<T extends spatial_ref_sysCountArgs>(
      args?: Subset<T, spatial_ref_sysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Spatial_ref_sysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Spatial_ref_sysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Spatial_ref_sysAggregateArgs>(args: Subset<T, Spatial_ref_sysAggregateArgs>): Prisma.PrismaPromise<GetSpatial_ref_sysAggregateType<T>>

    /**
     * Group by Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spatial_ref_sysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spatial_ref_sysGroupByArgs['orderBy'] }
        : { orderBy?: spatial_ref_sysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spatial_ref_sysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpatial_ref_sysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spatial_ref_sys model
   */
  readonly fields: spatial_ref_sysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spatial_ref_sys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spatial_ref_sysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the spatial_ref_sys model
   */
  interface spatial_ref_sysFieldRefs {
    readonly srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly auth_name: FieldRef<"spatial_ref_sys", 'String'>
    readonly auth_srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly srtext: FieldRef<"spatial_ref_sys", 'String'>
    readonly proj4text: FieldRef<"spatial_ref_sys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * spatial_ref_sys findUnique
   */
  export type spatial_ref_sysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findUniqueOrThrow
   */
  export type spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findFirst
   */
  export type spatial_ref_sysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findFirstOrThrow
   */
  export type spatial_ref_sysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findMany
   */
  export type spatial_ref_sysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys create
   */
  export type spatial_ref_sysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data needed to create a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
  }

  /**
   * spatial_ref_sys createMany
   */
  export type spatial_ref_sysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys createManyAndReturn
   */
  export type spatial_ref_sysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys update
   */
  export type spatial_ref_sysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data needed to update a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
    /**
     * Choose, which spatial_ref_sys to update.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys updateMany
   */
  export type spatial_ref_sysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to update.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys updateManyAndReturn
   */
  export type spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to update.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys upsert
   */
  export type spatial_ref_sysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The filter to search for the spatial_ref_sys to update in case it exists.
     */
    where: spatial_ref_sysWhereUniqueInput
    /**
     * In case the spatial_ref_sys found by the `where` argument doesn't exist, create a new spatial_ref_sys with this data.
     */
    create: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
    /**
     * In case the spatial_ref_sys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
  }

  /**
   * spatial_ref_sys delete
   */
  export type spatial_ref_sysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter which spatial_ref_sys to delete.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys deleteMany
   */
  export type spatial_ref_sysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to delete
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to delete.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys without action
   */
  export type spatial_ref_sysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
  }


  /**
   * Model tweetHashes
   */

  export type AggregateTweetHashes = {
    _count: TweetHashesCountAggregateOutputType | null
    _min: TweetHashesMinAggregateOutputType | null
    _max: TweetHashesMaxAggregateOutputType | null
  }

  export type TweetHashesMinAggregateOutputType = {
    tweetId: string | null
    hashId: string | null
  }

  export type TweetHashesMaxAggregateOutputType = {
    tweetId: string | null
    hashId: string | null
  }

  export type TweetHashesCountAggregateOutputType = {
    tweetId: number
    hashId: number
    _all: number
  }


  export type TweetHashesMinAggregateInputType = {
    tweetId?: true
    hashId?: true
  }

  export type TweetHashesMaxAggregateInputType = {
    tweetId?: true
    hashId?: true
  }

  export type TweetHashesCountAggregateInputType = {
    tweetId?: true
    hashId?: true
    _all?: true
  }

  export type TweetHashesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweetHashes to aggregate.
     */
    where?: tweetHashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetHashes to fetch.
     */
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tweetHashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tweetHashes
    **/
    _count?: true | TweetHashesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetHashesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetHashesMaxAggregateInputType
  }

  export type GetTweetHashesAggregateType<T extends TweetHashesAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetHashes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetHashes[P]>
      : GetScalarType<T[P], AggregateTweetHashes[P]>
  }




  export type tweetHashesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetHashesWhereInput
    orderBy?: tweetHashesOrderByWithAggregationInput | tweetHashesOrderByWithAggregationInput[]
    by: TweetHashesScalarFieldEnum[] | TweetHashesScalarFieldEnum
    having?: tweetHashesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetHashesCountAggregateInputType | true
    _min?: TweetHashesMinAggregateInputType
    _max?: TweetHashesMaxAggregateInputType
  }

  export type TweetHashesGroupByOutputType = {
    tweetId: string
    hashId: string
    _count: TweetHashesCountAggregateOutputType | null
    _min: TweetHashesMinAggregateOutputType | null
    _max: TweetHashesMaxAggregateOutputType | null
  }

  type GetTweetHashesGroupByPayload<T extends tweetHashesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetHashesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetHashesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetHashesGroupByOutputType[P]>
            : GetScalarType<T[P], TweetHashesGroupByOutputType[P]>
        }
      >
    >


  export type tweetHashesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    hashId?: boolean
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetHashes"]>

  export type tweetHashesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    hashId?: boolean
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetHashes"]>

  export type tweetHashesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tweetId?: boolean
    hashId?: boolean
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetHashes"]>

  export type tweetHashesSelectScalar = {
    tweetId?: boolean
    hashId?: boolean
  }

  export type tweetHashesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tweetId" | "hashId", ExtArgs["result"]["tweetHashes"]>
  export type tweetHashesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type tweetHashesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }
  export type tweetHashesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hashes?: boolean | hashesDefaultArgs<ExtArgs>
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
  }

  export type $tweetHashesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tweetHashes"
    objects: {
      hashes: Prisma.$hashesPayload<ExtArgs>
      tweets: Prisma.$tweetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tweetId: string
      hashId: string
    }, ExtArgs["result"]["tweetHashes"]>
    composites: {}
  }

  type tweetHashesGetPayload<S extends boolean | null | undefined | tweetHashesDefaultArgs> = $Result.GetResult<Prisma.$tweetHashesPayload, S>

  type tweetHashesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tweetHashesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetHashesCountAggregateInputType | true
    }

  export interface tweetHashesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tweetHashes'], meta: { name: 'tweetHashes' } }
    /**
     * Find zero or one TweetHashes that matches the filter.
     * @param {tweetHashesFindUniqueArgs} args - Arguments to find a TweetHashes
     * @example
     * // Get one TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tweetHashesFindUniqueArgs>(args: SelectSubset<T, tweetHashesFindUniqueArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TweetHashes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tweetHashesFindUniqueOrThrowArgs} args - Arguments to find a TweetHashes
     * @example
     * // Get one TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tweetHashesFindUniqueOrThrowArgs>(args: SelectSubset<T, tweetHashesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetHashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesFindFirstArgs} args - Arguments to find a TweetHashes
     * @example
     * // Get one TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tweetHashesFindFirstArgs>(args?: SelectSubset<T, tweetHashesFindFirstArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetHashes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesFindFirstOrThrowArgs} args - Arguments to find a TweetHashes
     * @example
     * // Get one TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tweetHashesFindFirstOrThrowArgs>(args?: SelectSubset<T, tweetHashesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TweetHashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findMany()
     * 
     * // Get first 10 TweetHashes
     * const tweetHashes = await prisma.tweetHashes.findMany({ take: 10 })
     * 
     * // Only select the `tweetId`
     * const tweetHashesWithTweetIdOnly = await prisma.tweetHashes.findMany({ select: { tweetId: true } })
     * 
     */
    findMany<T extends tweetHashesFindManyArgs>(args?: SelectSubset<T, tweetHashesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TweetHashes.
     * @param {tweetHashesCreateArgs} args - Arguments to create a TweetHashes.
     * @example
     * // Create one TweetHashes
     * const TweetHashes = await prisma.tweetHashes.create({
     *   data: {
     *     // ... data to create a TweetHashes
     *   }
     * })
     * 
     */
    create<T extends tweetHashesCreateArgs>(args: SelectSubset<T, tweetHashesCreateArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TweetHashes.
     * @param {tweetHashesCreateManyArgs} args - Arguments to create many TweetHashes.
     * @example
     * // Create many TweetHashes
     * const tweetHashes = await prisma.tweetHashes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tweetHashesCreateManyArgs>(args?: SelectSubset<T, tweetHashesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TweetHashes and returns the data saved in the database.
     * @param {tweetHashesCreateManyAndReturnArgs} args - Arguments to create many TweetHashes.
     * @example
     * // Create many TweetHashes
     * const tweetHashes = await prisma.tweetHashes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TweetHashes and only return the `tweetId`
     * const tweetHashesWithTweetIdOnly = await prisma.tweetHashes.createManyAndReturn({
     *   select: { tweetId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tweetHashesCreateManyAndReturnArgs>(args?: SelectSubset<T, tweetHashesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TweetHashes.
     * @param {tweetHashesDeleteArgs} args - Arguments to delete one TweetHashes.
     * @example
     * // Delete one TweetHashes
     * const TweetHashes = await prisma.tweetHashes.delete({
     *   where: {
     *     // ... filter to delete one TweetHashes
     *   }
     * })
     * 
     */
    delete<T extends tweetHashesDeleteArgs>(args: SelectSubset<T, tweetHashesDeleteArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TweetHashes.
     * @param {tweetHashesUpdateArgs} args - Arguments to update one TweetHashes.
     * @example
     * // Update one TweetHashes
     * const tweetHashes = await prisma.tweetHashes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tweetHashesUpdateArgs>(args: SelectSubset<T, tweetHashesUpdateArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TweetHashes.
     * @param {tweetHashesDeleteManyArgs} args - Arguments to filter TweetHashes to delete.
     * @example
     * // Delete a few TweetHashes
     * const { count } = await prisma.tweetHashes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tweetHashesDeleteManyArgs>(args?: SelectSubset<T, tweetHashesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TweetHashes
     * const tweetHashes = await prisma.tweetHashes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tweetHashesUpdateManyArgs>(args: SelectSubset<T, tweetHashesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetHashes and returns the data updated in the database.
     * @param {tweetHashesUpdateManyAndReturnArgs} args - Arguments to update many TweetHashes.
     * @example
     * // Update many TweetHashes
     * const tweetHashes = await prisma.tweetHashes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TweetHashes and only return the `tweetId`
     * const tweetHashesWithTweetIdOnly = await prisma.tweetHashes.updateManyAndReturn({
     *   select: { tweetId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tweetHashesUpdateManyAndReturnArgs>(args: SelectSubset<T, tweetHashesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TweetHashes.
     * @param {tweetHashesUpsertArgs} args - Arguments to update or create a TweetHashes.
     * @example
     * // Update or create a TweetHashes
     * const tweetHashes = await prisma.tweetHashes.upsert({
     *   create: {
     *     // ... data to create a TweetHashes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TweetHashes we want to update
     *   }
     * })
     */
    upsert<T extends tweetHashesUpsertArgs>(args: SelectSubset<T, tweetHashesUpsertArgs<ExtArgs>>): Prisma__tweetHashesClient<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TweetHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesCountArgs} args - Arguments to filter TweetHashes to count.
     * @example
     * // Count the number of TweetHashes
     * const count = await prisma.tweetHashes.count({
     *   where: {
     *     // ... the filter for the TweetHashes we want to count
     *   }
     * })
    **/
    count<T extends tweetHashesCountArgs>(
      args?: Subset<T, tweetHashesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetHashesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TweetHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetHashesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetHashesAggregateArgs>(args: Subset<T, TweetHashesAggregateArgs>): Prisma.PrismaPromise<GetTweetHashesAggregateType<T>>

    /**
     * Group by TweetHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetHashesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tweetHashesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tweetHashesGroupByArgs['orderBy'] }
        : { orderBy?: tweetHashesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tweetHashesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetHashesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tweetHashes model
   */
  readonly fields: tweetHashesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tweetHashes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tweetHashesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hashes<T extends hashesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hashesDefaultArgs<ExtArgs>>): Prisma__hashesClient<$Result.GetResult<Prisma.$hashesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tweetHashes model
   */
  interface tweetHashesFieldRefs {
    readonly tweetId: FieldRef<"tweetHashes", 'String'>
    readonly hashId: FieldRef<"tweetHashes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tweetHashes findUnique
   */
  export type tweetHashesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter, which tweetHashes to fetch.
     */
    where: tweetHashesWhereUniqueInput
  }

  /**
   * tweetHashes findUniqueOrThrow
   */
  export type tweetHashesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter, which tweetHashes to fetch.
     */
    where: tweetHashesWhereUniqueInput
  }

  /**
   * tweetHashes findFirst
   */
  export type tweetHashesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter, which tweetHashes to fetch.
     */
    where?: tweetHashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetHashes to fetch.
     */
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweetHashes.
     */
    cursor?: tweetHashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweetHashes.
     */
    distinct?: TweetHashesScalarFieldEnum | TweetHashesScalarFieldEnum[]
  }

  /**
   * tweetHashes findFirstOrThrow
   */
  export type tweetHashesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter, which tweetHashes to fetch.
     */
    where?: tweetHashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetHashes to fetch.
     */
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweetHashes.
     */
    cursor?: tweetHashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweetHashes.
     */
    distinct?: TweetHashesScalarFieldEnum | TweetHashesScalarFieldEnum[]
  }

  /**
   * tweetHashes findMany
   */
  export type tweetHashesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter, which tweetHashes to fetch.
     */
    where?: tweetHashesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetHashes to fetch.
     */
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tweetHashes.
     */
    cursor?: tweetHashesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetHashes.
     */
    skip?: number
    distinct?: TweetHashesScalarFieldEnum | TweetHashesScalarFieldEnum[]
  }

  /**
   * tweetHashes create
   */
  export type tweetHashesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * The data needed to create a tweetHashes.
     */
    data: XOR<tweetHashesCreateInput, tweetHashesUncheckedCreateInput>
  }

  /**
   * tweetHashes createMany
   */
  export type tweetHashesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tweetHashes.
     */
    data: tweetHashesCreateManyInput | tweetHashesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tweetHashes createManyAndReturn
   */
  export type tweetHashesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * The data used to create many tweetHashes.
     */
    data: tweetHashesCreateManyInput | tweetHashesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweetHashes update
   */
  export type tweetHashesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * The data needed to update a tweetHashes.
     */
    data: XOR<tweetHashesUpdateInput, tweetHashesUncheckedUpdateInput>
    /**
     * Choose, which tweetHashes to update.
     */
    where: tweetHashesWhereUniqueInput
  }

  /**
   * tweetHashes updateMany
   */
  export type tweetHashesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tweetHashes.
     */
    data: XOR<tweetHashesUpdateManyMutationInput, tweetHashesUncheckedUpdateManyInput>
    /**
     * Filter which tweetHashes to update
     */
    where?: tweetHashesWhereInput
    /**
     * Limit how many tweetHashes to update.
     */
    limit?: number
  }

  /**
   * tweetHashes updateManyAndReturn
   */
  export type tweetHashesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * The data used to update tweetHashes.
     */
    data: XOR<tweetHashesUpdateManyMutationInput, tweetHashesUncheckedUpdateManyInput>
    /**
     * Filter which tweetHashes to update
     */
    where?: tweetHashesWhereInput
    /**
     * Limit how many tweetHashes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweetHashes upsert
   */
  export type tweetHashesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * The filter to search for the tweetHashes to update in case it exists.
     */
    where: tweetHashesWhereUniqueInput
    /**
     * In case the tweetHashes found by the `where` argument doesn't exist, create a new tweetHashes with this data.
     */
    create: XOR<tweetHashesCreateInput, tweetHashesUncheckedCreateInput>
    /**
     * In case the tweetHashes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tweetHashesUpdateInput, tweetHashesUncheckedUpdateInput>
  }

  /**
   * tweetHashes delete
   */
  export type tweetHashesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    /**
     * Filter which tweetHashes to delete.
     */
    where: tweetHashesWhereUniqueInput
  }

  /**
   * tweetHashes deleteMany
   */
  export type tweetHashesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweetHashes to delete
     */
    where?: tweetHashesWhereInput
    /**
     * Limit how many tweetHashes to delete.
     */
    limit?: number
  }

  /**
   * tweetHashes without action
   */
  export type tweetHashesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
  }


  /**
   * Model tweetbookmarks
   */

  export type AggregateTweetbookmarks = {
    _count: TweetbookmarksCountAggregateOutputType | null
    _min: TweetbookmarksMinAggregateOutputType | null
    _max: TweetbookmarksMaxAggregateOutputType | null
  }

  export type TweetbookmarksMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
  }

  export type TweetbookmarksMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
  }

  export type TweetbookmarksCountAggregateOutputType = {
    id: number
    userId: number
    tweetId: number
    _all: number
  }


  export type TweetbookmarksMinAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
  }

  export type TweetbookmarksMaxAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
  }

  export type TweetbookmarksCountAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    _all?: true
  }

  export type TweetbookmarksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweetbookmarks to aggregate.
     */
    where?: tweetbookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetbookmarks to fetch.
     */
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tweetbookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetbookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetbookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tweetbookmarks
    **/
    _count?: true | TweetbookmarksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetbookmarksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetbookmarksMaxAggregateInputType
  }

  export type GetTweetbookmarksAggregateType<T extends TweetbookmarksAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetbookmarks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetbookmarks[P]>
      : GetScalarType<T[P], AggregateTweetbookmarks[P]>
  }




  export type tweetbookmarksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetbookmarksWhereInput
    orderBy?: tweetbookmarksOrderByWithAggregationInput | tweetbookmarksOrderByWithAggregationInput[]
    by: TweetbookmarksScalarFieldEnum[] | TweetbookmarksScalarFieldEnum
    having?: tweetbookmarksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetbookmarksCountAggregateInputType | true
    _min?: TweetbookmarksMinAggregateInputType
    _max?: TweetbookmarksMaxAggregateInputType
  }

  export type TweetbookmarksGroupByOutputType = {
    id: string
    userId: string
    tweetId: string
    _count: TweetbookmarksCountAggregateOutputType | null
    _min: TweetbookmarksMinAggregateOutputType | null
    _max: TweetbookmarksMaxAggregateOutputType | null
  }

  type GetTweetbookmarksGroupByPayload<T extends tweetbookmarksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetbookmarksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetbookmarksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetbookmarksGroupByOutputType[P]>
            : GetScalarType<T[P], TweetbookmarksGroupByOutputType[P]>
        }
      >
    >


  export type tweetbookmarksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetbookmarks"]>

  export type tweetbookmarksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetbookmarks"]>

  export type tweetbookmarksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetbookmarks"]>

  export type tweetbookmarksSelectScalar = {
    id?: boolean
    userId?: boolean
    tweetId?: boolean
  }

  export type tweetbookmarksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tweetId", ExtArgs["result"]["tweetbookmarks"]>
  export type tweetbookmarksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type tweetbookmarksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type tweetbookmarksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweetsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tweetbookmarksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tweetbookmarks"
    objects: {
      tweets: Prisma.$tweetsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tweetId: string
    }, ExtArgs["result"]["tweetbookmarks"]>
    composites: {}
  }

  type tweetbookmarksGetPayload<S extends boolean | null | undefined | tweetbookmarksDefaultArgs> = $Result.GetResult<Prisma.$tweetbookmarksPayload, S>

  type tweetbookmarksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tweetbookmarksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetbookmarksCountAggregateInputType | true
    }

  export interface tweetbookmarksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tweetbookmarks'], meta: { name: 'tweetbookmarks' } }
    /**
     * Find zero or one Tweetbookmarks that matches the filter.
     * @param {tweetbookmarksFindUniqueArgs} args - Arguments to find a Tweetbookmarks
     * @example
     * // Get one Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tweetbookmarksFindUniqueArgs>(args: SelectSubset<T, tweetbookmarksFindUniqueArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tweetbookmarks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tweetbookmarksFindUniqueOrThrowArgs} args - Arguments to find a Tweetbookmarks
     * @example
     * // Get one Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tweetbookmarksFindUniqueOrThrowArgs>(args: SelectSubset<T, tweetbookmarksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweetbookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksFindFirstArgs} args - Arguments to find a Tweetbookmarks
     * @example
     * // Get one Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tweetbookmarksFindFirstArgs>(args?: SelectSubset<T, tweetbookmarksFindFirstArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweetbookmarks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksFindFirstOrThrowArgs} args - Arguments to find a Tweetbookmarks
     * @example
     * // Get one Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tweetbookmarksFindFirstOrThrowArgs>(args?: SelectSubset<T, tweetbookmarksFindFirstOrThrowArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tweetbookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findMany()
     * 
     * // Get first 10 Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetbookmarksWithIdOnly = await prisma.tweetbookmarks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tweetbookmarksFindManyArgs>(args?: SelectSubset<T, tweetbookmarksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tweetbookmarks.
     * @param {tweetbookmarksCreateArgs} args - Arguments to create a Tweetbookmarks.
     * @example
     * // Create one Tweetbookmarks
     * const Tweetbookmarks = await prisma.tweetbookmarks.create({
     *   data: {
     *     // ... data to create a Tweetbookmarks
     *   }
     * })
     * 
     */
    create<T extends tweetbookmarksCreateArgs>(args: SelectSubset<T, tweetbookmarksCreateArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tweetbookmarks.
     * @param {tweetbookmarksCreateManyArgs} args - Arguments to create many Tweetbookmarks.
     * @example
     * // Create many Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tweetbookmarksCreateManyArgs>(args?: SelectSubset<T, tweetbookmarksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tweetbookmarks and returns the data saved in the database.
     * @param {tweetbookmarksCreateManyAndReturnArgs} args - Arguments to create many Tweetbookmarks.
     * @example
     * // Create many Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tweetbookmarks and only return the `id`
     * const tweetbookmarksWithIdOnly = await prisma.tweetbookmarks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tweetbookmarksCreateManyAndReturnArgs>(args?: SelectSubset<T, tweetbookmarksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tweetbookmarks.
     * @param {tweetbookmarksDeleteArgs} args - Arguments to delete one Tweetbookmarks.
     * @example
     * // Delete one Tweetbookmarks
     * const Tweetbookmarks = await prisma.tweetbookmarks.delete({
     *   where: {
     *     // ... filter to delete one Tweetbookmarks
     *   }
     * })
     * 
     */
    delete<T extends tweetbookmarksDeleteArgs>(args: SelectSubset<T, tweetbookmarksDeleteArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tweetbookmarks.
     * @param {tweetbookmarksUpdateArgs} args - Arguments to update one Tweetbookmarks.
     * @example
     * // Update one Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tweetbookmarksUpdateArgs>(args: SelectSubset<T, tweetbookmarksUpdateArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tweetbookmarks.
     * @param {tweetbookmarksDeleteManyArgs} args - Arguments to filter Tweetbookmarks to delete.
     * @example
     * // Delete a few Tweetbookmarks
     * const { count } = await prisma.tweetbookmarks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tweetbookmarksDeleteManyArgs>(args?: SelectSubset<T, tweetbookmarksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweetbookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tweetbookmarksUpdateManyArgs>(args: SelectSubset<T, tweetbookmarksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweetbookmarks and returns the data updated in the database.
     * @param {tweetbookmarksUpdateManyAndReturnArgs} args - Arguments to update many Tweetbookmarks.
     * @example
     * // Update many Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tweetbookmarks and only return the `id`
     * const tweetbookmarksWithIdOnly = await prisma.tweetbookmarks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tweetbookmarksUpdateManyAndReturnArgs>(args: SelectSubset<T, tweetbookmarksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tweetbookmarks.
     * @param {tweetbookmarksUpsertArgs} args - Arguments to update or create a Tweetbookmarks.
     * @example
     * // Update or create a Tweetbookmarks
     * const tweetbookmarks = await prisma.tweetbookmarks.upsert({
     *   create: {
     *     // ... data to create a Tweetbookmarks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweetbookmarks we want to update
     *   }
     * })
     */
    upsert<T extends tweetbookmarksUpsertArgs>(args: SelectSubset<T, tweetbookmarksUpsertArgs<ExtArgs>>): Prisma__tweetbookmarksClient<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tweetbookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksCountArgs} args - Arguments to filter Tweetbookmarks to count.
     * @example
     * // Count the number of Tweetbookmarks
     * const count = await prisma.tweetbookmarks.count({
     *   where: {
     *     // ... the filter for the Tweetbookmarks we want to count
     *   }
     * })
    **/
    count<T extends tweetbookmarksCountArgs>(
      args?: Subset<T, tweetbookmarksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetbookmarksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweetbookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetbookmarksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetbookmarksAggregateArgs>(args: Subset<T, TweetbookmarksAggregateArgs>): Prisma.PrismaPromise<GetTweetbookmarksAggregateType<T>>

    /**
     * Group by Tweetbookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetbookmarksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tweetbookmarksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tweetbookmarksGroupByArgs['orderBy'] }
        : { orderBy?: tweetbookmarksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tweetbookmarksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetbookmarksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tweetbookmarks model
   */
  readonly fields: tweetbookmarksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tweetbookmarks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tweetbookmarksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends tweetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tweetsDefaultArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tweetbookmarks model
   */
  interface tweetbookmarksFieldRefs {
    readonly id: FieldRef<"tweetbookmarks", 'String'>
    readonly userId: FieldRef<"tweetbookmarks", 'String'>
    readonly tweetId: FieldRef<"tweetbookmarks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tweetbookmarks findUnique
   */
  export type tweetbookmarksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter, which tweetbookmarks to fetch.
     */
    where: tweetbookmarksWhereUniqueInput
  }

  /**
   * tweetbookmarks findUniqueOrThrow
   */
  export type tweetbookmarksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter, which tweetbookmarks to fetch.
     */
    where: tweetbookmarksWhereUniqueInput
  }

  /**
   * tweetbookmarks findFirst
   */
  export type tweetbookmarksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter, which tweetbookmarks to fetch.
     */
    where?: tweetbookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetbookmarks to fetch.
     */
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweetbookmarks.
     */
    cursor?: tweetbookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetbookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetbookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweetbookmarks.
     */
    distinct?: TweetbookmarksScalarFieldEnum | TweetbookmarksScalarFieldEnum[]
  }

  /**
   * tweetbookmarks findFirstOrThrow
   */
  export type tweetbookmarksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter, which tweetbookmarks to fetch.
     */
    where?: tweetbookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetbookmarks to fetch.
     */
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweetbookmarks.
     */
    cursor?: tweetbookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetbookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetbookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweetbookmarks.
     */
    distinct?: TweetbookmarksScalarFieldEnum | TweetbookmarksScalarFieldEnum[]
  }

  /**
   * tweetbookmarks findMany
   */
  export type tweetbookmarksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter, which tweetbookmarks to fetch.
     */
    where?: tweetbookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweetbookmarks to fetch.
     */
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tweetbookmarks.
     */
    cursor?: tweetbookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweetbookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweetbookmarks.
     */
    skip?: number
    distinct?: TweetbookmarksScalarFieldEnum | TweetbookmarksScalarFieldEnum[]
  }

  /**
   * tweetbookmarks create
   */
  export type tweetbookmarksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * The data needed to create a tweetbookmarks.
     */
    data: XOR<tweetbookmarksCreateInput, tweetbookmarksUncheckedCreateInput>
  }

  /**
   * tweetbookmarks createMany
   */
  export type tweetbookmarksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tweetbookmarks.
     */
    data: tweetbookmarksCreateManyInput | tweetbookmarksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tweetbookmarks createManyAndReturn
   */
  export type tweetbookmarksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * The data used to create many tweetbookmarks.
     */
    data: tweetbookmarksCreateManyInput | tweetbookmarksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweetbookmarks update
   */
  export type tweetbookmarksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * The data needed to update a tweetbookmarks.
     */
    data: XOR<tweetbookmarksUpdateInput, tweetbookmarksUncheckedUpdateInput>
    /**
     * Choose, which tweetbookmarks to update.
     */
    where: tweetbookmarksWhereUniqueInput
  }

  /**
   * tweetbookmarks updateMany
   */
  export type tweetbookmarksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tweetbookmarks.
     */
    data: XOR<tweetbookmarksUpdateManyMutationInput, tweetbookmarksUncheckedUpdateManyInput>
    /**
     * Filter which tweetbookmarks to update
     */
    where?: tweetbookmarksWhereInput
    /**
     * Limit how many tweetbookmarks to update.
     */
    limit?: number
  }

  /**
   * tweetbookmarks updateManyAndReturn
   */
  export type tweetbookmarksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * The data used to update tweetbookmarks.
     */
    data: XOR<tweetbookmarksUpdateManyMutationInput, tweetbookmarksUncheckedUpdateManyInput>
    /**
     * Filter which tweetbookmarks to update
     */
    where?: tweetbookmarksWhereInput
    /**
     * Limit how many tweetbookmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweetbookmarks upsert
   */
  export type tweetbookmarksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * The filter to search for the tweetbookmarks to update in case it exists.
     */
    where: tweetbookmarksWhereUniqueInput
    /**
     * In case the tweetbookmarks found by the `where` argument doesn't exist, create a new tweetbookmarks with this data.
     */
    create: XOR<tweetbookmarksCreateInput, tweetbookmarksUncheckedCreateInput>
    /**
     * In case the tweetbookmarks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tweetbookmarksUpdateInput, tweetbookmarksUncheckedUpdateInput>
  }

  /**
   * tweetbookmarks delete
   */
  export type tweetbookmarksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    /**
     * Filter which tweetbookmarks to delete.
     */
    where: tweetbookmarksWhereUniqueInput
  }

  /**
   * tweetbookmarks deleteMany
   */
  export type tweetbookmarksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweetbookmarks to delete
     */
    where?: tweetbookmarksWhereInput
    /**
     * Limit how many tweetbookmarks to delete.
     */
    limit?: number
  }

  /**
   * tweetbookmarks without action
   */
  export type tweetbookmarksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
  }


  /**
   * Model tweets
   */

  export type AggregateTweets = {
    _count: TweetsCountAggregateOutputType | null
    _avg: TweetsAvgAggregateOutputType | null
    _sum: TweetsSumAggregateOutputType | null
    _min: TweetsMinAggregateOutputType | null
    _max: TweetsMaxAggregateOutputType | null
  }

  export type TweetsAvgAggregateOutputType = {
    likesCount: number | null
    retweetCount: number | null
    repliesCount: number | null
  }

  export type TweetsSumAggregateOutputType = {
    likesCount: number | null
    retweetCount: number | null
    repliesCount: number | null
  }

  export type TweetsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    likesCount: number | null
    retweetCount: number | null
    repliesCount: number | null
    parentId: string | null
    tweetType: $Enums.TweetType | null
    replyControl: $Enums.ReplyControl | null
  }

  export type TweetsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    likesCount: number | null
    retweetCount: number | null
    repliesCount: number | null
    parentId: string | null
    tweetType: $Enums.TweetType | null
    replyControl: $Enums.ReplyControl | null
  }

  export type TweetsCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    createdAt: number
    likesCount: number
    retweetCount: number
    repliesCount: number
    parentId: number
    tweetType: number
    replyControl: number
    _all: number
  }


  export type TweetsAvgAggregateInputType = {
    likesCount?: true
    retweetCount?: true
    repliesCount?: true
  }

  export type TweetsSumAggregateInputType = {
    likesCount?: true
    retweetCount?: true
    repliesCount?: true
  }

  export type TweetsMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    likesCount?: true
    retweetCount?: true
    repliesCount?: true
    parentId?: true
    tweetType?: true
    replyControl?: true
  }

  export type TweetsMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    likesCount?: true
    retweetCount?: true
    repliesCount?: true
    parentId?: true
    tweetType?: true
    replyControl?: true
  }

  export type TweetsCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    likesCount?: true
    retweetCount?: true
    repliesCount?: true
    parentId?: true
    tweetType?: true
    replyControl?: true
    _all?: true
  }

  export type TweetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweets to aggregate.
     */
    where?: tweetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweets to fetch.
     */
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tweetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tweets
    **/
    _count?: true | TweetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TweetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TweetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetsMaxAggregateInputType
  }

  export type GetTweetsAggregateType<T extends TweetsAggregateArgs> = {
        [P in keyof T & keyof AggregateTweets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweets[P]>
      : GetScalarType<T[P], AggregateTweets[P]>
  }




  export type tweetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tweetsWhereInput
    orderBy?: tweetsOrderByWithAggregationInput | tweetsOrderByWithAggregationInput[]
    by: TweetsScalarFieldEnum[] | TweetsScalarFieldEnum
    having?: tweetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetsCountAggregateInputType | true
    _avg?: TweetsAvgAggregateInputType
    _sum?: TweetsSumAggregateInputType
    _min?: TweetsMinAggregateInputType
    _max?: TweetsMaxAggregateInputType
  }

  export type TweetsGroupByOutputType = {
    id: string
    userId: string
    content: string
    createdAt: Date
    likesCount: number
    retweetCount: number
    repliesCount: number
    parentId: string | null
    tweetType: $Enums.TweetType
    replyControl: $Enums.ReplyControl
    _count: TweetsCountAggregateOutputType | null
    _avg: TweetsAvgAggregateOutputType | null
    _sum: TweetsSumAggregateOutputType | null
    _min: TweetsMinAggregateOutputType | null
    _max: TweetsMaxAggregateOutputType | null
  }

  type GetTweetsGroupByPayload<T extends tweetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetsGroupByOutputType[P]>
            : GetScalarType<T[P], TweetsGroupByOutputType[P]>
        }
      >
    >


  export type tweetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    likesCount?: boolean
    retweetCount?: boolean
    repliesCount?: boolean
    parentId?: boolean
    tweetType?: boolean
    replyControl?: boolean
    Mention?: boolean | tweets$MentionArgs<ExtArgs>
    Retweet?: boolean | tweets$RetweetArgs<ExtArgs>
    TweetLike?: boolean | tweets$TweetLikeArgs<ExtArgs>
    TweetMedia?: boolean | tweets$TweetMediaArgs<ExtArgs>
    TweetSummary?: boolean | tweets$TweetSummaryArgs<ExtArgs>
    notifications?: boolean | tweets$notificationsArgs<ExtArgs>
    tweetHashes?: boolean | tweets$tweetHashesArgs<ExtArgs>
    tweetbookmarks?: boolean | tweets$tweetbookmarksArgs<ExtArgs>
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    other_tweets?: boolean | tweets$other_tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TweetsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweets"]>

  export type tweetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    likesCount?: boolean
    retweetCount?: boolean
    repliesCount?: boolean
    parentId?: boolean
    tweetType?: boolean
    replyControl?: boolean
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweets"]>

  export type tweetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    likesCount?: boolean
    retweetCount?: boolean
    repliesCount?: boolean
    parentId?: boolean
    tweetType?: boolean
    replyControl?: boolean
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweets"]>

  export type tweetsSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    likesCount?: boolean
    retweetCount?: boolean
    repliesCount?: boolean
    parentId?: boolean
    tweetType?: boolean
    replyControl?: boolean
  }

  export type tweetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "createdAt" | "likesCount" | "retweetCount" | "repliesCount" | "parentId" | "tweetType" | "replyControl", ExtArgs["result"]["tweets"]>
  export type tweetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mention?: boolean | tweets$MentionArgs<ExtArgs>
    Retweet?: boolean | tweets$RetweetArgs<ExtArgs>
    TweetLike?: boolean | tweets$TweetLikeArgs<ExtArgs>
    TweetMedia?: boolean | tweets$TweetMediaArgs<ExtArgs>
    TweetSummary?: boolean | tweets$TweetSummaryArgs<ExtArgs>
    notifications?: boolean | tweets$notificationsArgs<ExtArgs>
    tweetHashes?: boolean | tweets$tweetHashesArgs<ExtArgs>
    tweetbookmarks?: boolean | tweets$tweetbookmarksArgs<ExtArgs>
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    other_tweets?: boolean | tweets$other_tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TweetsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tweetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type tweetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | tweets$tweetsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $tweetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tweets"
    objects: {
      Mention: Prisma.$MentionPayload<ExtArgs>[]
      Retweet: Prisma.$RetweetPayload<ExtArgs>[]
      TweetLike: Prisma.$TweetLikePayload<ExtArgs>[]
      TweetMedia: Prisma.$TweetMediaPayload<ExtArgs>[]
      TweetSummary: Prisma.$TweetSummaryPayload<ExtArgs> | null
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      tweetHashes: Prisma.$tweetHashesPayload<ExtArgs>[]
      tweetbookmarks: Prisma.$tweetbookmarksPayload<ExtArgs>[]
      tweets: Prisma.$tweetsPayload<ExtArgs> | null
      other_tweets: Prisma.$tweetsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      createdAt: Date
      likesCount: number
      retweetCount: number
      repliesCount: number
      parentId: string | null
      tweetType: $Enums.TweetType
      replyControl: $Enums.ReplyControl
    }, ExtArgs["result"]["tweets"]>
    composites: {}
  }

  type tweetsGetPayload<S extends boolean | null | undefined | tweetsDefaultArgs> = $Result.GetResult<Prisma.$tweetsPayload, S>

  type tweetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tweetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetsCountAggregateInputType | true
    }

  export interface tweetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tweets'], meta: { name: 'tweets' } }
    /**
     * Find zero or one Tweets that matches the filter.
     * @param {tweetsFindUniqueArgs} args - Arguments to find a Tweets
     * @example
     * // Get one Tweets
     * const tweets = await prisma.tweets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tweetsFindUniqueArgs>(args: SelectSubset<T, tweetsFindUniqueArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tweets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tweetsFindUniqueOrThrowArgs} args - Arguments to find a Tweets
     * @example
     * // Get one Tweets
     * const tweets = await prisma.tweets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tweetsFindUniqueOrThrowArgs>(args: SelectSubset<T, tweetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsFindFirstArgs} args - Arguments to find a Tweets
     * @example
     * // Get one Tweets
     * const tweets = await prisma.tweets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tweetsFindFirstArgs>(args?: SelectSubset<T, tweetsFindFirstArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsFindFirstOrThrowArgs} args - Arguments to find a Tweets
     * @example
     * // Get one Tweets
     * const tweets = await prisma.tweets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tweetsFindFirstOrThrowArgs>(args?: SelectSubset<T, tweetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweets
     * const tweets = await prisma.tweets.findMany()
     * 
     * // Get first 10 Tweets
     * const tweets = await prisma.tweets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetsWithIdOnly = await prisma.tweets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tweetsFindManyArgs>(args?: SelectSubset<T, tweetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tweets.
     * @param {tweetsCreateArgs} args - Arguments to create a Tweets.
     * @example
     * // Create one Tweets
     * const Tweets = await prisma.tweets.create({
     *   data: {
     *     // ... data to create a Tweets
     *   }
     * })
     * 
     */
    create<T extends tweetsCreateArgs>(args: SelectSubset<T, tweetsCreateArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tweets.
     * @param {tweetsCreateManyArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweets = await prisma.tweets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tweetsCreateManyArgs>(args?: SelectSubset<T, tweetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tweets and returns the data saved in the database.
     * @param {tweetsCreateManyAndReturnArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweets = await prisma.tweets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tweets and only return the `id`
     * const tweetsWithIdOnly = await prisma.tweets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tweetsCreateManyAndReturnArgs>(args?: SelectSubset<T, tweetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tweets.
     * @param {tweetsDeleteArgs} args - Arguments to delete one Tweets.
     * @example
     * // Delete one Tweets
     * const Tweets = await prisma.tweets.delete({
     *   where: {
     *     // ... filter to delete one Tweets
     *   }
     * })
     * 
     */
    delete<T extends tweetsDeleteArgs>(args: SelectSubset<T, tweetsDeleteArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tweets.
     * @param {tweetsUpdateArgs} args - Arguments to update one Tweets.
     * @example
     * // Update one Tweets
     * const tweets = await prisma.tweets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tweetsUpdateArgs>(args: SelectSubset<T, tweetsUpdateArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tweets.
     * @param {tweetsDeleteManyArgs} args - Arguments to filter Tweets to delete.
     * @example
     * // Delete a few Tweets
     * const { count } = await prisma.tweets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tweetsDeleteManyArgs>(args?: SelectSubset<T, tweetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweets
     * const tweets = await prisma.tweets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tweetsUpdateManyArgs>(args: SelectSubset<T, tweetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets and returns the data updated in the database.
     * @param {tweetsUpdateManyAndReturnArgs} args - Arguments to update many Tweets.
     * @example
     * // Update many Tweets
     * const tweets = await prisma.tweets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tweets and only return the `id`
     * const tweetsWithIdOnly = await prisma.tweets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tweetsUpdateManyAndReturnArgs>(args: SelectSubset<T, tweetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tweets.
     * @param {tweetsUpsertArgs} args - Arguments to update or create a Tweets.
     * @example
     * // Update or create a Tweets
     * const tweets = await prisma.tweets.upsert({
     *   create: {
     *     // ... data to create a Tweets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweets we want to update
     *   }
     * })
     */
    upsert<T extends tweetsUpsertArgs>(args: SelectSubset<T, tweetsUpsertArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsCountArgs} args - Arguments to filter Tweets to count.
     * @example
     * // Count the number of Tweets
     * const count = await prisma.tweets.count({
     *   where: {
     *     // ... the filter for the Tweets we want to count
     *   }
     * })
    **/
    count<T extends tweetsCountArgs>(
      args?: Subset<T, tweetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetsAggregateArgs>(args: Subset<T, TweetsAggregateArgs>): Prisma.PrismaPromise<GetTweetsAggregateType<T>>

    /**
     * Group by Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tweetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tweetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tweetsGroupByArgs['orderBy'] }
        : { orderBy?: tweetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tweetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tweets model
   */
  readonly fields: tweetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tweets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tweetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Mention<T extends tweets$MentionArgs<ExtArgs> = {}>(args?: Subset<T, tweets$MentionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Retweet<T extends tweets$RetweetArgs<ExtArgs> = {}>(args?: Subset<T, tweets$RetweetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TweetLike<T extends tweets$TweetLikeArgs<ExtArgs> = {}>(args?: Subset<T, tweets$TweetLikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TweetMedia<T extends tweets$TweetMediaArgs<ExtArgs> = {}>(args?: Subset<T, tweets$TweetMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TweetSummary<T extends tweets$TweetSummaryArgs<ExtArgs> = {}>(args?: Subset<T, tweets$TweetSummaryArgs<ExtArgs>>): Prisma__TweetSummaryClient<$Result.GetResult<Prisma.$TweetSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends tweets$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, tweets$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweetHashes<T extends tweets$tweetHashesArgs<ExtArgs> = {}>(args?: Subset<T, tweets$tweetHashesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetHashesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweetbookmarks<T extends tweets$tweetbookmarksArgs<ExtArgs> = {}>(args?: Subset<T, tweets$tweetbookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweets<T extends tweets$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, tweets$tweetsArgs<ExtArgs>>): Prisma__tweetsClient<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_tweets<T extends tweets$other_tweetsArgs<ExtArgs> = {}>(args?: Subset<T, tweets$other_tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tweets model
   */
  interface tweetsFieldRefs {
    readonly id: FieldRef<"tweets", 'String'>
    readonly userId: FieldRef<"tweets", 'String'>
    readonly content: FieldRef<"tweets", 'String'>
    readonly createdAt: FieldRef<"tweets", 'DateTime'>
    readonly likesCount: FieldRef<"tweets", 'Int'>
    readonly retweetCount: FieldRef<"tweets", 'Int'>
    readonly repliesCount: FieldRef<"tweets", 'Int'>
    readonly parentId: FieldRef<"tweets", 'String'>
    readonly tweetType: FieldRef<"tweets", 'TweetType'>
    readonly replyControl: FieldRef<"tweets", 'ReplyControl'>
  }
    

  // Custom InputTypes
  /**
   * tweets findUnique
   */
  export type tweetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter, which tweets to fetch.
     */
    where: tweetsWhereUniqueInput
  }

  /**
   * tweets findUniqueOrThrow
   */
  export type tweetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter, which tweets to fetch.
     */
    where: tweetsWhereUniqueInput
  }

  /**
   * tweets findFirst
   */
  export type tweetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter, which tweets to fetch.
     */
    where?: tweetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweets to fetch.
     */
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweets.
     */
    cursor?: tweetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweets.
     */
    distinct?: TweetsScalarFieldEnum | TweetsScalarFieldEnum[]
  }

  /**
   * tweets findFirstOrThrow
   */
  export type tweetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter, which tweets to fetch.
     */
    where?: tweetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweets to fetch.
     */
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tweets.
     */
    cursor?: tweetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tweets.
     */
    distinct?: TweetsScalarFieldEnum | TweetsScalarFieldEnum[]
  }

  /**
   * tweets findMany
   */
  export type tweetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter, which tweets to fetch.
     */
    where?: tweetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tweets to fetch.
     */
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tweets.
     */
    cursor?: tweetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tweets.
     */
    skip?: number
    distinct?: TweetsScalarFieldEnum | TweetsScalarFieldEnum[]
  }

  /**
   * tweets create
   */
  export type tweetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * The data needed to create a tweets.
     */
    data: XOR<tweetsCreateInput, tweetsUncheckedCreateInput>
  }

  /**
   * tweets createMany
   */
  export type tweetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tweets.
     */
    data: tweetsCreateManyInput | tweetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tweets createManyAndReturn
   */
  export type tweetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * The data used to create many tweets.
     */
    data: tweetsCreateManyInput | tweetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweets update
   */
  export type tweetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * The data needed to update a tweets.
     */
    data: XOR<tweetsUpdateInput, tweetsUncheckedUpdateInput>
    /**
     * Choose, which tweets to update.
     */
    where: tweetsWhereUniqueInput
  }

  /**
   * tweets updateMany
   */
  export type tweetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tweets.
     */
    data: XOR<tweetsUpdateManyMutationInput, tweetsUncheckedUpdateManyInput>
    /**
     * Filter which tweets to update
     */
    where?: tweetsWhereInput
    /**
     * Limit how many tweets to update.
     */
    limit?: number
  }

  /**
   * tweets updateManyAndReturn
   */
  export type tweetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * The data used to update tweets.
     */
    data: XOR<tweetsUpdateManyMutationInput, tweetsUncheckedUpdateManyInput>
    /**
     * Filter which tweets to update
     */
    where?: tweetsWhereInput
    /**
     * Limit how many tweets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tweets upsert
   */
  export type tweetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * The filter to search for the tweets to update in case it exists.
     */
    where: tweetsWhereUniqueInput
    /**
     * In case the tweets found by the `where` argument doesn't exist, create a new tweets with this data.
     */
    create: XOR<tweetsCreateInput, tweetsUncheckedCreateInput>
    /**
     * In case the tweets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tweetsUpdateInput, tweetsUncheckedUpdateInput>
  }

  /**
   * tweets delete
   */
  export type tweetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    /**
     * Filter which tweets to delete.
     */
    where: tweetsWhereUniqueInput
  }

  /**
   * tweets deleteMany
   */
  export type tweetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tweets to delete
     */
    where?: tweetsWhereInput
    /**
     * Limit how many tweets to delete.
     */
    limit?: number
  }

  /**
   * tweets.Mention
   */
  export type tweets$MentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * tweets.Retweet
   */
  export type tweets$RetweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    where?: RetweetWhereInput
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    cursor?: RetweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RetweetScalarFieldEnum | RetweetScalarFieldEnum[]
  }

  /**
   * tweets.TweetLike
   */
  export type tweets$TweetLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    where?: TweetLikeWhereInput
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    cursor?: TweetLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetLikeScalarFieldEnum | TweetLikeScalarFieldEnum[]
  }

  /**
   * tweets.TweetMedia
   */
  export type tweets$TweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    where?: TweetMediaWhereInput
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    cursor?: TweetMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * tweets.TweetSummary
   */
  export type tweets$TweetSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetSummary
     */
    select?: TweetSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetSummary
     */
    omit?: TweetSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetSummaryInclude<ExtArgs> | null
    where?: TweetSummaryWhereInput
  }

  /**
   * tweets.notifications
   */
  export type tweets$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * tweets.tweetHashes
   */
  export type tweets$tweetHashesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetHashes
     */
    select?: tweetHashesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetHashes
     */
    omit?: tweetHashesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetHashesInclude<ExtArgs> | null
    where?: tweetHashesWhereInput
    orderBy?: tweetHashesOrderByWithRelationInput | tweetHashesOrderByWithRelationInput[]
    cursor?: tweetHashesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetHashesScalarFieldEnum | TweetHashesScalarFieldEnum[]
  }

  /**
   * tweets.tweetbookmarks
   */
  export type tweets$tweetbookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    where?: tweetbookmarksWhereInput
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    cursor?: tweetbookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetbookmarksScalarFieldEnum | TweetbookmarksScalarFieldEnum[]
  }

  /**
   * tweets.tweets
   */
  export type tweets$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    where?: tweetsWhereInput
  }

  /**
   * tweets.other_tweets
   */
  export type tweets$other_tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    where?: tweetsWhereInput
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    cursor?: tweetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetsScalarFieldEnum | TweetsScalarFieldEnum[]
  }

  /**
   * tweets without action
   */
  export type tweetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    otp: number | null
  }

  export type UsersSumAggregateOutputType = {
    otp: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    is_email_verified: boolean | null
    password: string | null
    saltPassword: string | null
    otp: number | null
    otpExpiry: Date | null
    tfa_verifed: boolean | null
    bio: string | null
    dateOfBirth: Date | null
    joinDate: Date | null
    verified: boolean | null
    address: string | null
    website: string | null
    protectedAccount: boolean | null
    profilePhoto: string | null
    cover: string | null
    provider: string | null
    login_codes: string | null
    login_codes_set: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    is_email_verified: boolean | null
    password: string | null
    saltPassword: string | null
    otp: number | null
    otpExpiry: Date | null
    tfa_verifed: boolean | null
    bio: string | null
    dateOfBirth: Date | null
    joinDate: Date | null
    verified: boolean | null
    address: string | null
    website: string | null
    protectedAccount: boolean | null
    profilePhoto: string | null
    cover: string | null
    provider: string | null
    login_codes: string | null
    login_codes_set: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    username: number
    email: number
    is_email_verified: number
    password: number
    saltPassword: number
    otp: number
    otpExpiry: number
    tfa_verifed: number
    bio: number
    dateOfBirth: number
    joinDate: number
    verified: number
    address: number
    website: number
    protectedAccount: number
    profilePhoto: number
    cover: number
    provider: number
    login_codes: number
    login_codes_set: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    otp?: true
  }

  export type UsersSumAggregateInputType = {
    otp?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    is_email_verified?: true
    password?: true
    saltPassword?: true
    otp?: true
    otpExpiry?: true
    tfa_verifed?: true
    bio?: true
    dateOfBirth?: true
    joinDate?: true
    verified?: true
    address?: true
    website?: true
    protectedAccount?: true
    profilePhoto?: true
    cover?: true
    provider?: true
    login_codes?: true
    login_codes_set?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    is_email_verified?: true
    password?: true
    saltPassword?: true
    otp?: true
    otpExpiry?: true
    tfa_verifed?: true
    bio?: true
    dateOfBirth?: true
    joinDate?: true
    verified?: true
    address?: true
    website?: true
    protectedAccount?: true
    profilePhoto?: true
    cover?: true
    provider?: true
    login_codes?: true
    login_codes_set?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    is_email_verified?: true
    password?: true
    saltPassword?: true
    otp?: true
    otpExpiry?: true
    tfa_verifed?: true
    bio?: true
    dateOfBirth?: true
    joinDate?: true
    verified?: true
    address?: true
    website?: true
    protectedAccount?: true
    profilePhoto?: true
    cover?: true
    provider?: true
    login_codes?: true
    login_codes_set?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string | null
    username: string
    email: string
    is_email_verified: boolean
    password: string
    saltPassword: string
    otp: number | null
    otpExpiry: Date | null
    tfa_verifed: boolean
    bio: string | null
    dateOfBirth: Date
    joinDate: Date
    verified: boolean
    address: string | null
    website: string | null
    protectedAccount: boolean
    profilePhoto: string | null
    cover: string | null
    provider: string | null
    login_codes: string | null
    login_codes_set: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    is_email_verified?: boolean
    password?: boolean
    saltPassword?: boolean
    otp?: boolean
    otpExpiry?: boolean
    tfa_verifed?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    joinDate?: boolean
    verified?: boolean
    address?: boolean
    website?: boolean
    protectedAccount?: boolean
    profilePhoto?: boolean
    cover?: boolean
    provider?: boolean
    login_codes?: boolean
    login_codes_set?: boolean
    device_record?: boolean | users$device_recordArgs<ExtArgs>
    old_passwords?: boolean | users$old_passwordsArgs<ExtArgs>
    Block_Block_blockedIdTousers?: boolean | users$Block_Block_blockedIdTousersArgs<ExtArgs>
    Block_Block_blockerIdTousers?: boolean | users$Block_Block_blockerIdTousersArgs<ExtArgs>
    Follow_Follow_followerIdTousers?: boolean | users$Follow_Follow_followerIdTousersArgs<ExtArgs>
    Follow_Follow_followingIdTousers?: boolean | users$Follow_Follow_followingIdTousersArgs<ExtArgs>
    Mention_Mention_mentionedIdTousers?: boolean | users$Mention_Mention_mentionedIdTousersArgs<ExtArgs>
    Mention_Mention_mentionerIdTousers?: boolean | users$Mention_Mention_mentionerIdTousersArgs<ExtArgs>
    Mute_Mute_mutedIdTousers?: boolean | users$Mute_Mute_mutedIdTousersArgs<ExtArgs>
    Mute_Mute_muterIdTousers?: boolean | users$Mute_Mute_muterIdTousersArgs<ExtArgs>
    Retweet?: boolean | users$RetweetArgs<ExtArgs>
    TweetLike?: boolean | users$TweetLikeArgs<ExtArgs>
    chatusers?: boolean | users$chatusersArgs<ExtArgs>
    messages?: boolean | users$messagesArgs<ExtArgs>
    notifications_notifications_actorIdTousers?: boolean | users$notifications_notifications_actorIdTousersArgs<ExtArgs>
    notifications_notifications_userIdTousers?: boolean | users$notifications_notifications_userIdTousersArgs<ExtArgs>
    tweetbookmarks?: boolean | users$tweetbookmarksArgs<ExtArgs>
    tweets?: boolean | users$tweetsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    is_email_verified?: boolean
    password?: boolean
    saltPassword?: boolean
    otp?: boolean
    otpExpiry?: boolean
    tfa_verifed?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    joinDate?: boolean
    verified?: boolean
    address?: boolean
    website?: boolean
    protectedAccount?: boolean
    profilePhoto?: boolean
    cover?: boolean
    provider?: boolean
    login_codes?: boolean
    login_codes_set?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    is_email_verified?: boolean
    password?: boolean
    saltPassword?: boolean
    otp?: boolean
    otpExpiry?: boolean
    tfa_verifed?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    joinDate?: boolean
    verified?: boolean
    address?: boolean
    website?: boolean
    protectedAccount?: boolean
    profilePhoto?: boolean
    cover?: boolean
    provider?: boolean
    login_codes?: boolean
    login_codes_set?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    is_email_verified?: boolean
    password?: boolean
    saltPassword?: boolean
    otp?: boolean
    otpExpiry?: boolean
    tfa_verifed?: boolean
    bio?: boolean
    dateOfBirth?: boolean
    joinDate?: boolean
    verified?: boolean
    address?: boolean
    website?: boolean
    protectedAccount?: boolean
    profilePhoto?: boolean
    cover?: boolean
    provider?: boolean
    login_codes?: boolean
    login_codes_set?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "email" | "is_email_verified" | "password" | "saltPassword" | "otp" | "otpExpiry" | "tfa_verifed" | "bio" | "dateOfBirth" | "joinDate" | "verified" | "address" | "website" | "protectedAccount" | "profilePhoto" | "cover" | "provider" | "login_codes" | "login_codes_set", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device_record?: boolean | users$device_recordArgs<ExtArgs>
    old_passwords?: boolean | users$old_passwordsArgs<ExtArgs>
    Block_Block_blockedIdTousers?: boolean | users$Block_Block_blockedIdTousersArgs<ExtArgs>
    Block_Block_blockerIdTousers?: boolean | users$Block_Block_blockerIdTousersArgs<ExtArgs>
    Follow_Follow_followerIdTousers?: boolean | users$Follow_Follow_followerIdTousersArgs<ExtArgs>
    Follow_Follow_followingIdTousers?: boolean | users$Follow_Follow_followingIdTousersArgs<ExtArgs>
    Mention_Mention_mentionedIdTousers?: boolean | users$Mention_Mention_mentionedIdTousersArgs<ExtArgs>
    Mention_Mention_mentionerIdTousers?: boolean | users$Mention_Mention_mentionerIdTousersArgs<ExtArgs>
    Mute_Mute_mutedIdTousers?: boolean | users$Mute_Mute_mutedIdTousersArgs<ExtArgs>
    Mute_Mute_muterIdTousers?: boolean | users$Mute_Mute_muterIdTousersArgs<ExtArgs>
    Retweet?: boolean | users$RetweetArgs<ExtArgs>
    TweetLike?: boolean | users$TweetLikeArgs<ExtArgs>
    chatusers?: boolean | users$chatusersArgs<ExtArgs>
    messages?: boolean | users$messagesArgs<ExtArgs>
    notifications_notifications_actorIdTousers?: boolean | users$notifications_notifications_actorIdTousersArgs<ExtArgs>
    notifications_notifications_userIdTousers?: boolean | users$notifications_notifications_userIdTousersArgs<ExtArgs>
    tweetbookmarks?: boolean | users$tweetbookmarksArgs<ExtArgs>
    tweets?: boolean | users$tweetsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      device_record: Prisma.$DeviceRecordPayload<ExtArgs>[]
      old_passwords: Prisma.$OldPasswordPayload<ExtArgs>[]
      Block_Block_blockedIdTousers: Prisma.$BlockPayload<ExtArgs>[]
      Block_Block_blockerIdTousers: Prisma.$BlockPayload<ExtArgs>[]
      Follow_Follow_followerIdTousers: Prisma.$FollowPayload<ExtArgs>[]
      Follow_Follow_followingIdTousers: Prisma.$FollowPayload<ExtArgs>[]
      Mention_Mention_mentionedIdTousers: Prisma.$MentionPayload<ExtArgs>[]
      Mention_Mention_mentionerIdTousers: Prisma.$MentionPayload<ExtArgs>[]
      Mute_Mute_mutedIdTousers: Prisma.$MutePayload<ExtArgs>[]
      Mute_Mute_muterIdTousers: Prisma.$MutePayload<ExtArgs>[]
      Retweet: Prisma.$RetweetPayload<ExtArgs>[]
      TweetLike: Prisma.$TweetLikePayload<ExtArgs>[]
      chatusers: Prisma.$chatusersPayload<ExtArgs>[]
      messages: Prisma.$messagesPayload<ExtArgs>[]
      notifications_notifications_actorIdTousers: Prisma.$notificationsPayload<ExtArgs>[]
      notifications_notifications_userIdTousers: Prisma.$notificationsPayload<ExtArgs>[]
      tweetbookmarks: Prisma.$tweetbookmarksPayload<ExtArgs>[]
      tweets: Prisma.$tweetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      username: string
      email: string
      is_email_verified: boolean
      password: string
      saltPassword: string
      otp: number | null
      otpExpiry: Date | null
      tfa_verifed: boolean
      bio: string | null
      dateOfBirth: Date
      joinDate: Date
      verified: boolean
      address: string | null
      website: string | null
      protectedAccount: boolean
      profilePhoto: string | null
      cover: string | null
      provider: string | null
      login_codes: string | null
      login_codes_set: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device_record<T extends users$device_recordArgs<ExtArgs> = {}>(args?: Subset<T, users$device_recordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    old_passwords<T extends users$old_passwordsArgs<ExtArgs> = {}>(args?: Subset<T, users$old_passwordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Block_Block_blockedIdTousers<T extends users$Block_Block_blockedIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Block_Block_blockedIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Block_Block_blockerIdTousers<T extends users$Block_Block_blockerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Block_Block_blockerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Follow_Follow_followerIdTousers<T extends users$Follow_Follow_followerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Follow_Follow_followerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Follow_Follow_followingIdTousers<T extends users$Follow_Follow_followingIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Follow_Follow_followingIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Mention_Mention_mentionedIdTousers<T extends users$Mention_Mention_mentionedIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Mention_Mention_mentionedIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Mention_Mention_mentionerIdTousers<T extends users$Mention_Mention_mentionerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Mention_Mention_mentionerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Mute_Mute_mutedIdTousers<T extends users$Mute_Mute_mutedIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Mute_Mute_mutedIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Mute_Mute_muterIdTousers<T extends users$Mute_Mute_muterIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$Mute_Mute_muterIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Retweet<T extends users$RetweetArgs<ExtArgs> = {}>(args?: Subset<T, users$RetweetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TweetLike<T extends users$TweetLikeArgs<ExtArgs> = {}>(args?: Subset<T, users$TweetLikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatusers<T extends users$chatusersArgs<ExtArgs> = {}>(args?: Subset<T, users$chatusersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatusersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends users$messagesArgs<ExtArgs> = {}>(args?: Subset<T, users$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications_notifications_actorIdTousers<T extends users$notifications_notifications_actorIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$notifications_notifications_actorIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications_notifications_userIdTousers<T extends users$notifications_notifications_userIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$notifications_notifications_userIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweetbookmarks<T extends users$tweetbookmarksArgs<ExtArgs> = {}>(args?: Subset<T, users$tweetbookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetbookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweets<T extends users$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, users$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tweetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly is_email_verified: FieldRef<"users", 'Boolean'>
    readonly password: FieldRef<"users", 'String'>
    readonly saltPassword: FieldRef<"users", 'String'>
    readonly otp: FieldRef<"users", 'Int'>
    readonly otpExpiry: FieldRef<"users", 'DateTime'>
    readonly tfa_verifed: FieldRef<"users", 'Boolean'>
    readonly bio: FieldRef<"users", 'String'>
    readonly dateOfBirth: FieldRef<"users", 'DateTime'>
    readonly joinDate: FieldRef<"users", 'DateTime'>
    readonly verified: FieldRef<"users", 'Boolean'>
    readonly address: FieldRef<"users", 'String'>
    readonly website: FieldRef<"users", 'String'>
    readonly protectedAccount: FieldRef<"users", 'Boolean'>
    readonly profilePhoto: FieldRef<"users", 'String'>
    readonly cover: FieldRef<"users", 'String'>
    readonly provider: FieldRef<"users", 'String'>
    readonly login_codes: FieldRef<"users", 'String'>
    readonly login_codes_set: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.device_record
   */
  export type users$device_recordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    where?: DeviceRecordWhereInput
    orderBy?: DeviceRecordOrderByWithRelationInput | DeviceRecordOrderByWithRelationInput[]
    cursor?: DeviceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceRecordScalarFieldEnum | DeviceRecordScalarFieldEnum[]
  }

  /**
   * users.old_passwords
   */
  export type users$old_passwordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    where?: OldPasswordWhereInput
    orderBy?: OldPasswordOrderByWithRelationInput | OldPasswordOrderByWithRelationInput[]
    cursor?: OldPasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OldPasswordScalarFieldEnum | OldPasswordScalarFieldEnum[]
  }

  /**
   * users.Block_Block_blockedIdTousers
   */
  export type users$Block_Block_blockedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * users.Block_Block_blockerIdTousers
   */
  export type users$Block_Block_blockerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * users.Follow_Follow_followerIdTousers
   */
  export type users$Follow_Follow_followerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * users.Follow_Follow_followingIdTousers
   */
  export type users$Follow_Follow_followingIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * users.Mention_Mention_mentionedIdTousers
   */
  export type users$Mention_Mention_mentionedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * users.Mention_Mention_mentionerIdTousers
   */
  export type users$Mention_Mention_mentionerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mention
     */
    omit?: MentionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * users.Mute_Mute_mutedIdTousers
   */
  export type users$Mute_Mute_mutedIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * users.Mute_Mute_muterIdTousers
   */
  export type users$Mute_Mute_muterIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * users.Retweet
   */
  export type users$RetweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retweet
     */
    select?: RetweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retweet
     */
    omit?: RetweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetweetInclude<ExtArgs> | null
    where?: RetweetWhereInput
    orderBy?: RetweetOrderByWithRelationInput | RetweetOrderByWithRelationInput[]
    cursor?: RetweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RetweetScalarFieldEnum | RetweetScalarFieldEnum[]
  }

  /**
   * users.TweetLike
   */
  export type users$TweetLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetLike
     */
    select?: TweetLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetLike
     */
    omit?: TweetLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetLikeInclude<ExtArgs> | null
    where?: TweetLikeWhereInput
    orderBy?: TweetLikeOrderByWithRelationInput | TweetLikeOrderByWithRelationInput[]
    cursor?: TweetLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetLikeScalarFieldEnum | TweetLikeScalarFieldEnum[]
  }

  /**
   * users.chatusers
   */
  export type users$chatusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatusers
     */
    select?: chatusersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatusers
     */
    omit?: chatusersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatusersInclude<ExtArgs> | null
    where?: chatusersWhereInput
    orderBy?: chatusersOrderByWithRelationInput | chatusersOrderByWithRelationInput[]
    cursor?: chatusersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatusersScalarFieldEnum | ChatusersScalarFieldEnum[]
  }

  /**
   * users.messages
   */
  export type users$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.notifications_notifications_actorIdTousers
   */
  export type users$notifications_notifications_actorIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.notifications_notifications_userIdTousers
   */
  export type users$notifications_notifications_userIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.tweetbookmarks
   */
  export type users$tweetbookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweetbookmarks
     */
    select?: tweetbookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweetbookmarks
     */
    omit?: tweetbookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetbookmarksInclude<ExtArgs> | null
    where?: tweetbookmarksWhereInput
    orderBy?: tweetbookmarksOrderByWithRelationInput | tweetbookmarksOrderByWithRelationInput[]
    cursor?: tweetbookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetbookmarksScalarFieldEnum | TweetbookmarksScalarFieldEnum[]
  }

  /**
   * users.tweets
   */
  export type users$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tweets
     */
    select?: tweetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tweets
     */
    omit?: tweetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tweetsInclude<ExtArgs> | null
    where?: tweetsWhereInput
    orderBy?: tweetsOrderByWithRelationInput | tweetsOrderByWithRelationInput[]
    cursor?: tweetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetsScalarFieldEnum | TweetsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model DeviceRecord
   */

  export type AggregateDeviceRecord = {
    _count: DeviceRecordCountAggregateOutputType | null
    _avg: DeviceRecordAvgAggregateOutputType | null
    _sum: DeviceRecordSumAggregateOutputType | null
    _min: DeviceRecordMinAggregateOutputType | null
    _max: DeviceRecordMaxAggregateOutputType | null
  }

  export type DeviceRecordAvgAggregateOutputType = {
    id: number | null
    lat: number | null
    lon: number | null
  }

  export type DeviceRecordSumAggregateOutputType = {
    id: number | null
    lat: number | null
    lon: number | null
  }

  export type DeviceRecordMinAggregateOutputType = {
    id: number | null
    userid: string | null
    city: string | null
    region: string | null
    country: string | null
    locale: string | null
    lat: number | null
    lon: number | null
    zipcode: string | null
    last_login: Date | null
    browser: string | null
  }

  export type DeviceRecordMaxAggregateOutputType = {
    id: number | null
    userid: string | null
    city: string | null
    region: string | null
    country: string | null
    locale: string | null
    lat: number | null
    lon: number | null
    zipcode: string | null
    last_login: Date | null
    browser: string | null
  }

  export type DeviceRecordCountAggregateOutputType = {
    id: number
    userid: number
    city: number
    region: number
    country: number
    locale: number
    lat: number
    lon: number
    zipcode: number
    last_login: number
    browser: number
    _all: number
  }


  export type DeviceRecordAvgAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type DeviceRecordSumAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type DeviceRecordMinAggregateInputType = {
    id?: true
    userid?: true
    city?: true
    region?: true
    country?: true
    locale?: true
    lat?: true
    lon?: true
    zipcode?: true
    last_login?: true
    browser?: true
  }

  export type DeviceRecordMaxAggregateInputType = {
    id?: true
    userid?: true
    city?: true
    region?: true
    country?: true
    locale?: true
    lat?: true
    lon?: true
    zipcode?: true
    last_login?: true
    browser?: true
  }

  export type DeviceRecordCountAggregateInputType = {
    id?: true
    userid?: true
    city?: true
    region?: true
    country?: true
    locale?: true
    lat?: true
    lon?: true
    zipcode?: true
    last_login?: true
    browser?: true
    _all?: true
  }

  export type DeviceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceRecord to aggregate.
     */
    where?: DeviceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRecords to fetch.
     */
    orderBy?: DeviceRecordOrderByWithRelationInput | DeviceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceRecords
    **/
    _count?: true | DeviceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceRecordMaxAggregateInputType
  }

  export type GetDeviceRecordAggregateType<T extends DeviceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceRecord[P]>
      : GetScalarType<T[P], AggregateDeviceRecord[P]>
  }




  export type DeviceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceRecordWhereInput
    orderBy?: DeviceRecordOrderByWithAggregationInput | DeviceRecordOrderByWithAggregationInput[]
    by: DeviceRecordScalarFieldEnum[] | DeviceRecordScalarFieldEnum
    having?: DeviceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceRecordCountAggregateInputType | true
    _avg?: DeviceRecordAvgAggregateInputType
    _sum?: DeviceRecordSumAggregateInputType
    _min?: DeviceRecordMinAggregateInputType
    _max?: DeviceRecordMaxAggregateInputType
  }

  export type DeviceRecordGroupByOutputType = {
    id: number
    userid: string
    city: string | null
    region: string | null
    country: string | null
    locale: string | null
    lat: number | null
    lon: number | null
    zipcode: string | null
    last_login: Date | null
    browser: string | null
    _count: DeviceRecordCountAggregateOutputType | null
    _avg: DeviceRecordAvgAggregateOutputType | null
    _sum: DeviceRecordSumAggregateOutputType | null
    _min: DeviceRecordMinAggregateOutputType | null
    _max: DeviceRecordMaxAggregateOutputType | null
  }

  type GetDeviceRecordGroupByPayload<T extends DeviceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceRecordGroupByOutputType[P]>
        }
      >
    >


  export type DeviceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    locale?: boolean
    lat?: boolean
    lon?: boolean
    zipcode?: boolean
    last_login?: boolean
    browser?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRecord"]>

  export type DeviceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    locale?: boolean
    lat?: boolean
    lon?: boolean
    zipcode?: boolean
    last_login?: boolean
    browser?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRecord"]>

  export type DeviceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    locale?: boolean
    lat?: boolean
    lon?: boolean
    zipcode?: boolean
    last_login?: boolean
    browser?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceRecord"]>

  export type DeviceRecordSelectScalar = {
    id?: boolean
    userid?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    locale?: boolean
    lat?: boolean
    lon?: boolean
    zipcode?: boolean
    last_login?: boolean
    browser?: boolean
  }

  export type DeviceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "city" | "region" | "country" | "locale" | "lat" | "lon" | "zipcode" | "last_login" | "browser", ExtArgs["result"]["deviceRecord"]>
  export type DeviceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type DeviceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type DeviceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $DeviceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceRecord"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userid: string
      city: string | null
      region: string | null
      country: string | null
      locale: string | null
      lat: number | null
      lon: number | null
      zipcode: string | null
      last_login: Date | null
      browser: string | null
    }, ExtArgs["result"]["deviceRecord"]>
    composites: {}
  }

  type DeviceRecordGetPayload<S extends boolean | null | undefined | DeviceRecordDefaultArgs> = $Result.GetResult<Prisma.$DeviceRecordPayload, S>

  type DeviceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceRecordCountAggregateInputType | true
    }

  export interface DeviceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceRecord'], meta: { name: 'DeviceRecord' } }
    /**
     * Find zero or one DeviceRecord that matches the filter.
     * @param {DeviceRecordFindUniqueArgs} args - Arguments to find a DeviceRecord
     * @example
     * // Get one DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceRecordFindUniqueArgs>(args: SelectSubset<T, DeviceRecordFindUniqueArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceRecordFindUniqueOrThrowArgs} args - Arguments to find a DeviceRecord
     * @example
     * // Get one DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordFindFirstArgs} args - Arguments to find a DeviceRecord
     * @example
     * // Get one DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceRecordFindFirstArgs>(args?: SelectSubset<T, DeviceRecordFindFirstArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordFindFirstOrThrowArgs} args - Arguments to find a DeviceRecord
     * @example
     * // Get one DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceRecords
     * const deviceRecords = await prisma.deviceRecord.findMany()
     * 
     * // Get first 10 DeviceRecords
     * const deviceRecords = await prisma.deviceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceRecordWithIdOnly = await prisma.deviceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceRecordFindManyArgs>(args?: SelectSubset<T, DeviceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceRecord.
     * @param {DeviceRecordCreateArgs} args - Arguments to create a DeviceRecord.
     * @example
     * // Create one DeviceRecord
     * const DeviceRecord = await prisma.deviceRecord.create({
     *   data: {
     *     // ... data to create a DeviceRecord
     *   }
     * })
     * 
     */
    create<T extends DeviceRecordCreateArgs>(args: SelectSubset<T, DeviceRecordCreateArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceRecords.
     * @param {DeviceRecordCreateManyArgs} args - Arguments to create many DeviceRecords.
     * @example
     * // Create many DeviceRecords
     * const deviceRecord = await prisma.deviceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceRecordCreateManyArgs>(args?: SelectSubset<T, DeviceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceRecords and returns the data saved in the database.
     * @param {DeviceRecordCreateManyAndReturnArgs} args - Arguments to create many DeviceRecords.
     * @example
     * // Create many DeviceRecords
     * const deviceRecord = await prisma.deviceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceRecords and only return the `id`
     * const deviceRecordWithIdOnly = await prisma.deviceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceRecord.
     * @param {DeviceRecordDeleteArgs} args - Arguments to delete one DeviceRecord.
     * @example
     * // Delete one DeviceRecord
     * const DeviceRecord = await prisma.deviceRecord.delete({
     *   where: {
     *     // ... filter to delete one DeviceRecord
     *   }
     * })
     * 
     */
    delete<T extends DeviceRecordDeleteArgs>(args: SelectSubset<T, DeviceRecordDeleteArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceRecord.
     * @param {DeviceRecordUpdateArgs} args - Arguments to update one DeviceRecord.
     * @example
     * // Update one DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceRecordUpdateArgs>(args: SelectSubset<T, DeviceRecordUpdateArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceRecords.
     * @param {DeviceRecordDeleteManyArgs} args - Arguments to filter DeviceRecords to delete.
     * @example
     * // Delete a few DeviceRecords
     * const { count } = await prisma.deviceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceRecordDeleteManyArgs>(args?: SelectSubset<T, DeviceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceRecords
     * const deviceRecord = await prisma.deviceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceRecordUpdateManyArgs>(args: SelectSubset<T, DeviceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceRecords and returns the data updated in the database.
     * @param {DeviceRecordUpdateManyAndReturnArgs} args - Arguments to update many DeviceRecords.
     * @example
     * // Update many DeviceRecords
     * const deviceRecord = await prisma.deviceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceRecords and only return the `id`
     * const deviceRecordWithIdOnly = await prisma.deviceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceRecord.
     * @param {DeviceRecordUpsertArgs} args - Arguments to update or create a DeviceRecord.
     * @example
     * // Update or create a DeviceRecord
     * const deviceRecord = await prisma.deviceRecord.upsert({
     *   create: {
     *     // ... data to create a DeviceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceRecord we want to update
     *   }
     * })
     */
    upsert<T extends DeviceRecordUpsertArgs>(args: SelectSubset<T, DeviceRecordUpsertArgs<ExtArgs>>): Prisma__DeviceRecordClient<$Result.GetResult<Prisma.$DeviceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordCountArgs} args - Arguments to filter DeviceRecords to count.
     * @example
     * // Count the number of DeviceRecords
     * const count = await prisma.deviceRecord.count({
     *   where: {
     *     // ... the filter for the DeviceRecords we want to count
     *   }
     * })
    **/
    count<T extends DeviceRecordCountArgs>(
      args?: Subset<T, DeviceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceRecordAggregateArgs>(args: Subset<T, DeviceRecordAggregateArgs>): Prisma.PrismaPromise<GetDeviceRecordAggregateType<T>>

    /**
     * Group by DeviceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceRecordGroupByArgs['orderBy'] }
        : { orderBy?: DeviceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceRecord model
   */
  readonly fields: DeviceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceRecord model
   */
  interface DeviceRecordFieldRefs {
    readonly id: FieldRef<"DeviceRecord", 'Int'>
    readonly userid: FieldRef<"DeviceRecord", 'String'>
    readonly city: FieldRef<"DeviceRecord", 'String'>
    readonly region: FieldRef<"DeviceRecord", 'String'>
    readonly country: FieldRef<"DeviceRecord", 'String'>
    readonly locale: FieldRef<"DeviceRecord", 'String'>
    readonly lat: FieldRef<"DeviceRecord", 'Float'>
    readonly lon: FieldRef<"DeviceRecord", 'Float'>
    readonly zipcode: FieldRef<"DeviceRecord", 'String'>
    readonly last_login: FieldRef<"DeviceRecord", 'DateTime'>
    readonly browser: FieldRef<"DeviceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceRecord findUnique
   */
  export type DeviceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRecord to fetch.
     */
    where: DeviceRecordWhereUniqueInput
  }

  /**
   * DeviceRecord findUniqueOrThrow
   */
  export type DeviceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRecord to fetch.
     */
    where: DeviceRecordWhereUniqueInput
  }

  /**
   * DeviceRecord findFirst
   */
  export type DeviceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRecord to fetch.
     */
    where?: DeviceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRecords to fetch.
     */
    orderBy?: DeviceRecordOrderByWithRelationInput | DeviceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceRecords.
     */
    cursor?: DeviceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceRecords.
     */
    distinct?: DeviceRecordScalarFieldEnum | DeviceRecordScalarFieldEnum[]
  }

  /**
   * DeviceRecord findFirstOrThrow
   */
  export type DeviceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRecord to fetch.
     */
    where?: DeviceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRecords to fetch.
     */
    orderBy?: DeviceRecordOrderByWithRelationInput | DeviceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceRecords.
     */
    cursor?: DeviceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceRecords.
     */
    distinct?: DeviceRecordScalarFieldEnum | DeviceRecordScalarFieldEnum[]
  }

  /**
   * DeviceRecord findMany
   */
  export type DeviceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter, which DeviceRecords to fetch.
     */
    where?: DeviceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceRecords to fetch.
     */
    orderBy?: DeviceRecordOrderByWithRelationInput | DeviceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceRecords.
     */
    cursor?: DeviceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceRecords.
     */
    skip?: number
    distinct?: DeviceRecordScalarFieldEnum | DeviceRecordScalarFieldEnum[]
  }

  /**
   * DeviceRecord create
   */
  export type DeviceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceRecord.
     */
    data: XOR<DeviceRecordCreateInput, DeviceRecordUncheckedCreateInput>
  }

  /**
   * DeviceRecord createMany
   */
  export type DeviceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceRecords.
     */
    data: DeviceRecordCreateManyInput | DeviceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceRecord createManyAndReturn
   */
  export type DeviceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceRecords.
     */
    data: DeviceRecordCreateManyInput | DeviceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceRecord update
   */
  export type DeviceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceRecord.
     */
    data: XOR<DeviceRecordUpdateInput, DeviceRecordUncheckedUpdateInput>
    /**
     * Choose, which DeviceRecord to update.
     */
    where: DeviceRecordWhereUniqueInput
  }

  /**
   * DeviceRecord updateMany
   */
  export type DeviceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceRecords.
     */
    data: XOR<DeviceRecordUpdateManyMutationInput, DeviceRecordUncheckedUpdateManyInput>
    /**
     * Filter which DeviceRecords to update
     */
    where?: DeviceRecordWhereInput
    /**
     * Limit how many DeviceRecords to update.
     */
    limit?: number
  }

  /**
   * DeviceRecord updateManyAndReturn
   */
  export type DeviceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * The data used to update DeviceRecords.
     */
    data: XOR<DeviceRecordUpdateManyMutationInput, DeviceRecordUncheckedUpdateManyInput>
    /**
     * Filter which DeviceRecords to update
     */
    where?: DeviceRecordWhereInput
    /**
     * Limit how many DeviceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceRecord upsert
   */
  export type DeviceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceRecord to update in case it exists.
     */
    where: DeviceRecordWhereUniqueInput
    /**
     * In case the DeviceRecord found by the `where` argument doesn't exist, create a new DeviceRecord with this data.
     */
    create: XOR<DeviceRecordCreateInput, DeviceRecordUncheckedCreateInput>
    /**
     * In case the DeviceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceRecordUpdateInput, DeviceRecordUncheckedUpdateInput>
  }

  /**
   * DeviceRecord delete
   */
  export type DeviceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
    /**
     * Filter which DeviceRecord to delete.
     */
    where: DeviceRecordWhereUniqueInput
  }

  /**
   * DeviceRecord deleteMany
   */
  export type DeviceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceRecords to delete
     */
    where?: DeviceRecordWhereInput
    /**
     * Limit how many DeviceRecords to delete.
     */
    limit?: number
  }

  /**
   * DeviceRecord without action
   */
  export type DeviceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceRecord
     */
    select?: DeviceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceRecord
     */
    omit?: DeviceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceRecordInclude<ExtArgs> | null
  }


  /**
   * Model OldPassword
   */

  export type AggregateOldPassword = {
    _count: OldPasswordCountAggregateOutputType | null
    _avg: OldPasswordAvgAggregateOutputType | null
    _sum: OldPasswordSumAggregateOutputType | null
    _min: OldPasswordMinAggregateOutputType | null
    _max: OldPasswordMaxAggregateOutputType | null
  }

  export type OldPasswordAvgAggregateOutputType = {
    id: number | null
  }

  export type OldPasswordSumAggregateOutputType = {
    id: number | null
  }

  export type OldPasswordMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    password: string | null
  }

  export type OldPasswordMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    password: string | null
  }

  export type OldPasswordCountAggregateOutputType = {
    id: number
    user_id: number
    password: number
    _all: number
  }


  export type OldPasswordAvgAggregateInputType = {
    id?: true
  }

  export type OldPasswordSumAggregateInputType = {
    id?: true
  }

  export type OldPasswordMinAggregateInputType = {
    id?: true
    user_id?: true
    password?: true
  }

  export type OldPasswordMaxAggregateInputType = {
    id?: true
    user_id?: true
    password?: true
  }

  export type OldPasswordCountAggregateInputType = {
    id?: true
    user_id?: true
    password?: true
    _all?: true
  }

  export type OldPasswordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OldPassword to aggregate.
     */
    where?: OldPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OldPasswords to fetch.
     */
    orderBy?: OldPasswordOrderByWithRelationInput | OldPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OldPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OldPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OldPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OldPasswords
    **/
    _count?: true | OldPasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OldPasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OldPasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OldPasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OldPasswordMaxAggregateInputType
  }

  export type GetOldPasswordAggregateType<T extends OldPasswordAggregateArgs> = {
        [P in keyof T & keyof AggregateOldPassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOldPassword[P]>
      : GetScalarType<T[P], AggregateOldPassword[P]>
  }




  export type OldPasswordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OldPasswordWhereInput
    orderBy?: OldPasswordOrderByWithAggregationInput | OldPasswordOrderByWithAggregationInput[]
    by: OldPasswordScalarFieldEnum[] | OldPasswordScalarFieldEnum
    having?: OldPasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OldPasswordCountAggregateInputType | true
    _avg?: OldPasswordAvgAggregateInputType
    _sum?: OldPasswordSumAggregateInputType
    _min?: OldPasswordMinAggregateInputType
    _max?: OldPasswordMaxAggregateInputType
  }

  export type OldPasswordGroupByOutputType = {
    id: number
    user_id: string
    password: string
    _count: OldPasswordCountAggregateOutputType | null
    _avg: OldPasswordAvgAggregateOutputType | null
    _sum: OldPasswordSumAggregateOutputType | null
    _min: OldPasswordMinAggregateOutputType | null
    _max: OldPasswordMaxAggregateOutputType | null
  }

  type GetOldPasswordGroupByPayload<T extends OldPasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OldPasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OldPasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OldPasswordGroupByOutputType[P]>
            : GetScalarType<T[P], OldPasswordGroupByOutputType[P]>
        }
      >
    >


  export type OldPasswordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    password?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oldPassword"]>

  export type OldPasswordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    password?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oldPassword"]>

  export type OldPasswordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    password?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oldPassword"]>

  export type OldPasswordSelectScalar = {
    id?: boolean
    user_id?: boolean
    password?: boolean
  }

  export type OldPasswordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "password", ExtArgs["result"]["oldPassword"]>
  export type OldPasswordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type OldPasswordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type OldPasswordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $OldPasswordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OldPassword"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      password: string
    }, ExtArgs["result"]["oldPassword"]>
    composites: {}
  }

  type OldPasswordGetPayload<S extends boolean | null | undefined | OldPasswordDefaultArgs> = $Result.GetResult<Prisma.$OldPasswordPayload, S>

  type OldPasswordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OldPasswordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OldPasswordCountAggregateInputType | true
    }

  export interface OldPasswordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OldPassword'], meta: { name: 'OldPassword' } }
    /**
     * Find zero or one OldPassword that matches the filter.
     * @param {OldPasswordFindUniqueArgs} args - Arguments to find a OldPassword
     * @example
     * // Get one OldPassword
     * const oldPassword = await prisma.oldPassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OldPasswordFindUniqueArgs>(args: SelectSubset<T, OldPasswordFindUniqueArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OldPassword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OldPasswordFindUniqueOrThrowArgs} args - Arguments to find a OldPassword
     * @example
     * // Get one OldPassword
     * const oldPassword = await prisma.oldPassword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OldPasswordFindUniqueOrThrowArgs>(args: SelectSubset<T, OldPasswordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OldPassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordFindFirstArgs} args - Arguments to find a OldPassword
     * @example
     * // Get one OldPassword
     * const oldPassword = await prisma.oldPassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OldPasswordFindFirstArgs>(args?: SelectSubset<T, OldPasswordFindFirstArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OldPassword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordFindFirstOrThrowArgs} args - Arguments to find a OldPassword
     * @example
     * // Get one OldPassword
     * const oldPassword = await prisma.oldPassword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OldPasswordFindFirstOrThrowArgs>(args?: SelectSubset<T, OldPasswordFindFirstOrThrowArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OldPasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OldPasswords
     * const oldPasswords = await prisma.oldPassword.findMany()
     * 
     * // Get first 10 OldPasswords
     * const oldPasswords = await prisma.oldPassword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oldPasswordWithIdOnly = await prisma.oldPassword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OldPasswordFindManyArgs>(args?: SelectSubset<T, OldPasswordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OldPassword.
     * @param {OldPasswordCreateArgs} args - Arguments to create a OldPassword.
     * @example
     * // Create one OldPassword
     * const OldPassword = await prisma.oldPassword.create({
     *   data: {
     *     // ... data to create a OldPassword
     *   }
     * })
     * 
     */
    create<T extends OldPasswordCreateArgs>(args: SelectSubset<T, OldPasswordCreateArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OldPasswords.
     * @param {OldPasswordCreateManyArgs} args - Arguments to create many OldPasswords.
     * @example
     * // Create many OldPasswords
     * const oldPassword = await prisma.oldPassword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OldPasswordCreateManyArgs>(args?: SelectSubset<T, OldPasswordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OldPasswords and returns the data saved in the database.
     * @param {OldPasswordCreateManyAndReturnArgs} args - Arguments to create many OldPasswords.
     * @example
     * // Create many OldPasswords
     * const oldPassword = await prisma.oldPassword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OldPasswords and only return the `id`
     * const oldPasswordWithIdOnly = await prisma.oldPassword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OldPasswordCreateManyAndReturnArgs>(args?: SelectSubset<T, OldPasswordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OldPassword.
     * @param {OldPasswordDeleteArgs} args - Arguments to delete one OldPassword.
     * @example
     * // Delete one OldPassword
     * const OldPassword = await prisma.oldPassword.delete({
     *   where: {
     *     // ... filter to delete one OldPassword
     *   }
     * })
     * 
     */
    delete<T extends OldPasswordDeleteArgs>(args: SelectSubset<T, OldPasswordDeleteArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OldPassword.
     * @param {OldPasswordUpdateArgs} args - Arguments to update one OldPassword.
     * @example
     * // Update one OldPassword
     * const oldPassword = await prisma.oldPassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OldPasswordUpdateArgs>(args: SelectSubset<T, OldPasswordUpdateArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OldPasswords.
     * @param {OldPasswordDeleteManyArgs} args - Arguments to filter OldPasswords to delete.
     * @example
     * // Delete a few OldPasswords
     * const { count } = await prisma.oldPassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OldPasswordDeleteManyArgs>(args?: SelectSubset<T, OldPasswordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OldPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OldPasswords
     * const oldPassword = await prisma.oldPassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OldPasswordUpdateManyArgs>(args: SelectSubset<T, OldPasswordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OldPasswords and returns the data updated in the database.
     * @param {OldPasswordUpdateManyAndReturnArgs} args - Arguments to update many OldPasswords.
     * @example
     * // Update many OldPasswords
     * const oldPassword = await prisma.oldPassword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OldPasswords and only return the `id`
     * const oldPasswordWithIdOnly = await prisma.oldPassword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OldPasswordUpdateManyAndReturnArgs>(args: SelectSubset<T, OldPasswordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OldPassword.
     * @param {OldPasswordUpsertArgs} args - Arguments to update or create a OldPassword.
     * @example
     * // Update or create a OldPassword
     * const oldPassword = await prisma.oldPassword.upsert({
     *   create: {
     *     // ... data to create a OldPassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OldPassword we want to update
     *   }
     * })
     */
    upsert<T extends OldPasswordUpsertArgs>(args: SelectSubset<T, OldPasswordUpsertArgs<ExtArgs>>): Prisma__OldPasswordClient<$Result.GetResult<Prisma.$OldPasswordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OldPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordCountArgs} args - Arguments to filter OldPasswords to count.
     * @example
     * // Count the number of OldPasswords
     * const count = await prisma.oldPassword.count({
     *   where: {
     *     // ... the filter for the OldPasswords we want to count
     *   }
     * })
    **/
    count<T extends OldPasswordCountArgs>(
      args?: Subset<T, OldPasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OldPasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OldPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OldPasswordAggregateArgs>(args: Subset<T, OldPasswordAggregateArgs>): Prisma.PrismaPromise<GetOldPasswordAggregateType<T>>

    /**
     * Group by OldPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OldPasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OldPasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OldPasswordGroupByArgs['orderBy'] }
        : { orderBy?: OldPasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OldPasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOldPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OldPassword model
   */
  readonly fields: OldPasswordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OldPassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OldPasswordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OldPassword model
   */
  interface OldPasswordFieldRefs {
    readonly id: FieldRef<"OldPassword", 'Int'>
    readonly user_id: FieldRef<"OldPassword", 'String'>
    readonly password: FieldRef<"OldPassword", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OldPassword findUnique
   */
  export type OldPasswordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter, which OldPassword to fetch.
     */
    where: OldPasswordWhereUniqueInput
  }

  /**
   * OldPassword findUniqueOrThrow
   */
  export type OldPasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter, which OldPassword to fetch.
     */
    where: OldPasswordWhereUniqueInput
  }

  /**
   * OldPassword findFirst
   */
  export type OldPasswordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter, which OldPassword to fetch.
     */
    where?: OldPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OldPasswords to fetch.
     */
    orderBy?: OldPasswordOrderByWithRelationInput | OldPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OldPasswords.
     */
    cursor?: OldPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OldPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OldPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OldPasswords.
     */
    distinct?: OldPasswordScalarFieldEnum | OldPasswordScalarFieldEnum[]
  }

  /**
   * OldPassword findFirstOrThrow
   */
  export type OldPasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter, which OldPassword to fetch.
     */
    where?: OldPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OldPasswords to fetch.
     */
    orderBy?: OldPasswordOrderByWithRelationInput | OldPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OldPasswords.
     */
    cursor?: OldPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OldPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OldPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OldPasswords.
     */
    distinct?: OldPasswordScalarFieldEnum | OldPasswordScalarFieldEnum[]
  }

  /**
   * OldPassword findMany
   */
  export type OldPasswordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter, which OldPasswords to fetch.
     */
    where?: OldPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OldPasswords to fetch.
     */
    orderBy?: OldPasswordOrderByWithRelationInput | OldPasswordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OldPasswords.
     */
    cursor?: OldPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OldPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OldPasswords.
     */
    skip?: number
    distinct?: OldPasswordScalarFieldEnum | OldPasswordScalarFieldEnum[]
  }

  /**
   * OldPassword create
   */
  export type OldPasswordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a OldPassword.
     */
    data: XOR<OldPasswordCreateInput, OldPasswordUncheckedCreateInput>
  }

  /**
   * OldPassword createMany
   */
  export type OldPasswordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OldPasswords.
     */
    data: OldPasswordCreateManyInput | OldPasswordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OldPassword createManyAndReturn
   */
  export type OldPasswordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * The data used to create many OldPasswords.
     */
    data: OldPasswordCreateManyInput | OldPasswordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OldPassword update
   */
  export type OldPasswordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a OldPassword.
     */
    data: XOR<OldPasswordUpdateInput, OldPasswordUncheckedUpdateInput>
    /**
     * Choose, which OldPassword to update.
     */
    where: OldPasswordWhereUniqueInput
  }

  /**
   * OldPassword updateMany
   */
  export type OldPasswordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OldPasswords.
     */
    data: XOR<OldPasswordUpdateManyMutationInput, OldPasswordUncheckedUpdateManyInput>
    /**
     * Filter which OldPasswords to update
     */
    where?: OldPasswordWhereInput
    /**
     * Limit how many OldPasswords to update.
     */
    limit?: number
  }

  /**
   * OldPassword updateManyAndReturn
   */
  export type OldPasswordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * The data used to update OldPasswords.
     */
    data: XOR<OldPasswordUpdateManyMutationInput, OldPasswordUncheckedUpdateManyInput>
    /**
     * Filter which OldPasswords to update
     */
    where?: OldPasswordWhereInput
    /**
     * Limit how many OldPasswords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OldPassword upsert
   */
  export type OldPasswordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the OldPassword to update in case it exists.
     */
    where: OldPasswordWhereUniqueInput
    /**
     * In case the OldPassword found by the `where` argument doesn't exist, create a new OldPassword with this data.
     */
    create: XOR<OldPasswordCreateInput, OldPasswordUncheckedCreateInput>
    /**
     * In case the OldPassword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OldPasswordUpdateInput, OldPasswordUncheckedUpdateInput>
  }

  /**
   * OldPassword delete
   */
  export type OldPasswordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
    /**
     * Filter which OldPassword to delete.
     */
    where: OldPasswordWhereUniqueInput
  }

  /**
   * OldPassword deleteMany
   */
  export type OldPasswordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OldPasswords to delete
     */
    where?: OldPasswordWhereInput
    /**
     * Limit how many OldPasswords to delete.
     */
    limit?: number
  }

  /**
   * OldPassword without action
   */
  export type OldPasswordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OldPassword
     */
    select?: OldPasswordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OldPassword
     */
    omit?: OldPasswordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OldPasswordInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    user_id: number | null
    device_info_id: number | null
  }

  export type SessionSumAggregateOutputType = {
    user_id: number | null
    device_info_id: number | null
  }

  export type SessionMinAggregateOutputType = {
    jti: string | null
    user_id: number | null
    is_active: boolean | null
    issued_at: Date | null
    device_info_id: number | null
    expire_at: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    jti: string | null
    user_id: number | null
    is_active: boolean | null
    issued_at: Date | null
    device_info_id: number | null
    expire_at: Date | null
  }

  export type SessionCountAggregateOutputType = {
    jti: number
    user_id: number
    is_active: number
    issued_at: number
    device_info_id: number
    expire_at: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    user_id?: true
    device_info_id?: true
  }

  export type SessionSumAggregateInputType = {
    user_id?: true
    device_info_id?: true
  }

  export type SessionMinAggregateInputType = {
    jti?: true
    user_id?: true
    is_active?: true
    issued_at?: true
    device_info_id?: true
    expire_at?: true
  }

  export type SessionMaxAggregateInputType = {
    jti?: true
    user_id?: true
    is_active?: true
    issued_at?: true
    device_info_id?: true
    expire_at?: true
  }

  export type SessionCountAggregateInputType = {
    jti?: true
    user_id?: true
    is_active?: true
    issued_at?: true
    device_info_id?: true
    expire_at?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    jti: string
    user_id: number
    is_active: boolean
    issued_at: Date
    device_info_id: number | null
    expire_at: Date | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jti?: boolean
    user_id?: boolean
    is_active?: boolean
    issued_at?: boolean
    device_info_id?: boolean
    expire_at?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jti?: boolean
    user_id?: boolean
    is_active?: boolean
    issued_at?: boolean
    device_info_id?: boolean
    expire_at?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jti?: boolean
    user_id?: boolean
    is_active?: boolean
    issued_at?: boolean
    device_info_id?: boolean
    expire_at?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    jti?: boolean
    user_id?: boolean
    is_active?: boolean
    issued_at?: boolean
    device_info_id?: boolean
    expire_at?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jti" | "user_id" | "is_active" | "issued_at" | "device_info_id" | "expire_at", ExtArgs["result"]["session"]>

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      jti: string
      user_id: number
      is_active: boolean
      issued_at: Date
      device_info_id: number | null
      expire_at: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `jti`
     * const sessionWithJtiOnly = await prisma.session.findMany({ select: { jti: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `jti`
     * const sessionWithJtiOnly = await prisma.session.createManyAndReturn({
     *   select: { jti: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `jti`
     * const sessionWithJtiOnly = await prisma.session.updateManyAndReturn({
     *   select: { jti: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly jti: FieldRef<"Session", 'String'>
    readonly user_id: FieldRef<"Session", 'Int'>
    readonly is_active: FieldRef<"Session", 'Boolean'>
    readonly issued_at: FieldRef<"Session", 'DateTime'>
    readonly device_info_id: FieldRef<"Session", 'Int'>
    readonly expire_at: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BlockScalarFieldEnum: {
    blockedId: 'blockedId',
    blockerId: 'blockerId'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    followerId: 'followerId',
    followingId: 'followingId',
    status: 'status'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const MentionScalarFieldEnum: {
    tweetId: 'tweetId',
    mentionerId: 'mentionerId',
    mentionedId: 'mentionedId'
  };

  export type MentionScalarFieldEnum = (typeof MentionScalarFieldEnum)[keyof typeof MentionScalarFieldEnum]


  export const MessageMediaScalarFieldEnum: {
    messageId: 'messageId',
    mediaId: 'mediaId'
  };

  export type MessageMediaScalarFieldEnum = (typeof MessageMediaScalarFieldEnum)[keyof typeof MessageMediaScalarFieldEnum]


  export const MuteScalarFieldEnum: {
    mutedId: 'mutedId',
    muterId: 'muterId'
  };

  export type MuteScalarFieldEnum = (typeof MuteScalarFieldEnum)[keyof typeof MuteScalarFieldEnum]


  export const RetweetScalarFieldEnum: {
    userId: 'userId',
    tweetId: 'tweetId'
  };

  export type RetweetScalarFieldEnum = (typeof RetweetScalarFieldEnum)[keyof typeof RetweetScalarFieldEnum]


  export const TweetLikeScalarFieldEnum: {
    tweetId: 'tweetId',
    userId: 'userId'
  };

  export type TweetLikeScalarFieldEnum = (typeof TweetLikeScalarFieldEnum)[keyof typeof TweetLikeScalarFieldEnum]


  export const TweetMediaScalarFieldEnum: {
    tweetId: 'tweetId',
    mediaId: 'mediaId'
  };

  export type TweetMediaScalarFieldEnum = (typeof TweetMediaScalarFieldEnum)[keyof typeof TweetMediaScalarFieldEnum]


  export const TweetSummaryScalarFieldEnum: {
    id: 'id',
    tweetId: 'tweetId',
    summary: 'summary'
  };

  export type TweetSummaryScalarFieldEnum = (typeof TweetSummaryScalarFieldEnum)[keyof typeof TweetSummaryScalarFieldEnum]


  export const ChatGroupsScalarFieldEnum: {
    name: 'name',
    description: 'description',
    photo: 'photo',
    chatId: 'chatId'
  };

  export type ChatGroupsScalarFieldEnum = (typeof ChatGroupsScalarFieldEnum)[keyof typeof ChatGroupsScalarFieldEnum]


  export const ChatsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    DMChat: 'DMChat'
  };

  export type ChatsScalarFieldEnum = (typeof ChatsScalarFieldEnum)[keyof typeof ChatsScalarFieldEnum]


  export const ChatusersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chatId: 'chatId'
  };

  export type ChatusersScalarFieldEnum = (typeof ChatusersScalarFieldEnum)[keyof typeof ChatusersScalarFieldEnum]


  export const HashesScalarFieldEnum: {
    id: 'id',
    tag_text: 'tag_text'
  };

  export type HashesScalarFieldEnum = (typeof HashesScalarFieldEnum)[keyof typeof HashesScalarFieldEnum]


  export const MediasScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    type: 'type',
    size: 'size'
  };

  export type MediasScalarFieldEnum = (typeof MediasScalarFieldEnum)[keyof typeof MediasScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    status: 'status'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId',
    tweetId: 'tweetId',
    actorId: 'actorId'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Spatial_ref_sysScalarFieldEnum: {
    srid: 'srid',
    auth_name: 'auth_name',
    auth_srid: 'auth_srid',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type Spatial_ref_sysScalarFieldEnum = (typeof Spatial_ref_sysScalarFieldEnum)[keyof typeof Spatial_ref_sysScalarFieldEnum]


  export const TweetHashesScalarFieldEnum: {
    tweetId: 'tweetId',
    hashId: 'hashId'
  };

  export type TweetHashesScalarFieldEnum = (typeof TweetHashesScalarFieldEnum)[keyof typeof TweetHashesScalarFieldEnum]


  export const TweetbookmarksScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tweetId: 'tweetId'
  };

  export type TweetbookmarksScalarFieldEnum = (typeof TweetbookmarksScalarFieldEnum)[keyof typeof TweetbookmarksScalarFieldEnum]


  export const TweetsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    likesCount: 'likesCount',
    retweetCount: 'retweetCount',
    repliesCount: 'repliesCount',
    parentId: 'parentId',
    tweetType: 'tweetType',
    replyControl: 'replyControl'
  };

  export type TweetsScalarFieldEnum = (typeof TweetsScalarFieldEnum)[keyof typeof TweetsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    email: 'email',
    is_email_verified: 'is_email_verified',
    password: 'password',
    saltPassword: 'saltPassword',
    otp: 'otp',
    otpExpiry: 'otpExpiry',
    tfa_verifed: 'tfa_verifed',
    bio: 'bio',
    dateOfBirth: 'dateOfBirth',
    joinDate: 'joinDate',
    verified: 'verified',
    address: 'address',
    website: 'website',
    protectedAccount: 'protectedAccount',
    profilePhoto: 'profilePhoto',
    cover: 'cover',
    provider: 'provider',
    login_codes: 'login_codes',
    login_codes_set: 'login_codes_set'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const DeviceRecordScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    city: 'city',
    region: 'region',
    country: 'country',
    locale: 'locale',
    lat: 'lat',
    lon: 'lon',
    zipcode: 'zipcode',
    last_login: 'last_login',
    browser: 'browser'
  };

  export type DeviceRecordScalarFieldEnum = (typeof DeviceRecordScalarFieldEnum)[keyof typeof DeviceRecordScalarFieldEnum]


  export const OldPasswordScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    password: 'password'
  };

  export type OldPasswordScalarFieldEnum = (typeof OldPasswordScalarFieldEnum)[keyof typeof OldPasswordScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    jti: 'jti',
    user_id: 'user_id',
    is_active: 'is_active',
    issued_at: 'issued_at',
    device_info_id: 'device_info_id',
    expire_at: 'expire_at'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'FollowStatus'
   */
  export type EnumFollowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowStatus'>
    


  /**
   * Reference to a field of type 'FollowStatus[]'
   */
  export type ListEnumFollowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'TweetType'
   */
  export type EnumTweetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TweetType'>
    


  /**
   * Reference to a field of type 'TweetType[]'
   */
  export type ListEnumTweetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TweetType[]'>
    


  /**
   * Reference to a field of type 'ReplyControl'
   */
  export type EnumReplyControlFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplyControl'>
    


  /**
   * Reference to a field of type 'ReplyControl[]'
   */
  export type ListEnumReplyControlFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReplyControl[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockedId?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    users_Block_blockedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Block_blockerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    blockedId?: SortOrder
    blockerId?: SortOrder
    users_Block_blockedIdTousers?: usersOrderByWithRelationInput
    users_Block_blockerIdTousers?: usersOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    blockerId_blockedId?: BlockBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockedId?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    users_Block_blockedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Block_blockerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "blockerId_blockedId">

  export type BlockOrderByWithAggregationInput = {
    blockedId?: SortOrder
    blockerId?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    blockedId?: StringWithAggregatesFilter<"Block"> | string
    blockerId?: StringWithAggregatesFilter<"Block"> | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    status?: EnumFollowStatusFilter<"Follow"> | $Enums.FollowStatus
    users_Follow_followerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Follow_followingIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    status?: SortOrder
    users_Follow_followerIdTousers?: usersOrderByWithRelationInput
    users_Follow_followingIdTousers?: usersOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    status?: EnumFollowStatusFilter<"Follow"> | $Enums.FollowStatus
    users_Follow_followerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Follow_followingIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    status?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    status?: EnumFollowStatusWithAggregatesFilter<"Follow"> | $Enums.FollowStatus
  }

  export type MentionWhereInput = {
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    tweetId?: StringFilter<"Mention"> | string
    mentionerId?: StringFilter<"Mention"> | string
    mentionedId?: StringFilter<"Mention"> | string
    users_Mention_mentionedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Mention_mentionerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }

  export type MentionOrderByWithRelationInput = {
    tweetId?: SortOrder
    mentionerId?: SortOrder
    mentionedId?: SortOrder
    users_Mention_mentionedIdTousers?: usersOrderByWithRelationInput
    users_Mention_mentionerIdTousers?: usersOrderByWithRelationInput
    tweets?: tweetsOrderByWithRelationInput
  }

  export type MentionWhereUniqueInput = Prisma.AtLeast<{
    tweetId_mentionerId_mentionedId?: MentionTweetIdMentionerIdMentionedIdCompoundUniqueInput
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    tweetId?: StringFilter<"Mention"> | string
    mentionerId?: StringFilter<"Mention"> | string
    mentionedId?: StringFilter<"Mention"> | string
    users_Mention_mentionedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Mention_mentionerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }, "tweetId_mentionerId_mentionedId">

  export type MentionOrderByWithAggregationInput = {
    tweetId?: SortOrder
    mentionerId?: SortOrder
    mentionedId?: SortOrder
    _count?: MentionCountOrderByAggregateInput
    _max?: MentionMaxOrderByAggregateInput
    _min?: MentionMinOrderByAggregateInput
  }

  export type MentionScalarWhereWithAggregatesInput = {
    AND?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    OR?: MentionScalarWhereWithAggregatesInput[]
    NOT?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    tweetId?: StringWithAggregatesFilter<"Mention"> | string
    mentionerId?: StringWithAggregatesFilter<"Mention"> | string
    mentionedId?: StringWithAggregatesFilter<"Mention"> | string
  }

  export type MessageMediaWhereInput = {
    AND?: MessageMediaWhereInput | MessageMediaWhereInput[]
    OR?: MessageMediaWhereInput[]
    NOT?: MessageMediaWhereInput | MessageMediaWhereInput[]
    messageId?: StringFilter<"MessageMedia"> | string
    mediaId?: StringFilter<"MessageMedia"> | string
    medias?: XOR<MediasScalarRelationFilter, mediasWhereInput>
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }

  export type MessageMediaOrderByWithRelationInput = {
    messageId?: SortOrder
    mediaId?: SortOrder
    medias?: mediasOrderByWithRelationInput
    messages?: messagesOrderByWithRelationInput
  }

  export type MessageMediaWhereUniqueInput = Prisma.AtLeast<{
    messageId_mediaId?: MessageMediaMessageIdMediaIdCompoundUniqueInput
    AND?: MessageMediaWhereInput | MessageMediaWhereInput[]
    OR?: MessageMediaWhereInput[]
    NOT?: MessageMediaWhereInput | MessageMediaWhereInput[]
    messageId?: StringFilter<"MessageMedia"> | string
    mediaId?: StringFilter<"MessageMedia"> | string
    medias?: XOR<MediasScalarRelationFilter, mediasWhereInput>
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }, "messageId_mediaId">

  export type MessageMediaOrderByWithAggregationInput = {
    messageId?: SortOrder
    mediaId?: SortOrder
    _count?: MessageMediaCountOrderByAggregateInput
    _max?: MessageMediaMaxOrderByAggregateInput
    _min?: MessageMediaMinOrderByAggregateInput
  }

  export type MessageMediaScalarWhereWithAggregatesInput = {
    AND?: MessageMediaScalarWhereWithAggregatesInput | MessageMediaScalarWhereWithAggregatesInput[]
    OR?: MessageMediaScalarWhereWithAggregatesInput[]
    NOT?: MessageMediaScalarWhereWithAggregatesInput | MessageMediaScalarWhereWithAggregatesInput[]
    messageId?: StringWithAggregatesFilter<"MessageMedia"> | string
    mediaId?: StringWithAggregatesFilter<"MessageMedia"> | string
  }

  export type MuteWhereInput = {
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    mutedId?: StringFilter<"Mute"> | string
    muterId?: StringFilter<"Mute"> | string
    users_Mute_mutedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Mute_muterIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type MuteOrderByWithRelationInput = {
    mutedId?: SortOrder
    muterId?: SortOrder
    users_Mute_mutedIdTousers?: usersOrderByWithRelationInput
    users_Mute_muterIdTousers?: usersOrderByWithRelationInput
  }

  export type MuteWhereUniqueInput = Prisma.AtLeast<{
    muterId_mutedId?: MuteMuterIdMutedIdCompoundUniqueInput
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    mutedId?: StringFilter<"Mute"> | string
    muterId?: StringFilter<"Mute"> | string
    users_Mute_mutedIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_Mute_muterIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "muterId_mutedId">

  export type MuteOrderByWithAggregationInput = {
    mutedId?: SortOrder
    muterId?: SortOrder
    _count?: MuteCountOrderByAggregateInput
    _max?: MuteMaxOrderByAggregateInput
    _min?: MuteMinOrderByAggregateInput
  }

  export type MuteScalarWhereWithAggregatesInput = {
    AND?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    OR?: MuteScalarWhereWithAggregatesInput[]
    NOT?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    mutedId?: StringWithAggregatesFilter<"Mute"> | string
    muterId?: StringWithAggregatesFilter<"Mute"> | string
  }

  export type RetweetWhereInput = {
    AND?: RetweetWhereInput | RetweetWhereInput[]
    OR?: RetweetWhereInput[]
    NOT?: RetweetWhereInput | RetweetWhereInput[]
    userId?: StringFilter<"Retweet"> | string
    tweetId?: StringFilter<"Retweet"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type RetweetOrderByWithRelationInput = {
    userId?: SortOrder
    tweetId?: SortOrder
    tweets?: tweetsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type RetweetWhereUniqueInput = Prisma.AtLeast<{
    userId_tweetId?: RetweetUserIdTweetIdCompoundUniqueInput
    AND?: RetweetWhereInput | RetweetWhereInput[]
    OR?: RetweetWhereInput[]
    NOT?: RetweetWhereInput | RetweetWhereInput[]
    userId?: StringFilter<"Retweet"> | string
    tweetId?: StringFilter<"Retweet"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "userId_tweetId">

  export type RetweetOrderByWithAggregationInput = {
    userId?: SortOrder
    tweetId?: SortOrder
    _count?: RetweetCountOrderByAggregateInput
    _max?: RetweetMaxOrderByAggregateInput
    _min?: RetweetMinOrderByAggregateInput
  }

  export type RetweetScalarWhereWithAggregatesInput = {
    AND?: RetweetScalarWhereWithAggregatesInput | RetweetScalarWhereWithAggregatesInput[]
    OR?: RetweetScalarWhereWithAggregatesInput[]
    NOT?: RetweetScalarWhereWithAggregatesInput | RetweetScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Retweet"> | string
    tweetId?: StringWithAggregatesFilter<"Retweet"> | string
  }

  export type TweetLikeWhereInput = {
    AND?: TweetLikeWhereInput | TweetLikeWhereInput[]
    OR?: TweetLikeWhereInput[]
    NOT?: TweetLikeWhereInput | TweetLikeWhereInput[]
    tweetId?: StringFilter<"TweetLike"> | string
    userId?: StringFilter<"TweetLike"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type TweetLikeOrderByWithRelationInput = {
    tweetId?: SortOrder
    userId?: SortOrder
    tweets?: tweetsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type TweetLikeWhereUniqueInput = Prisma.AtLeast<{
    userId_tweetId?: TweetLikeUserIdTweetIdCompoundUniqueInput
    AND?: TweetLikeWhereInput | TweetLikeWhereInput[]
    OR?: TweetLikeWhereInput[]
    NOT?: TweetLikeWhereInput | TweetLikeWhereInput[]
    tweetId?: StringFilter<"TweetLike"> | string
    userId?: StringFilter<"TweetLike"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "userId_tweetId">

  export type TweetLikeOrderByWithAggregationInput = {
    tweetId?: SortOrder
    userId?: SortOrder
    _count?: TweetLikeCountOrderByAggregateInput
    _max?: TweetLikeMaxOrderByAggregateInput
    _min?: TweetLikeMinOrderByAggregateInput
  }

  export type TweetLikeScalarWhereWithAggregatesInput = {
    AND?: TweetLikeScalarWhereWithAggregatesInput | TweetLikeScalarWhereWithAggregatesInput[]
    OR?: TweetLikeScalarWhereWithAggregatesInput[]
    NOT?: TweetLikeScalarWhereWithAggregatesInput | TweetLikeScalarWhereWithAggregatesInput[]
    tweetId?: StringWithAggregatesFilter<"TweetLike"> | string
    userId?: StringWithAggregatesFilter<"TweetLike"> | string
  }

  export type TweetMediaWhereInput = {
    AND?: TweetMediaWhereInput | TweetMediaWhereInput[]
    OR?: TweetMediaWhereInput[]
    NOT?: TweetMediaWhereInput | TweetMediaWhereInput[]
    tweetId?: StringFilter<"TweetMedia"> | string
    mediaId?: StringFilter<"TweetMedia"> | string
    medias?: XOR<MediasScalarRelationFilter, mediasWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }

  export type TweetMediaOrderByWithRelationInput = {
    tweetId?: SortOrder
    mediaId?: SortOrder
    medias?: mediasOrderByWithRelationInput
    tweets?: tweetsOrderByWithRelationInput
  }

  export type TweetMediaWhereUniqueInput = Prisma.AtLeast<{
    tweetId_mediaId?: TweetMediaTweetIdMediaIdCompoundUniqueInput
    AND?: TweetMediaWhereInput | TweetMediaWhereInput[]
    OR?: TweetMediaWhereInput[]
    NOT?: TweetMediaWhereInput | TweetMediaWhereInput[]
    tweetId?: StringFilter<"TweetMedia"> | string
    mediaId?: StringFilter<"TweetMedia"> | string
    medias?: XOR<MediasScalarRelationFilter, mediasWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }, "tweetId_mediaId">

  export type TweetMediaOrderByWithAggregationInput = {
    tweetId?: SortOrder
    mediaId?: SortOrder
    _count?: TweetMediaCountOrderByAggregateInput
    _max?: TweetMediaMaxOrderByAggregateInput
    _min?: TweetMediaMinOrderByAggregateInput
  }

  export type TweetMediaScalarWhereWithAggregatesInput = {
    AND?: TweetMediaScalarWhereWithAggregatesInput | TweetMediaScalarWhereWithAggregatesInput[]
    OR?: TweetMediaScalarWhereWithAggregatesInput[]
    NOT?: TweetMediaScalarWhereWithAggregatesInput | TweetMediaScalarWhereWithAggregatesInput[]
    tweetId?: StringWithAggregatesFilter<"TweetMedia"> | string
    mediaId?: StringWithAggregatesFilter<"TweetMedia"> | string
  }

  export type TweetSummaryWhereInput = {
    AND?: TweetSummaryWhereInput | TweetSummaryWhereInput[]
    OR?: TweetSummaryWhereInput[]
    NOT?: TweetSummaryWhereInput | TweetSummaryWhereInput[]
    id?: StringFilter<"TweetSummary"> | string
    tweetId?: StringFilter<"TweetSummary"> | string
    summary?: StringFilter<"TweetSummary"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }

  export type TweetSummaryOrderByWithRelationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    summary?: SortOrder
    tweets?: tweetsOrderByWithRelationInput
  }

  export type TweetSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: TweetSummaryWhereInput | TweetSummaryWhereInput[]
    OR?: TweetSummaryWhereInput[]
    NOT?: TweetSummaryWhereInput | TweetSummaryWhereInput[]
    summary?: StringFilter<"TweetSummary"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }, "id" | "tweetId">

  export type TweetSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    summary?: SortOrder
    _count?: TweetSummaryCountOrderByAggregateInput
    _max?: TweetSummaryMaxOrderByAggregateInput
    _min?: TweetSummaryMinOrderByAggregateInput
  }

  export type TweetSummaryScalarWhereWithAggregatesInput = {
    AND?: TweetSummaryScalarWhereWithAggregatesInput | TweetSummaryScalarWhereWithAggregatesInput[]
    OR?: TweetSummaryScalarWhereWithAggregatesInput[]
    NOT?: TweetSummaryScalarWhereWithAggregatesInput | TweetSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TweetSummary"> | string
    tweetId?: StringWithAggregatesFilter<"TweetSummary"> | string
    summary?: StringWithAggregatesFilter<"TweetSummary"> | string
  }

  export type chatGroupsWhereInput = {
    AND?: chatGroupsWhereInput | chatGroupsWhereInput[]
    OR?: chatGroupsWhereInput[]
    NOT?: chatGroupsWhereInput | chatGroupsWhereInput[]
    name?: StringNullableFilter<"chatGroups"> | string | null
    description?: StringNullableFilter<"chatGroups"> | string | null
    photo?: StringNullableFilter<"chatGroups"> | string | null
    chatId?: StringFilter<"chatGroups"> | string
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
  }

  export type chatGroupsOrderByWithRelationInput = {
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    chatId?: SortOrder
    chats?: chatsOrderByWithRelationInput
  }

  export type chatGroupsWhereUniqueInput = Prisma.AtLeast<{
    chatId?: string
    AND?: chatGroupsWhereInput | chatGroupsWhereInput[]
    OR?: chatGroupsWhereInput[]
    NOT?: chatGroupsWhereInput | chatGroupsWhereInput[]
    name?: StringNullableFilter<"chatGroups"> | string | null
    description?: StringNullableFilter<"chatGroups"> | string | null
    photo?: StringNullableFilter<"chatGroups"> | string | null
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
  }, "chatId">

  export type chatGroupsOrderByWithAggregationInput = {
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    chatId?: SortOrder
    _count?: chatGroupsCountOrderByAggregateInput
    _max?: chatGroupsMaxOrderByAggregateInput
    _min?: chatGroupsMinOrderByAggregateInput
  }

  export type chatGroupsScalarWhereWithAggregatesInput = {
    AND?: chatGroupsScalarWhereWithAggregatesInput | chatGroupsScalarWhereWithAggregatesInput[]
    OR?: chatGroupsScalarWhereWithAggregatesInput[]
    NOT?: chatGroupsScalarWhereWithAggregatesInput | chatGroupsScalarWhereWithAggregatesInput[]
    name?: StringNullableWithAggregatesFilter<"chatGroups"> | string | null
    description?: StringNullableWithAggregatesFilter<"chatGroups"> | string | null
    photo?: StringNullableWithAggregatesFilter<"chatGroups"> | string | null
    chatId?: StringWithAggregatesFilter<"chatGroups"> | string
  }

  export type chatsWhereInput = {
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    id?: StringFilter<"chats"> | string
    createdAt?: DateTimeFilter<"chats"> | Date | string
    updatedAt?: DateTimeFilter<"chats"> | Date | string
    DMChat?: BoolFilter<"chats"> | boolean
    chatGroups?: XOR<ChatGroupsNullableScalarRelationFilter, chatGroupsWhereInput> | null
    chatusers?: ChatusersListRelationFilter
    messages?: MessagesListRelationFilter
  }

  export type chatsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DMChat?: SortOrder
    chatGroups?: chatGroupsOrderByWithRelationInput
    chatusers?: chatusersOrderByRelationAggregateInput
    messages?: messagesOrderByRelationAggregateInput
  }

  export type chatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    createdAt?: DateTimeFilter<"chats"> | Date | string
    updatedAt?: DateTimeFilter<"chats"> | Date | string
    DMChat?: BoolFilter<"chats"> | boolean
    chatGroups?: XOR<ChatGroupsNullableScalarRelationFilter, chatGroupsWhereInput> | null
    chatusers?: ChatusersListRelationFilter
    messages?: MessagesListRelationFilter
  }, "id">

  export type chatsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DMChat?: SortOrder
    _count?: chatsCountOrderByAggregateInput
    _max?: chatsMaxOrderByAggregateInput
    _min?: chatsMinOrderByAggregateInput
  }

  export type chatsScalarWhereWithAggregatesInput = {
    AND?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    OR?: chatsScalarWhereWithAggregatesInput[]
    NOT?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"chats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"chats"> | Date | string
    DMChat?: BoolWithAggregatesFilter<"chats"> | boolean
  }

  export type chatusersWhereInput = {
    AND?: chatusersWhereInput | chatusersWhereInput[]
    OR?: chatusersWhereInput[]
    NOT?: chatusersWhereInput | chatusersWhereInput[]
    id?: StringFilter<"chatusers"> | string
    userId?: StringFilter<"chatusers"> | string
    chatId?: StringFilter<"chatusers"> | string
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type chatusersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    chats?: chatsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type chatusersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_chatId?: chatusersUserIdChatIdCompoundUniqueInput
    AND?: chatusersWhereInput | chatusersWhereInput[]
    OR?: chatusersWhereInput[]
    NOT?: chatusersWhereInput | chatusersWhereInput[]
    userId?: StringFilter<"chatusers"> | string
    chatId?: StringFilter<"chatusers"> | string
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId_chatId">

  export type chatusersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    _count?: chatusersCountOrderByAggregateInput
    _max?: chatusersMaxOrderByAggregateInput
    _min?: chatusersMinOrderByAggregateInput
  }

  export type chatusersScalarWhereWithAggregatesInput = {
    AND?: chatusersScalarWhereWithAggregatesInput | chatusersScalarWhereWithAggregatesInput[]
    OR?: chatusersScalarWhereWithAggregatesInput[]
    NOT?: chatusersScalarWhereWithAggregatesInput | chatusersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chatusers"> | string
    userId?: StringWithAggregatesFilter<"chatusers"> | string
    chatId?: StringWithAggregatesFilter<"chatusers"> | string
  }

  export type hashesWhereInput = {
    AND?: hashesWhereInput | hashesWhereInput[]
    OR?: hashesWhereInput[]
    NOT?: hashesWhereInput | hashesWhereInput[]
    id?: StringFilter<"hashes"> | string
    tag_text?: StringFilter<"hashes"> | string
    tweetHashes?: TweetHashesListRelationFilter
  }

  export type hashesOrderByWithRelationInput = {
    id?: SortOrder
    tag_text?: SortOrder
    tweetHashes?: tweetHashesOrderByRelationAggregateInput
  }

  export type hashesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag_text?: string
    AND?: hashesWhereInput | hashesWhereInput[]
    OR?: hashesWhereInput[]
    NOT?: hashesWhereInput | hashesWhereInput[]
    tweetHashes?: TweetHashesListRelationFilter
  }, "id" | "tag_text">

  export type hashesOrderByWithAggregationInput = {
    id?: SortOrder
    tag_text?: SortOrder
    _count?: hashesCountOrderByAggregateInput
    _max?: hashesMaxOrderByAggregateInput
    _min?: hashesMinOrderByAggregateInput
  }

  export type hashesScalarWhereWithAggregatesInput = {
    AND?: hashesScalarWhereWithAggregatesInput | hashesScalarWhereWithAggregatesInput[]
    OR?: hashesScalarWhereWithAggregatesInput[]
    NOT?: hashesScalarWhereWithAggregatesInput | hashesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"hashes"> | string
    tag_text?: StringWithAggregatesFilter<"hashes"> | string
  }

  export type mediasWhereInput = {
    AND?: mediasWhereInput | mediasWhereInput[]
    OR?: mediasWhereInput[]
    NOT?: mediasWhereInput | mediasWhereInput[]
    id?: StringFilter<"medias"> | string
    name?: StringFilter<"medias"> | string
    url?: StringFilter<"medias"> | string
    type?: EnumMediaTypeFilter<"medias"> | $Enums.MediaType
    size?: IntNullableFilter<"medias"> | number | null
    MessageMedia?: MessageMediaListRelationFilter
    TweetMedia?: TweetMediaListRelationFilter
  }

  export type mediasOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrderInput | SortOrder
    MessageMedia?: MessageMediaOrderByRelationAggregateInput
    TweetMedia?: TweetMediaOrderByRelationAggregateInput
  }

  export type mediasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mediasWhereInput | mediasWhereInput[]
    OR?: mediasWhereInput[]
    NOT?: mediasWhereInput | mediasWhereInput[]
    name?: StringFilter<"medias"> | string
    url?: StringFilter<"medias"> | string
    type?: EnumMediaTypeFilter<"medias"> | $Enums.MediaType
    size?: IntNullableFilter<"medias"> | number | null
    MessageMedia?: MessageMediaListRelationFilter
    TweetMedia?: TweetMediaListRelationFilter
  }, "id">

  export type mediasOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrderInput | SortOrder
    _count?: mediasCountOrderByAggregateInput
    _avg?: mediasAvgOrderByAggregateInput
    _max?: mediasMaxOrderByAggregateInput
    _min?: mediasMinOrderByAggregateInput
    _sum?: mediasSumOrderByAggregateInput
  }

  export type mediasScalarWhereWithAggregatesInput = {
    AND?: mediasScalarWhereWithAggregatesInput | mediasScalarWhereWithAggregatesInput[]
    OR?: mediasScalarWhereWithAggregatesInput[]
    NOT?: mediasScalarWhereWithAggregatesInput | mediasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"medias"> | string
    name?: StringWithAggregatesFilter<"medias"> | string
    url?: StringWithAggregatesFilter<"medias"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"medias"> | $Enums.MediaType
    size?: IntNullableWithAggregatesFilter<"medias"> | number | null
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: StringFilter<"messages"> | string
    chatId?: StringFilter<"messages"> | string
    userId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    createdAt?: DateTimeFilter<"messages"> | Date | string
    status?: EnumMessageStatusFilter<"messages"> | $Enums.MessageStatus
    MessageMedia?: MessageMediaListRelationFilter
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    MessageMedia?: MessageMediaOrderByRelationAggregateInput
    chats?: chatsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    chatId?: StringFilter<"messages"> | string
    userId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    createdAt?: DateTimeFilter<"messages"> | Date | string
    status?: EnumMessageStatusFilter<"messages"> | $Enums.MessageStatus
    MessageMedia?: MessageMediaListRelationFilter
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _count?: messagesCountOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"messages"> | string
    chatId?: StringWithAggregatesFilter<"messages"> | string
    userId?: StringWithAggregatesFilter<"messages"> | string
    content?: StringWithAggregatesFilter<"messages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"messages"> | Date | string
    status?: EnumMessageStatusWithAggregatesFilter<"messages"> | $Enums.MessageStatus
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    content?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    tweetId?: StringNullableFilter<"notifications"> | string | null
    actorId?: StringNullableFilter<"notifications"> | string | null
    users_notifications_actorIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    tweets?: XOR<TweetsNullableScalarRelationFilter, tweetsWhereInput> | null
    users_notifications_userIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    users_notifications_actorIdTousers?: usersOrderByWithRelationInput
    tweets?: tweetsOrderByWithRelationInput
    users_notifications_userIdTousers?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    content?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    tweetId?: StringNullableFilter<"notifications"> | string | null
    actorId?: StringNullableFilter<"notifications"> | string | null
    users_notifications_actorIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    tweets?: XOR<TweetsNullableScalarRelationFilter, tweetsWhereInput> | null
    users_notifications_userIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"notifications"> | $Enums.NotificationType
    content?: StringWithAggregatesFilter<"notifications"> | string
    isRead?: BoolWithAggregatesFilter<"notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    tweetId?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    actorId?: StringNullableWithAggregatesFilter<"notifications"> | string | null
  }

  export type spatial_ref_sysWhereInput = {
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    srid?: IntFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }

  export type spatial_ref_sysOrderByWithRelationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
  }

  export type spatial_ref_sysWhereUniqueInput = Prisma.AtLeast<{
    srid?: number
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }, "srid">

  export type spatial_ref_sysOrderByWithAggregationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _count?: spatial_ref_sysCountOrderByAggregateInput
    _avg?: spatial_ref_sysAvgOrderByAggregateInput
    _max?: spatial_ref_sysMaxOrderByAggregateInput
    _min?: spatial_ref_sysMinOrderByAggregateInput
    _sum?: spatial_ref_sysSumOrderByAggregateInput
  }

  export type spatial_ref_sysScalarWhereWithAggregatesInput = {
    AND?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    OR?: spatial_ref_sysScalarWhereWithAggregatesInput[]
    NOT?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    srid?: IntWithAggregatesFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableWithAggregatesFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
  }

  export type tweetHashesWhereInput = {
    AND?: tweetHashesWhereInput | tweetHashesWhereInput[]
    OR?: tweetHashesWhereInput[]
    NOT?: tweetHashesWhereInput | tweetHashesWhereInput[]
    tweetId?: StringFilter<"tweetHashes"> | string
    hashId?: StringFilter<"tweetHashes"> | string
    hashes?: XOR<HashesScalarRelationFilter, hashesWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }

  export type tweetHashesOrderByWithRelationInput = {
    tweetId?: SortOrder
    hashId?: SortOrder
    hashes?: hashesOrderByWithRelationInput
    tweets?: tweetsOrderByWithRelationInput
  }

  export type tweetHashesWhereUniqueInput = Prisma.AtLeast<{
    tweetId_hashId?: tweetHashesTweetIdHashIdCompoundUniqueInput
    AND?: tweetHashesWhereInput | tweetHashesWhereInput[]
    OR?: tweetHashesWhereInput[]
    NOT?: tweetHashesWhereInput | tweetHashesWhereInput[]
    tweetId?: StringFilter<"tweetHashes"> | string
    hashId?: StringFilter<"tweetHashes"> | string
    hashes?: XOR<HashesScalarRelationFilter, hashesWhereInput>
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
  }, "tweetId_hashId">

  export type tweetHashesOrderByWithAggregationInput = {
    tweetId?: SortOrder
    hashId?: SortOrder
    _count?: tweetHashesCountOrderByAggregateInput
    _max?: tweetHashesMaxOrderByAggregateInput
    _min?: tweetHashesMinOrderByAggregateInput
  }

  export type tweetHashesScalarWhereWithAggregatesInput = {
    AND?: tweetHashesScalarWhereWithAggregatesInput | tweetHashesScalarWhereWithAggregatesInput[]
    OR?: tweetHashesScalarWhereWithAggregatesInput[]
    NOT?: tweetHashesScalarWhereWithAggregatesInput | tweetHashesScalarWhereWithAggregatesInput[]
    tweetId?: StringWithAggregatesFilter<"tweetHashes"> | string
    hashId?: StringWithAggregatesFilter<"tweetHashes"> | string
  }

  export type tweetbookmarksWhereInput = {
    AND?: tweetbookmarksWhereInput | tweetbookmarksWhereInput[]
    OR?: tweetbookmarksWhereInput[]
    NOT?: tweetbookmarksWhereInput | tweetbookmarksWhereInput[]
    id?: StringFilter<"tweetbookmarks"> | string
    userId?: StringFilter<"tweetbookmarks"> | string
    tweetId?: StringFilter<"tweetbookmarks"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type tweetbookmarksOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    tweets?: tweetsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type tweetbookmarksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tweetbookmarksWhereInput | tweetbookmarksWhereInput[]
    OR?: tweetbookmarksWhereInput[]
    NOT?: tweetbookmarksWhereInput | tweetbookmarksWhereInput[]
    userId?: StringFilter<"tweetbookmarks"> | string
    tweetId?: StringFilter<"tweetbookmarks"> | string
    tweets?: XOR<TweetsScalarRelationFilter, tweetsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type tweetbookmarksOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    _count?: tweetbookmarksCountOrderByAggregateInput
    _max?: tweetbookmarksMaxOrderByAggregateInput
    _min?: tweetbookmarksMinOrderByAggregateInput
  }

  export type tweetbookmarksScalarWhereWithAggregatesInput = {
    AND?: tweetbookmarksScalarWhereWithAggregatesInput | tweetbookmarksScalarWhereWithAggregatesInput[]
    OR?: tweetbookmarksScalarWhereWithAggregatesInput[]
    NOT?: tweetbookmarksScalarWhereWithAggregatesInput | tweetbookmarksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tweetbookmarks"> | string
    userId?: StringWithAggregatesFilter<"tweetbookmarks"> | string
    tweetId?: StringWithAggregatesFilter<"tweetbookmarks"> | string
  }

  export type tweetsWhereInput = {
    AND?: tweetsWhereInput | tweetsWhereInput[]
    OR?: tweetsWhereInput[]
    NOT?: tweetsWhereInput | tweetsWhereInput[]
    id?: StringFilter<"tweets"> | string
    userId?: StringFilter<"tweets"> | string
    content?: StringFilter<"tweets"> | string
    createdAt?: DateTimeFilter<"tweets"> | Date | string
    likesCount?: IntFilter<"tweets"> | number
    retweetCount?: IntFilter<"tweets"> | number
    repliesCount?: IntFilter<"tweets"> | number
    parentId?: StringNullableFilter<"tweets"> | string | null
    tweetType?: EnumTweetTypeFilter<"tweets"> | $Enums.TweetType
    replyControl?: EnumReplyControlFilter<"tweets"> | $Enums.ReplyControl
    Mention?: MentionListRelationFilter
    Retweet?: RetweetListRelationFilter
    TweetLike?: TweetLikeListRelationFilter
    TweetMedia?: TweetMediaListRelationFilter
    TweetSummary?: XOR<TweetSummaryNullableScalarRelationFilter, TweetSummaryWhereInput> | null
    notifications?: NotificationsListRelationFilter
    tweetHashes?: TweetHashesListRelationFilter
    tweetbookmarks?: TweetbookmarksListRelationFilter
    tweets?: XOR<TweetsNullableScalarRelationFilter, tweetsWhereInput> | null
    other_tweets?: TweetsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type tweetsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
    parentId?: SortOrderInput | SortOrder
    tweetType?: SortOrder
    replyControl?: SortOrder
    Mention?: MentionOrderByRelationAggregateInput
    Retweet?: RetweetOrderByRelationAggregateInput
    TweetLike?: TweetLikeOrderByRelationAggregateInput
    TweetMedia?: TweetMediaOrderByRelationAggregateInput
    TweetSummary?: TweetSummaryOrderByWithRelationInput
    notifications?: notificationsOrderByRelationAggregateInput
    tweetHashes?: tweetHashesOrderByRelationAggregateInput
    tweetbookmarks?: tweetbookmarksOrderByRelationAggregateInput
    tweets?: tweetsOrderByWithRelationInput
    other_tweets?: tweetsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type tweetsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tweetsWhereInput | tweetsWhereInput[]
    OR?: tweetsWhereInput[]
    NOT?: tweetsWhereInput | tweetsWhereInput[]
    userId?: StringFilter<"tweets"> | string
    content?: StringFilter<"tweets"> | string
    createdAt?: DateTimeFilter<"tweets"> | Date | string
    likesCount?: IntFilter<"tweets"> | number
    retweetCount?: IntFilter<"tweets"> | number
    repliesCount?: IntFilter<"tweets"> | number
    parentId?: StringNullableFilter<"tweets"> | string | null
    tweetType?: EnumTweetTypeFilter<"tweets"> | $Enums.TweetType
    replyControl?: EnumReplyControlFilter<"tweets"> | $Enums.ReplyControl
    Mention?: MentionListRelationFilter
    Retweet?: RetweetListRelationFilter
    TweetLike?: TweetLikeListRelationFilter
    TweetMedia?: TweetMediaListRelationFilter
    TweetSummary?: XOR<TweetSummaryNullableScalarRelationFilter, TweetSummaryWhereInput> | null
    notifications?: NotificationsListRelationFilter
    tweetHashes?: TweetHashesListRelationFilter
    tweetbookmarks?: TweetbookmarksListRelationFilter
    tweets?: XOR<TweetsNullableScalarRelationFilter, tweetsWhereInput> | null
    other_tweets?: TweetsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type tweetsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
    parentId?: SortOrderInput | SortOrder
    tweetType?: SortOrder
    replyControl?: SortOrder
    _count?: tweetsCountOrderByAggregateInput
    _avg?: tweetsAvgOrderByAggregateInput
    _max?: tweetsMaxOrderByAggregateInput
    _min?: tweetsMinOrderByAggregateInput
    _sum?: tweetsSumOrderByAggregateInput
  }

  export type tweetsScalarWhereWithAggregatesInput = {
    AND?: tweetsScalarWhereWithAggregatesInput | tweetsScalarWhereWithAggregatesInput[]
    OR?: tweetsScalarWhereWithAggregatesInput[]
    NOT?: tweetsScalarWhereWithAggregatesInput | tweetsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tweets"> | string
    userId?: StringWithAggregatesFilter<"tweets"> | string
    content?: StringWithAggregatesFilter<"tweets"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tweets"> | Date | string
    likesCount?: IntWithAggregatesFilter<"tweets"> | number
    retweetCount?: IntWithAggregatesFilter<"tweets"> | number
    repliesCount?: IntWithAggregatesFilter<"tweets"> | number
    parentId?: StringNullableWithAggregatesFilter<"tweets"> | string | null
    tweetType?: EnumTweetTypeWithAggregatesFilter<"tweets"> | $Enums.TweetType
    replyControl?: EnumReplyControlWithAggregatesFilter<"tweets"> | $Enums.ReplyControl
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    is_email_verified?: BoolFilter<"users"> | boolean
    password?: StringFilter<"users"> | string
    saltPassword?: StringFilter<"users"> | string
    otp?: IntNullableFilter<"users"> | number | null
    otpExpiry?: DateTimeNullableFilter<"users"> | Date | string | null
    tfa_verifed?: BoolFilter<"users"> | boolean
    bio?: StringNullableFilter<"users"> | string | null
    dateOfBirth?: DateTimeFilter<"users"> | Date | string
    joinDate?: DateTimeFilter<"users"> | Date | string
    verified?: BoolFilter<"users"> | boolean
    address?: StringNullableFilter<"users"> | string | null
    website?: StringNullableFilter<"users"> | string | null
    protectedAccount?: BoolFilter<"users"> | boolean
    profilePhoto?: StringNullableFilter<"users"> | string | null
    cover?: StringNullableFilter<"users"> | string | null
    provider?: StringNullableFilter<"users"> | string | null
    login_codes?: StringNullableFilter<"users"> | string | null
    login_codes_set?: BoolFilter<"users"> | boolean
    device_record?: DeviceRecordListRelationFilter
    old_passwords?: OldPasswordListRelationFilter
    Block_Block_blockedIdTousers?: BlockListRelationFilter
    Block_Block_blockerIdTousers?: BlockListRelationFilter
    Follow_Follow_followerIdTousers?: FollowListRelationFilter
    Follow_Follow_followingIdTousers?: FollowListRelationFilter
    Mention_Mention_mentionedIdTousers?: MentionListRelationFilter
    Mention_Mention_mentionerIdTousers?: MentionListRelationFilter
    Mute_Mute_mutedIdTousers?: MuteListRelationFilter
    Mute_Mute_muterIdTousers?: MuteListRelationFilter
    Retweet?: RetweetListRelationFilter
    TweetLike?: TweetLikeListRelationFilter
    chatusers?: ChatusersListRelationFilter
    messages?: MessagesListRelationFilter
    notifications_notifications_actorIdTousers?: NotificationsListRelationFilter
    notifications_notifications_userIdTousers?: NotificationsListRelationFilter
    tweetbookmarks?: TweetbookmarksListRelationFilter
    tweets?: TweetsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    is_email_verified?: SortOrder
    password?: SortOrder
    saltPassword?: SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiry?: SortOrderInput | SortOrder
    tfa_verifed?: SortOrder
    bio?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    joinDate?: SortOrder
    verified?: SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    protectedAccount?: SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    login_codes?: SortOrderInput | SortOrder
    login_codes_set?: SortOrder
    device_record?: DeviceRecordOrderByRelationAggregateInput
    old_passwords?: OldPasswordOrderByRelationAggregateInput
    Block_Block_blockedIdTousers?: BlockOrderByRelationAggregateInput
    Block_Block_blockerIdTousers?: BlockOrderByRelationAggregateInput
    Follow_Follow_followerIdTousers?: FollowOrderByRelationAggregateInput
    Follow_Follow_followingIdTousers?: FollowOrderByRelationAggregateInput
    Mention_Mention_mentionedIdTousers?: MentionOrderByRelationAggregateInput
    Mention_Mention_mentionerIdTousers?: MentionOrderByRelationAggregateInput
    Mute_Mute_mutedIdTousers?: MuteOrderByRelationAggregateInput
    Mute_Mute_muterIdTousers?: MuteOrderByRelationAggregateInput
    Retweet?: RetweetOrderByRelationAggregateInput
    TweetLike?: TweetLikeOrderByRelationAggregateInput
    chatusers?: chatusersOrderByRelationAggregateInput
    messages?: messagesOrderByRelationAggregateInput
    notifications_notifications_actorIdTousers?: notificationsOrderByRelationAggregateInput
    notifications_notifications_userIdTousers?: notificationsOrderByRelationAggregateInput
    tweetbookmarks?: tweetbookmarksOrderByRelationAggregateInput
    tweets?: tweetsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    is_email_verified?: BoolFilter<"users"> | boolean
    password?: StringFilter<"users"> | string
    saltPassword?: StringFilter<"users"> | string
    otp?: IntNullableFilter<"users"> | number | null
    otpExpiry?: DateTimeNullableFilter<"users"> | Date | string | null
    tfa_verifed?: BoolFilter<"users"> | boolean
    bio?: StringNullableFilter<"users"> | string | null
    dateOfBirth?: DateTimeFilter<"users"> | Date | string
    joinDate?: DateTimeFilter<"users"> | Date | string
    verified?: BoolFilter<"users"> | boolean
    address?: StringNullableFilter<"users"> | string | null
    website?: StringNullableFilter<"users"> | string | null
    protectedAccount?: BoolFilter<"users"> | boolean
    profilePhoto?: StringNullableFilter<"users"> | string | null
    cover?: StringNullableFilter<"users"> | string | null
    provider?: StringNullableFilter<"users"> | string | null
    login_codes?: StringNullableFilter<"users"> | string | null
    login_codes_set?: BoolFilter<"users"> | boolean
    device_record?: DeviceRecordListRelationFilter
    old_passwords?: OldPasswordListRelationFilter
    Block_Block_blockedIdTousers?: BlockListRelationFilter
    Block_Block_blockerIdTousers?: BlockListRelationFilter
    Follow_Follow_followerIdTousers?: FollowListRelationFilter
    Follow_Follow_followingIdTousers?: FollowListRelationFilter
    Mention_Mention_mentionedIdTousers?: MentionListRelationFilter
    Mention_Mention_mentionerIdTousers?: MentionListRelationFilter
    Mute_Mute_mutedIdTousers?: MuteListRelationFilter
    Mute_Mute_muterIdTousers?: MuteListRelationFilter
    Retweet?: RetweetListRelationFilter
    TweetLike?: TweetLikeListRelationFilter
    chatusers?: ChatusersListRelationFilter
    messages?: MessagesListRelationFilter
    notifications_notifications_actorIdTousers?: NotificationsListRelationFilter
    notifications_notifications_userIdTousers?: NotificationsListRelationFilter
    tweetbookmarks?: TweetbookmarksListRelationFilter
    tweets?: TweetsListRelationFilter
  }, "id" | "username" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    is_email_verified?: SortOrder
    password?: SortOrder
    saltPassword?: SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiry?: SortOrderInput | SortOrder
    tfa_verifed?: SortOrder
    bio?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrder
    joinDate?: SortOrder
    verified?: SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    protectedAccount?: SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    cover?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    login_codes?: SortOrderInput | SortOrder
    login_codes_set?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    is_email_verified?: BoolWithAggregatesFilter<"users"> | boolean
    password?: StringWithAggregatesFilter<"users"> | string
    saltPassword?: StringWithAggregatesFilter<"users"> | string
    otp?: IntNullableWithAggregatesFilter<"users"> | number | null
    otpExpiry?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    tfa_verifed?: BoolWithAggregatesFilter<"users"> | boolean
    bio?: StringNullableWithAggregatesFilter<"users"> | string | null
    dateOfBirth?: DateTimeWithAggregatesFilter<"users"> | Date | string
    joinDate?: DateTimeWithAggregatesFilter<"users"> | Date | string
    verified?: BoolWithAggregatesFilter<"users"> | boolean
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    website?: StringNullableWithAggregatesFilter<"users"> | string | null
    protectedAccount?: BoolWithAggregatesFilter<"users"> | boolean
    profilePhoto?: StringNullableWithAggregatesFilter<"users"> | string | null
    cover?: StringNullableWithAggregatesFilter<"users"> | string | null
    provider?: StringNullableWithAggregatesFilter<"users"> | string | null
    login_codes?: StringNullableWithAggregatesFilter<"users"> | string | null
    login_codes_set?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type DeviceRecordWhereInput = {
    AND?: DeviceRecordWhereInput | DeviceRecordWhereInput[]
    OR?: DeviceRecordWhereInput[]
    NOT?: DeviceRecordWhereInput | DeviceRecordWhereInput[]
    id?: IntFilter<"DeviceRecord"> | number
    userid?: StringFilter<"DeviceRecord"> | string
    city?: StringNullableFilter<"DeviceRecord"> | string | null
    region?: StringNullableFilter<"DeviceRecord"> | string | null
    country?: StringNullableFilter<"DeviceRecord"> | string | null
    locale?: StringNullableFilter<"DeviceRecord"> | string | null
    lat?: FloatNullableFilter<"DeviceRecord"> | number | null
    lon?: FloatNullableFilter<"DeviceRecord"> | number | null
    zipcode?: StringNullableFilter<"DeviceRecord"> | string | null
    last_login?: DateTimeNullableFilter<"DeviceRecord"> | Date | string | null
    browser?: StringNullableFilter<"DeviceRecord"> | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type DeviceRecordOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type DeviceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceRecordWhereInput | DeviceRecordWhereInput[]
    OR?: DeviceRecordWhereInput[]
    NOT?: DeviceRecordWhereInput | DeviceRecordWhereInput[]
    userid?: StringFilter<"DeviceRecord"> | string
    city?: StringNullableFilter<"DeviceRecord"> | string | null
    region?: StringNullableFilter<"DeviceRecord"> | string | null
    country?: StringNullableFilter<"DeviceRecord"> | string | null
    locale?: StringNullableFilter<"DeviceRecord"> | string | null
    lat?: FloatNullableFilter<"DeviceRecord"> | number | null
    lon?: FloatNullableFilter<"DeviceRecord"> | number | null
    zipcode?: StringNullableFilter<"DeviceRecord"> | string | null
    last_login?: DateTimeNullableFilter<"DeviceRecord"> | Date | string | null
    browser?: StringNullableFilter<"DeviceRecord"> | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type DeviceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    _count?: DeviceRecordCountOrderByAggregateInput
    _avg?: DeviceRecordAvgOrderByAggregateInput
    _max?: DeviceRecordMaxOrderByAggregateInput
    _min?: DeviceRecordMinOrderByAggregateInput
    _sum?: DeviceRecordSumOrderByAggregateInput
  }

  export type DeviceRecordScalarWhereWithAggregatesInput = {
    AND?: DeviceRecordScalarWhereWithAggregatesInput | DeviceRecordScalarWhereWithAggregatesInput[]
    OR?: DeviceRecordScalarWhereWithAggregatesInput[]
    NOT?: DeviceRecordScalarWhereWithAggregatesInput | DeviceRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceRecord"> | number
    userid?: StringWithAggregatesFilter<"DeviceRecord"> | string
    city?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
    region?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
    country?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
    locale?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"DeviceRecord"> | number | null
    lon?: FloatNullableWithAggregatesFilter<"DeviceRecord"> | number | null
    zipcode?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
    last_login?: DateTimeNullableWithAggregatesFilter<"DeviceRecord"> | Date | string | null
    browser?: StringNullableWithAggregatesFilter<"DeviceRecord"> | string | null
  }

  export type OldPasswordWhereInput = {
    AND?: OldPasswordWhereInput | OldPasswordWhereInput[]
    OR?: OldPasswordWhereInput[]
    NOT?: OldPasswordWhereInput | OldPasswordWhereInput[]
    id?: IntFilter<"OldPassword"> | number
    user_id?: StringFilter<"OldPassword"> | string
    password?: StringFilter<"OldPassword"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type OldPasswordOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    password?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type OldPasswordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OldPasswordWhereInput | OldPasswordWhereInput[]
    OR?: OldPasswordWhereInput[]
    NOT?: OldPasswordWhereInput | OldPasswordWhereInput[]
    user_id?: StringFilter<"OldPassword"> | string
    password?: StringFilter<"OldPassword"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type OldPasswordOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    password?: SortOrder
    _count?: OldPasswordCountOrderByAggregateInput
    _avg?: OldPasswordAvgOrderByAggregateInput
    _max?: OldPasswordMaxOrderByAggregateInput
    _min?: OldPasswordMinOrderByAggregateInput
    _sum?: OldPasswordSumOrderByAggregateInput
  }

  export type OldPasswordScalarWhereWithAggregatesInput = {
    AND?: OldPasswordScalarWhereWithAggregatesInput | OldPasswordScalarWhereWithAggregatesInput[]
    OR?: OldPasswordScalarWhereWithAggregatesInput[]
    NOT?: OldPasswordScalarWhereWithAggregatesInput | OldPasswordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OldPassword"> | number
    user_id?: StringWithAggregatesFilter<"OldPassword"> | string
    password?: StringWithAggregatesFilter<"OldPassword"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    jti?: StringFilter<"Session"> | string
    user_id?: IntFilter<"Session"> | number
    is_active?: BoolFilter<"Session"> | boolean
    issued_at?: DateTimeFilter<"Session"> | Date | string
    device_info_id?: IntNullableFilter<"Session"> | number | null
    expire_at?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type SessionOrderByWithRelationInput = {
    jti?: SortOrder
    user_id?: SortOrder
    is_active?: SortOrder
    issued_at?: SortOrder
    device_info_id?: SortOrderInput | SortOrder
    expire_at?: SortOrderInput | SortOrder
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    jti?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    user_id?: IntFilter<"Session"> | number
    is_active?: BoolFilter<"Session"> | boolean
    issued_at?: DateTimeFilter<"Session"> | Date | string
    device_info_id?: IntNullableFilter<"Session"> | number | null
    expire_at?: DateTimeNullableFilter<"Session"> | Date | string | null
  }, "jti">

  export type SessionOrderByWithAggregationInput = {
    jti?: SortOrder
    user_id?: SortOrder
    is_active?: SortOrder
    issued_at?: SortOrder
    device_info_id?: SortOrderInput | SortOrder
    expire_at?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    jti?: StringWithAggregatesFilter<"Session"> | string
    user_id?: IntWithAggregatesFilter<"Session"> | number
    is_active?: BoolWithAggregatesFilter<"Session"> | boolean
    issued_at?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    device_info_id?: IntNullableWithAggregatesFilter<"Session"> | number | null
    expire_at?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type BlockCreateInput = {
    users_Block_blockedIdTousers: usersCreateNestedOneWithoutBlock_Block_blockedIdTousersInput
    users_Block_blockerIdTousers: usersCreateNestedOneWithoutBlock_Block_blockerIdTousersInput
  }

  export type BlockUncheckedCreateInput = {
    blockedId: string
    blockerId: string
  }

  export type BlockUpdateInput = {
    users_Block_blockedIdTousers?: usersUpdateOneRequiredWithoutBlock_Block_blockedIdTousersNestedInput
    users_Block_blockerIdTousers?: usersUpdateOneRequiredWithoutBlock_Block_blockerIdTousersNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    blockedId?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockCreateManyInput = {
    blockedId: string
    blockerId: string
  }

  export type BlockUpdateManyMutationInput = {

  }

  export type BlockUncheckedUpdateManyInput = {
    blockedId?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type FollowCreateInput = {
    status?: $Enums.FollowStatus
    users_Follow_followerIdTousers: usersCreateNestedOneWithoutFollow_Follow_followerIdTousersInput
    users_Follow_followingIdTousers: usersCreateNestedOneWithoutFollow_Follow_followingIdTousersInput
  }

  export type FollowUncheckedCreateInput = {
    followerId: string
    followingId: string
    status?: $Enums.FollowStatus
  }

  export type FollowUpdateInput = {
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
    users_Follow_followerIdTousers?: usersUpdateOneRequiredWithoutFollow_Follow_followerIdTousersNestedInput
    users_Follow_followingIdTousers?: usersUpdateOneRequiredWithoutFollow_Follow_followingIdTousersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type FollowCreateManyInput = {
    followerId: string
    followingId: string
    status?: $Enums.FollowStatus
  }

  export type FollowUpdateManyMutationInput = {
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type FollowUncheckedUpdateManyInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type MentionCreateInput = {
    users_Mention_mentionedIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionedIdTousersInput
    users_Mention_mentionerIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionerIdTousersInput
    tweets: tweetsCreateNestedOneWithoutMentionInput
  }

  export type MentionUncheckedCreateInput = {
    tweetId: string
    mentionerId: string
    mentionedId: string
  }

  export type MentionUpdateInput = {
    users_Mention_mentionedIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionedIdTousersNestedInput
    users_Mention_mentionerIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionerIdTousersNestedInput
    tweets?: tweetsUpdateOneRequiredWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionerId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionCreateManyInput = {
    tweetId: string
    mentionerId: string
    mentionedId: string
  }

  export type MentionUpdateManyMutationInput = {

  }

  export type MentionUncheckedUpdateManyInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionerId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaCreateInput = {
    medias: mediasCreateNestedOneWithoutMessageMediaInput
    messages: messagesCreateNestedOneWithoutMessageMediaInput
  }

  export type MessageMediaUncheckedCreateInput = {
    messageId: string
    mediaId: string
  }

  export type MessageMediaUpdateInput = {
    medias?: mediasUpdateOneRequiredWithoutMessageMediaNestedInput
    messages?: messagesUpdateOneRequiredWithoutMessageMediaNestedInput
  }

  export type MessageMediaUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaCreateManyInput = {
    messageId: string
    mediaId: string
  }

  export type MessageMediaUpdateManyMutationInput = {

  }

  export type MessageMediaUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteCreateInput = {
    users_Mute_mutedIdTousers: usersCreateNestedOneWithoutMute_Mute_mutedIdTousersInput
    users_Mute_muterIdTousers: usersCreateNestedOneWithoutMute_Mute_muterIdTousersInput
  }

  export type MuteUncheckedCreateInput = {
    mutedId: string
    muterId: string
  }

  export type MuteUpdateInput = {
    users_Mute_mutedIdTousers?: usersUpdateOneRequiredWithoutMute_Mute_mutedIdTousersNestedInput
    users_Mute_muterIdTousers?: usersUpdateOneRequiredWithoutMute_Mute_muterIdTousersNestedInput
  }

  export type MuteUncheckedUpdateInput = {
    mutedId?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteCreateManyInput = {
    mutedId: string
    muterId: string
  }

  export type MuteUpdateManyMutationInput = {

  }

  export type MuteUncheckedUpdateManyInput = {
    mutedId?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetCreateInput = {
    tweets: tweetsCreateNestedOneWithoutRetweetInput
    users: usersCreateNestedOneWithoutRetweetInput
  }

  export type RetweetUncheckedCreateInput = {
    userId: string
    tweetId: string
  }

  export type RetweetUpdateInput = {
    tweets?: tweetsUpdateOneRequiredWithoutRetweetNestedInput
    users?: usersUpdateOneRequiredWithoutRetweetNestedInput
  }

  export type RetweetUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetCreateManyInput = {
    userId: string
    tweetId: string
  }

  export type RetweetUpdateManyMutationInput = {

  }

  export type RetweetUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeCreateInput = {
    tweets: tweetsCreateNestedOneWithoutTweetLikeInput
    users: usersCreateNestedOneWithoutTweetLikeInput
  }

  export type TweetLikeUncheckedCreateInput = {
    tweetId: string
    userId: string
  }

  export type TweetLikeUpdateInput = {
    tweets?: tweetsUpdateOneRequiredWithoutTweetLikeNestedInput
    users?: usersUpdateOneRequiredWithoutTweetLikeNestedInput
  }

  export type TweetLikeUncheckedUpdateInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeCreateManyInput = {
    tweetId: string
    userId: string
  }

  export type TweetLikeUpdateManyMutationInput = {

  }

  export type TweetLikeUncheckedUpdateManyInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaCreateInput = {
    medias: mediasCreateNestedOneWithoutTweetMediaInput
    tweets: tweetsCreateNestedOneWithoutTweetMediaInput
  }

  export type TweetMediaUncheckedCreateInput = {
    tweetId: string
    mediaId: string
  }

  export type TweetMediaUpdateInput = {
    medias?: mediasUpdateOneRequiredWithoutTweetMediaNestedInput
    tweets?: tweetsUpdateOneRequiredWithoutTweetMediaNestedInput
  }

  export type TweetMediaUncheckedUpdateInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaCreateManyInput = {
    tweetId: string
    mediaId: string
  }

  export type TweetMediaUpdateManyMutationInput = {

  }

  export type TweetMediaUncheckedUpdateManyInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetSummaryCreateInput = {
    id: string
    summary: string
    tweets: tweetsCreateNestedOneWithoutTweetSummaryInput
  }

  export type TweetSummaryUncheckedCreateInput = {
    id: string
    tweetId: string
    summary: string
  }

  export type TweetSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    tweets?: tweetsUpdateOneRequiredWithoutTweetSummaryNestedInput
  }

  export type TweetSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
  }

  export type TweetSummaryCreateManyInput = {
    id: string
    tweetId: string
    summary: string
  }

  export type TweetSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
  }

  export type TweetSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
  }

  export type chatGroupsCreateInput = {
    name?: string | null
    description?: string | null
    photo?: string | null
    chats: chatsCreateNestedOneWithoutChatGroupsInput
  }

  export type chatGroupsUncheckedCreateInput = {
    name?: string | null
    description?: string | null
    photo?: string | null
    chatId: string
  }

  export type chatGroupsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: chatsUpdateOneRequiredWithoutChatGroupsNestedInput
  }

  export type chatGroupsUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type chatGroupsCreateManyInput = {
    name?: string | null
    description?: string | null
    photo?: string | null
    chatId: string
  }

  export type chatGroupsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatGroupsUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type chatsCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsCreateNestedOneWithoutChatsInput
    chatusers?: chatusersCreateNestedManyWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsUncheckedCreateNestedOneWithoutChatsInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUpdateOneWithoutChatsNestedInput
    chatusers?: chatusersUpdateManyWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUncheckedUpdateOneWithoutChatsNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type chatsCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
  }

  export type chatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chatusersCreateInput = {
    id: string
    chats: chatsCreateNestedOneWithoutChatusersInput
    users: usersCreateNestedOneWithoutChatusersInput
  }

  export type chatusersUncheckedCreateInput = {
    id: string
    userId: string
    chatId: string
  }

  export type chatusersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chats?: chatsUpdateOneRequiredWithoutChatusersNestedInput
    users?: usersUpdateOneRequiredWithoutChatusersNestedInput
  }

  export type chatusersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type chatusersCreateManyInput = {
    id: string
    userId: string
    chatId: string
  }

  export type chatusersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type chatusersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type hashesCreateInput = {
    id: string
    tag_text: string
    tweetHashes?: tweetHashesCreateNestedManyWithoutHashesInput
  }

  export type hashesUncheckedCreateInput = {
    id: string
    tag_text: string
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutHashesInput
  }

  export type hashesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
    tweetHashes?: tweetHashesUpdateManyWithoutHashesNestedInput
  }

  export type hashesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutHashesNestedInput
  }

  export type hashesCreateManyInput = {
    id: string
    tag_text: string
  }

  export type hashesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
  }

  export type hashesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
  }

  export type mediasCreateInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    MessageMedia?: MessageMediaCreateNestedManyWithoutMediasInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutMediasInput
  }

  export type mediasUncheckedCreateInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    MessageMedia?: MessageMediaUncheckedCreateNestedManyWithoutMediasInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutMediasInput
  }

  export type mediasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    MessageMedia?: MessageMediaUpdateManyWithoutMediasNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutMediasNestedInput
  }

  export type mediasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    MessageMedia?: MessageMediaUncheckedUpdateManyWithoutMediasNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutMediasNestedInput
  }

  export type mediasCreateManyInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
  }

  export type mediasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mediasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type messagesCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaCreateNestedManyWithoutMessagesInput
    chats: chatsCreateNestedOneWithoutMessagesInput
    users: usersCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateInput = {
    id: string
    chatId: string
    userId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUpdateManyWithoutMessagesNestedInput
    chats?: chatsUpdateOneRequiredWithoutMessagesNestedInput
    users?: usersUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesCreateManyInput = {
    id: string
    chatId: string
    userId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
  }

  export type messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
  }

  export type notificationsCreateInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    users_notifications_actorIdTousers?: usersCreateNestedOneWithoutNotifications_notifications_actorIdTousersInput
    tweets?: tweetsCreateNestedOneWithoutNotificationsInput
    users_notifications_userIdTousers: usersCreateNestedOneWithoutNotifications_notifications_userIdTousersInput
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    tweetId?: string | null
    actorId?: string | null
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_notifications_actorIdTousers?: usersUpdateOneWithoutNotifications_notifications_actorIdTousersNestedInput
    tweets?: tweetsUpdateOneWithoutNotificationsNestedInput
    users_notifications_userIdTousers?: usersUpdateOneRequiredWithoutNotifications_notifications_userIdTousersNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsCreateManyInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    tweetId?: string | null
    actorId?: string | null
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUncheckedCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateManyInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateManyMutationInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateManyInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tweetHashesCreateInput = {
    hashes: hashesCreateNestedOneWithoutTweetHashesInput
    tweets: tweetsCreateNestedOneWithoutTweetHashesInput
  }

  export type tweetHashesUncheckedCreateInput = {
    tweetId: string
    hashId: string
  }

  export type tweetHashesUpdateInput = {
    hashes?: hashesUpdateOneRequiredWithoutTweetHashesNestedInput
    tweets?: tweetsUpdateOneRequiredWithoutTweetHashesNestedInput
  }

  export type tweetHashesUncheckedUpdateInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    hashId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetHashesCreateManyInput = {
    tweetId: string
    hashId: string
  }

  export type tweetHashesUpdateManyMutationInput = {

  }

  export type tweetHashesUncheckedUpdateManyInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    hashId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksCreateInput = {
    id: string
    tweets: tweetsCreateNestedOneWithoutTweetbookmarksInput
    users: usersCreateNestedOneWithoutTweetbookmarksInput
  }

  export type tweetbookmarksUncheckedCreateInput = {
    id: string
    userId: string
    tweetId: string
  }

  export type tweetbookmarksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweets?: tweetsUpdateOneRequiredWithoutTweetbookmarksNestedInput
    users?: usersUpdateOneRequiredWithoutTweetbookmarksNestedInput
  }

  export type tweetbookmarksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksCreateManyInput = {
    id: string
    userId: string
    tweetId: string
  }

  export type tweetbookmarksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetsCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsCreateManyInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
  }

  export type tweetsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
  }

  export type tweetsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
  }

  export type usersCreateInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeviceRecordCreateInput = {
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
    user: usersCreateNestedOneWithoutDevice_recordInput
  }

  export type DeviceRecordUncheckedCreateInput = {
    id?: number
    userid: string
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
  }

  export type DeviceRecordUpdateInput = {
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    user?: usersUpdateOneRequiredWithoutDevice_recordNestedInput
  }

  export type DeviceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceRecordCreateManyInput = {
    id?: number
    userid: string
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
  }

  export type DeviceRecordUpdateManyMutationInput = {
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OldPasswordCreateInput = {
    password: string
    user: usersCreateNestedOneWithoutOld_passwordsInput
  }

  export type OldPasswordUncheckedCreateInput = {
    id?: number
    user_id: string
    password: string
  }

  export type OldPasswordUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutOld_passwordsNestedInput
  }

  export type OldPasswordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OldPasswordCreateManyInput = {
    id?: number
    user_id: string
    password: string
  }

  export type OldPasswordUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OldPasswordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    jti: string
    user_id: number
    is_active?: boolean
    issued_at?: Date | string
    device_info_id?: number | null
    expire_at?: Date | string | null
  }

  export type SessionUncheckedCreateInput = {
    jti: string
    user_id: number
    is_active?: boolean
    issued_at?: Date | string
    device_info_id?: number | null
    expire_at?: Date | string | null
  }

  export type SessionUpdateInput = {
    jti?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    expire_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateInput = {
    jti?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    expire_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    jti: string
    user_id: number
    is_active?: boolean
    issued_at?: Date | string
    device_info_id?: number | null
    expire_at?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    jti?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    expire_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    jti?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    expire_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type BlockBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    blockedId?: SortOrder
    blockerId?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    blockedId?: SortOrder
    blockerId?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    blockedId?: SortOrder
    blockerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumFollowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowStatusFilter<$PrismaModel> | $Enums.FollowStatus
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    status?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    status?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    followerId?: SortOrder
    followingId?: SortOrder
    status?: SortOrder
  }

  export type EnumFollowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowStatusFilter<$PrismaModel>
  }

  export type TweetsScalarRelationFilter = {
    is?: tweetsWhereInput
    isNot?: tweetsWhereInput
  }

  export type MentionTweetIdMentionerIdMentionedIdCompoundUniqueInput = {
    tweetId: string
    mentionerId: string
    mentionedId: string
  }

  export type MentionCountOrderByAggregateInput = {
    tweetId?: SortOrder
    mentionerId?: SortOrder
    mentionedId?: SortOrder
  }

  export type MentionMaxOrderByAggregateInput = {
    tweetId?: SortOrder
    mentionerId?: SortOrder
    mentionedId?: SortOrder
  }

  export type MentionMinOrderByAggregateInput = {
    tweetId?: SortOrder
    mentionerId?: SortOrder
    mentionedId?: SortOrder
  }

  export type MediasScalarRelationFilter = {
    is?: mediasWhereInput
    isNot?: mediasWhereInput
  }

  export type MessagesScalarRelationFilter = {
    is?: messagesWhereInput
    isNot?: messagesWhereInput
  }

  export type MessageMediaMessageIdMediaIdCompoundUniqueInput = {
    messageId: string
    mediaId: string
  }

  export type MessageMediaCountOrderByAggregateInput = {
    messageId?: SortOrder
    mediaId?: SortOrder
  }

  export type MessageMediaMaxOrderByAggregateInput = {
    messageId?: SortOrder
    mediaId?: SortOrder
  }

  export type MessageMediaMinOrderByAggregateInput = {
    messageId?: SortOrder
    mediaId?: SortOrder
  }

  export type MuteMuterIdMutedIdCompoundUniqueInput = {
    muterId: string
    mutedId: string
  }

  export type MuteCountOrderByAggregateInput = {
    mutedId?: SortOrder
    muterId?: SortOrder
  }

  export type MuteMaxOrderByAggregateInput = {
    mutedId?: SortOrder
    muterId?: SortOrder
  }

  export type MuteMinOrderByAggregateInput = {
    mutedId?: SortOrder
    muterId?: SortOrder
  }

  export type RetweetUserIdTweetIdCompoundUniqueInput = {
    userId: string
    tweetId: string
  }

  export type RetweetCountOrderByAggregateInput = {
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type RetweetMaxOrderByAggregateInput = {
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type RetweetMinOrderByAggregateInput = {
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type TweetLikeUserIdTweetIdCompoundUniqueInput = {
    userId: string
    tweetId: string
  }

  export type TweetLikeCountOrderByAggregateInput = {
    tweetId?: SortOrder
    userId?: SortOrder
  }

  export type TweetLikeMaxOrderByAggregateInput = {
    tweetId?: SortOrder
    userId?: SortOrder
  }

  export type TweetLikeMinOrderByAggregateInput = {
    tweetId?: SortOrder
    userId?: SortOrder
  }

  export type TweetMediaTweetIdMediaIdCompoundUniqueInput = {
    tweetId: string
    mediaId: string
  }

  export type TweetMediaCountOrderByAggregateInput = {
    tweetId?: SortOrder
    mediaId?: SortOrder
  }

  export type TweetMediaMaxOrderByAggregateInput = {
    tweetId?: SortOrder
    mediaId?: SortOrder
  }

  export type TweetMediaMinOrderByAggregateInput = {
    tweetId?: SortOrder
    mediaId?: SortOrder
  }

  export type TweetSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    summary?: SortOrder
  }

  export type TweetSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    summary?: SortOrder
  }

  export type TweetSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    summary?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ChatsScalarRelationFilter = {
    is?: chatsWhereInput
    isNot?: chatsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type chatGroupsCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    photo?: SortOrder
    chatId?: SortOrder
  }

  export type chatGroupsMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    photo?: SortOrder
    chatId?: SortOrder
  }

  export type chatGroupsMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    photo?: SortOrder
    chatId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ChatGroupsNullableScalarRelationFilter = {
    is?: chatGroupsWhereInput | null
    isNot?: chatGroupsWhereInput | null
  }

  export type ChatusersListRelationFilter = {
    every?: chatusersWhereInput
    some?: chatusersWhereInput
    none?: chatusersWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type chatusersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DMChat?: SortOrder
  }

  export type chatsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DMChat?: SortOrder
  }

  export type chatsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DMChat?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type chatusersUserIdChatIdCompoundUniqueInput = {
    userId: string
    chatId: string
  }

  export type chatusersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
  }

  export type chatusersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
  }

  export type chatusersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
  }

  export type TweetHashesListRelationFilter = {
    every?: tweetHashesWhereInput
    some?: tweetHashesWhereInput
    none?: tweetHashesWhereInput
  }

  export type tweetHashesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type hashesCountOrderByAggregateInput = {
    id?: SortOrder
    tag_text?: SortOrder
  }

  export type hashesMaxOrderByAggregateInput = {
    id?: SortOrder
    tag_text?: SortOrder
  }

  export type hashesMinOrderByAggregateInput = {
    id?: SortOrder
    tag_text?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MessageMediaListRelationFilter = {
    every?: MessageMediaWhereInput
    some?: MessageMediaWhereInput
    none?: MessageMediaWhereInput
  }

  export type TweetMediaListRelationFilter = {
    every?: TweetMediaWhereInput
    some?: TweetMediaWhereInput
    none?: TweetMediaWhereInput
  }

  export type MessageMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mediasCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
  }

  export type mediasAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type mediasMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
  }

  export type mediasMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
  }

  export type mediasSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type TweetsNullableScalarRelationFilter = {
    is?: tweetsWhereInput | null
    isNot?: tweetsWhereInput | null
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    actorId?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    actorId?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    actorId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type spatial_ref_sysCountOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysAvgOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type spatial_ref_sysMaxOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysMinOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysSumOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type HashesScalarRelationFilter = {
    is?: hashesWhereInput
    isNot?: hashesWhereInput
  }

  export type tweetHashesTweetIdHashIdCompoundUniqueInput = {
    tweetId: string
    hashId: string
  }

  export type tweetHashesCountOrderByAggregateInput = {
    tweetId?: SortOrder
    hashId?: SortOrder
  }

  export type tweetHashesMaxOrderByAggregateInput = {
    tweetId?: SortOrder
    hashId?: SortOrder
  }

  export type tweetHashesMinOrderByAggregateInput = {
    tweetId?: SortOrder
    hashId?: SortOrder
  }

  export type tweetbookmarksCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type tweetbookmarksMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type tweetbookmarksMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
  }

  export type EnumTweetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TweetType | EnumTweetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTweetTypeFilter<$PrismaModel> | $Enums.TweetType
  }

  export type EnumReplyControlFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyControl | EnumReplyControlFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyControlFilter<$PrismaModel> | $Enums.ReplyControl
  }

  export type MentionListRelationFilter = {
    every?: MentionWhereInput
    some?: MentionWhereInput
    none?: MentionWhereInput
  }

  export type RetweetListRelationFilter = {
    every?: RetweetWhereInput
    some?: RetweetWhereInput
    none?: RetweetWhereInput
  }

  export type TweetLikeListRelationFilter = {
    every?: TweetLikeWhereInput
    some?: TweetLikeWhereInput
    none?: TweetLikeWhereInput
  }

  export type TweetSummaryNullableScalarRelationFilter = {
    is?: TweetSummaryWhereInput | null
    isNot?: TweetSummaryWhereInput | null
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type TweetbookmarksListRelationFilter = {
    every?: tweetbookmarksWhereInput
    some?: tweetbookmarksWhereInput
    none?: tweetbookmarksWhereInput
  }

  export type TweetsListRelationFilter = {
    every?: tweetsWhereInput
    some?: tweetsWhereInput
    none?: tweetsWhereInput
  }

  export type MentionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RetweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tweetbookmarksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tweetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tweetsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
    parentId?: SortOrder
    tweetType?: SortOrder
    replyControl?: SortOrder
  }

  export type tweetsAvgOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
  }

  export type tweetsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
    parentId?: SortOrder
    tweetType?: SortOrder
    replyControl?: SortOrder
  }

  export type tweetsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
    parentId?: SortOrder
    tweetType?: SortOrder
    replyControl?: SortOrder
  }

  export type tweetsSumOrderByAggregateInput = {
    likesCount?: SortOrder
    retweetCount?: SortOrder
    repliesCount?: SortOrder
  }

  export type EnumTweetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TweetType | EnumTweetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTweetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TweetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTweetTypeFilter<$PrismaModel>
    _max?: NestedEnumTweetTypeFilter<$PrismaModel>
  }

  export type EnumReplyControlWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyControl | EnumReplyControlFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyControlWithAggregatesFilter<$PrismaModel> | $Enums.ReplyControl
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplyControlFilter<$PrismaModel>
    _max?: NestedEnumReplyControlFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DeviceRecordListRelationFilter = {
    every?: DeviceRecordWhereInput
    some?: DeviceRecordWhereInput
    none?: DeviceRecordWhereInput
  }

  export type OldPasswordListRelationFilter = {
    every?: OldPasswordWhereInput
    some?: OldPasswordWhereInput
    none?: OldPasswordWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type MuteListRelationFilter = {
    every?: MuteWhereInput
    some?: MuteWhereInput
    none?: MuteWhereInput
  }

  export type DeviceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OldPasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    is_email_verified?: SortOrder
    password?: SortOrder
    saltPassword?: SortOrder
    otp?: SortOrder
    otpExpiry?: SortOrder
    tfa_verifed?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    joinDate?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    website?: SortOrder
    protectedAccount?: SortOrder
    profilePhoto?: SortOrder
    cover?: SortOrder
    provider?: SortOrder
    login_codes?: SortOrder
    login_codes_set?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    is_email_verified?: SortOrder
    password?: SortOrder
    saltPassword?: SortOrder
    otp?: SortOrder
    otpExpiry?: SortOrder
    tfa_verifed?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    joinDate?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    website?: SortOrder
    protectedAccount?: SortOrder
    profilePhoto?: SortOrder
    cover?: SortOrder
    provider?: SortOrder
    login_codes?: SortOrder
    login_codes_set?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    is_email_verified?: SortOrder
    password?: SortOrder
    saltPassword?: SortOrder
    otp?: SortOrder
    otpExpiry?: SortOrder
    tfa_verifed?: SortOrder
    bio?: SortOrder
    dateOfBirth?: SortOrder
    joinDate?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    website?: SortOrder
    protectedAccount?: SortOrder
    profilePhoto?: SortOrder
    cover?: SortOrder
    provider?: SortOrder
    login_codes?: SortOrder
    login_codes_set?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DeviceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    zipcode?: SortOrder
    last_login?: SortOrder
    browser?: SortOrder
  }

  export type DeviceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type DeviceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    zipcode?: SortOrder
    last_login?: SortOrder
    browser?: SortOrder
  }

  export type DeviceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    locale?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    zipcode?: SortOrder
    last_login?: SortOrder
    browser?: SortOrder
  }

  export type DeviceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type OldPasswordCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    password?: SortOrder
  }

  export type OldPasswordAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OldPasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    password?: SortOrder
  }

  export type OldPasswordMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    password?: SortOrder
  }

  export type OldPasswordSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    jti?: SortOrder
    user_id?: SortOrder
    is_active?: SortOrder
    issued_at?: SortOrder
    device_info_id?: SortOrder
    expire_at?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    user_id?: SortOrder
    device_info_id?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    jti?: SortOrder
    user_id?: SortOrder
    is_active?: SortOrder
    issued_at?: SortOrder
    device_info_id?: SortOrder
    expire_at?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    jti?: SortOrder
    user_id?: SortOrder
    is_active?: SortOrder
    issued_at?: SortOrder
    device_info_id?: SortOrder
    expire_at?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    user_id?: SortOrder
    device_info_id?: SortOrder
  }

  export type usersCreateNestedOneWithoutBlock_Block_blockedIdTousersInput = {
    create?: XOR<usersCreateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlock_Block_blockedIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutBlock_Block_blockerIdTousersInput = {
    create?: XOR<usersCreateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlock_Block_blockerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutBlock_Block_blockedIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlock_Block_blockedIdTousersInput
    upsert?: usersUpsertWithoutBlock_Block_blockedIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBlock_Block_blockedIdTousersInput, usersUpdateWithoutBlock_Block_blockedIdTousersInput>, usersUncheckedUpdateWithoutBlock_Block_blockedIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutBlock_Block_blockerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlock_Block_blockerIdTousersInput
    upsert?: usersUpsertWithoutBlock_Block_blockerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBlock_Block_blockerIdTousersInput, usersUpdateWithoutBlock_Block_blockerIdTousersInput>, usersUncheckedUpdateWithoutBlock_Block_blockerIdTousersInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type usersCreateNestedOneWithoutFollow_Follow_followerIdTousersInput = {
    create?: XOR<usersCreateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollow_Follow_followerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFollow_Follow_followingIdTousersInput = {
    create?: XOR<usersCreateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followingIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollow_Follow_followingIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type EnumFollowStatusFieldUpdateOperationsInput = {
    set?: $Enums.FollowStatus
  }

  export type usersUpdateOneRequiredWithoutFollow_Follow_followerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollow_Follow_followerIdTousersInput
    upsert?: usersUpsertWithoutFollow_Follow_followerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFollow_Follow_followerIdTousersInput, usersUpdateWithoutFollow_Follow_followerIdTousersInput>, usersUncheckedUpdateWithoutFollow_Follow_followerIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutFollow_Follow_followingIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followingIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollow_Follow_followingIdTousersInput
    upsert?: usersUpsertWithoutFollow_Follow_followingIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFollow_Follow_followingIdTousersInput, usersUpdateWithoutFollow_Follow_followingIdTousersInput>, usersUncheckedUpdateWithoutFollow_Follow_followingIdTousersInput>
  }

  export type usersCreateNestedOneWithoutMention_Mention_mentionedIdTousersInput = {
    create?: XOR<usersCreateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMention_Mention_mentionedIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMention_Mention_mentionerIdTousersInput = {
    create?: XOR<usersCreateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMention_Mention_mentionerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type tweetsCreateNestedOneWithoutMentionInput = {
    create?: XOR<tweetsCreateWithoutMentionInput, tweetsUncheckedCreateWithoutMentionInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutMentionInput
    connect?: tweetsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutMention_Mention_mentionedIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMention_Mention_mentionedIdTousersInput
    upsert?: usersUpsertWithoutMention_Mention_mentionedIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMention_Mention_mentionedIdTousersInput, usersUpdateWithoutMention_Mention_mentionedIdTousersInput>, usersUncheckedUpdateWithoutMention_Mention_mentionedIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutMention_Mention_mentionerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMention_Mention_mentionerIdTousersInput
    upsert?: usersUpsertWithoutMention_Mention_mentionerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMention_Mention_mentionerIdTousersInput, usersUpdateWithoutMention_Mention_mentionerIdTousersInput>, usersUncheckedUpdateWithoutMention_Mention_mentionerIdTousersInput>
  }

  export type tweetsUpdateOneRequiredWithoutMentionNestedInput = {
    create?: XOR<tweetsCreateWithoutMentionInput, tweetsUncheckedCreateWithoutMentionInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutMentionInput
    upsert?: tweetsUpsertWithoutMentionInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutMentionInput, tweetsUpdateWithoutMentionInput>, tweetsUncheckedUpdateWithoutMentionInput>
  }

  export type mediasCreateNestedOneWithoutMessageMediaInput = {
    create?: XOR<mediasCreateWithoutMessageMediaInput, mediasUncheckedCreateWithoutMessageMediaInput>
    connectOrCreate?: mediasCreateOrConnectWithoutMessageMediaInput
    connect?: mediasWhereUniqueInput
  }

  export type messagesCreateNestedOneWithoutMessageMediaInput = {
    create?: XOR<messagesCreateWithoutMessageMediaInput, messagesUncheckedCreateWithoutMessageMediaInput>
    connectOrCreate?: messagesCreateOrConnectWithoutMessageMediaInput
    connect?: messagesWhereUniqueInput
  }

  export type mediasUpdateOneRequiredWithoutMessageMediaNestedInput = {
    create?: XOR<mediasCreateWithoutMessageMediaInput, mediasUncheckedCreateWithoutMessageMediaInput>
    connectOrCreate?: mediasCreateOrConnectWithoutMessageMediaInput
    upsert?: mediasUpsertWithoutMessageMediaInput
    connect?: mediasWhereUniqueInput
    update?: XOR<XOR<mediasUpdateToOneWithWhereWithoutMessageMediaInput, mediasUpdateWithoutMessageMediaInput>, mediasUncheckedUpdateWithoutMessageMediaInput>
  }

  export type messagesUpdateOneRequiredWithoutMessageMediaNestedInput = {
    create?: XOR<messagesCreateWithoutMessageMediaInput, messagesUncheckedCreateWithoutMessageMediaInput>
    connectOrCreate?: messagesCreateOrConnectWithoutMessageMediaInput
    upsert?: messagesUpsertWithoutMessageMediaInput
    connect?: messagesWhereUniqueInput
    update?: XOR<XOR<messagesUpdateToOneWithWhereWithoutMessageMediaInput, messagesUpdateWithoutMessageMediaInput>, messagesUncheckedUpdateWithoutMessageMediaInput>
  }

  export type usersCreateNestedOneWithoutMute_Mute_mutedIdTousersInput = {
    create?: XOR<usersCreateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedCreateWithoutMute_Mute_mutedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMute_Mute_mutedIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMute_Mute_muterIdTousersInput = {
    create?: XOR<usersCreateWithoutMute_Mute_muterIdTousersInput, usersUncheckedCreateWithoutMute_Mute_muterIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMute_Mute_muterIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutMute_Mute_mutedIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedCreateWithoutMute_Mute_mutedIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMute_Mute_mutedIdTousersInput
    upsert?: usersUpsertWithoutMute_Mute_mutedIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMute_Mute_mutedIdTousersInput, usersUpdateWithoutMute_Mute_mutedIdTousersInput>, usersUncheckedUpdateWithoutMute_Mute_mutedIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutMute_Mute_muterIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMute_Mute_muterIdTousersInput, usersUncheckedCreateWithoutMute_Mute_muterIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMute_Mute_muterIdTousersInput
    upsert?: usersUpsertWithoutMute_Mute_muterIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMute_Mute_muterIdTousersInput, usersUpdateWithoutMute_Mute_muterIdTousersInput>, usersUncheckedUpdateWithoutMute_Mute_muterIdTousersInput>
  }

  export type tweetsCreateNestedOneWithoutRetweetInput = {
    create?: XOR<tweetsCreateWithoutRetweetInput, tweetsUncheckedCreateWithoutRetweetInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutRetweetInput
    connect?: tweetsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRetweetInput = {
    create?: XOR<usersCreateWithoutRetweetInput, usersUncheckedCreateWithoutRetweetInput>
    connectOrCreate?: usersCreateOrConnectWithoutRetweetInput
    connect?: usersWhereUniqueInput
  }

  export type tweetsUpdateOneRequiredWithoutRetweetNestedInput = {
    create?: XOR<tweetsCreateWithoutRetweetInput, tweetsUncheckedCreateWithoutRetweetInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutRetweetInput
    upsert?: tweetsUpsertWithoutRetweetInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutRetweetInput, tweetsUpdateWithoutRetweetInput>, tweetsUncheckedUpdateWithoutRetweetInput>
  }

  export type usersUpdateOneRequiredWithoutRetweetNestedInput = {
    create?: XOR<usersCreateWithoutRetweetInput, usersUncheckedCreateWithoutRetweetInput>
    connectOrCreate?: usersCreateOrConnectWithoutRetweetInput
    upsert?: usersUpsertWithoutRetweetInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRetweetInput, usersUpdateWithoutRetweetInput>, usersUncheckedUpdateWithoutRetweetInput>
  }

  export type tweetsCreateNestedOneWithoutTweetLikeInput = {
    create?: XOR<tweetsCreateWithoutTweetLikeInput, tweetsUncheckedCreateWithoutTweetLikeInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetLikeInput
    connect?: tweetsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTweetLikeInput = {
    create?: XOR<usersCreateWithoutTweetLikeInput, usersUncheckedCreateWithoutTweetLikeInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetLikeInput
    connect?: usersWhereUniqueInput
  }

  export type tweetsUpdateOneRequiredWithoutTweetLikeNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetLikeInput, tweetsUncheckedCreateWithoutTweetLikeInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetLikeInput
    upsert?: tweetsUpsertWithoutTweetLikeInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutTweetLikeInput, tweetsUpdateWithoutTweetLikeInput>, tweetsUncheckedUpdateWithoutTweetLikeInput>
  }

  export type usersUpdateOneRequiredWithoutTweetLikeNestedInput = {
    create?: XOR<usersCreateWithoutTweetLikeInput, usersUncheckedCreateWithoutTweetLikeInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetLikeInput
    upsert?: usersUpsertWithoutTweetLikeInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTweetLikeInput, usersUpdateWithoutTweetLikeInput>, usersUncheckedUpdateWithoutTweetLikeInput>
  }

  export type mediasCreateNestedOneWithoutTweetMediaInput = {
    create?: XOR<mediasCreateWithoutTweetMediaInput, mediasUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: mediasCreateOrConnectWithoutTweetMediaInput
    connect?: mediasWhereUniqueInput
  }

  export type tweetsCreateNestedOneWithoutTweetMediaInput = {
    create?: XOR<tweetsCreateWithoutTweetMediaInput, tweetsUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetMediaInput
    connect?: tweetsWhereUniqueInput
  }

  export type mediasUpdateOneRequiredWithoutTweetMediaNestedInput = {
    create?: XOR<mediasCreateWithoutTweetMediaInput, mediasUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: mediasCreateOrConnectWithoutTweetMediaInput
    upsert?: mediasUpsertWithoutTweetMediaInput
    connect?: mediasWhereUniqueInput
    update?: XOR<XOR<mediasUpdateToOneWithWhereWithoutTweetMediaInput, mediasUpdateWithoutTweetMediaInput>, mediasUncheckedUpdateWithoutTweetMediaInput>
  }

  export type tweetsUpdateOneRequiredWithoutTweetMediaNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetMediaInput, tweetsUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetMediaInput
    upsert?: tweetsUpsertWithoutTweetMediaInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutTweetMediaInput, tweetsUpdateWithoutTweetMediaInput>, tweetsUncheckedUpdateWithoutTweetMediaInput>
  }

  export type tweetsCreateNestedOneWithoutTweetSummaryInput = {
    create?: XOR<tweetsCreateWithoutTweetSummaryInput, tweetsUncheckedCreateWithoutTweetSummaryInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetSummaryInput
    connect?: tweetsWhereUniqueInput
  }

  export type tweetsUpdateOneRequiredWithoutTweetSummaryNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetSummaryInput, tweetsUncheckedCreateWithoutTweetSummaryInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetSummaryInput
    upsert?: tweetsUpsertWithoutTweetSummaryInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutTweetSummaryInput, tweetsUpdateWithoutTweetSummaryInput>, tweetsUncheckedUpdateWithoutTweetSummaryInput>
  }

  export type chatsCreateNestedOneWithoutChatGroupsInput = {
    create?: XOR<chatsCreateWithoutChatGroupsInput, chatsUncheckedCreateWithoutChatGroupsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatGroupsInput
    connect?: chatsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type chatsUpdateOneRequiredWithoutChatGroupsNestedInput = {
    create?: XOR<chatsCreateWithoutChatGroupsInput, chatsUncheckedCreateWithoutChatGroupsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatGroupsInput
    upsert?: chatsUpsertWithoutChatGroupsInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutChatGroupsInput, chatsUpdateWithoutChatGroupsInput>, chatsUncheckedUpdateWithoutChatGroupsInput>
  }

  export type chatGroupsCreateNestedOneWithoutChatsInput = {
    create?: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
    connectOrCreate?: chatGroupsCreateOrConnectWithoutChatsInput
    connect?: chatGroupsWhereUniqueInput
  }

  export type chatusersCreateNestedManyWithoutChatsInput = {
    create?: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput> | chatusersCreateWithoutChatsInput[] | chatusersUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutChatsInput | chatusersCreateOrConnectWithoutChatsInput[]
    createMany?: chatusersCreateManyChatsInputEnvelope
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type chatGroupsUncheckedCreateNestedOneWithoutChatsInput = {
    create?: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
    connectOrCreate?: chatGroupsCreateOrConnectWithoutChatsInput
    connect?: chatGroupsWhereUniqueInput
  }

  export type chatusersUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput> | chatusersCreateWithoutChatsInput[] | chatusersUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutChatsInput | chatusersCreateOrConnectWithoutChatsInput[]
    createMany?: chatusersCreateManyChatsInputEnvelope
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type chatGroupsUpdateOneWithoutChatsNestedInput = {
    create?: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
    connectOrCreate?: chatGroupsCreateOrConnectWithoutChatsInput
    upsert?: chatGroupsUpsertWithoutChatsInput
    disconnect?: chatGroupsWhereInput | boolean
    delete?: chatGroupsWhereInput | boolean
    connect?: chatGroupsWhereUniqueInput
    update?: XOR<XOR<chatGroupsUpdateToOneWithWhereWithoutChatsInput, chatGroupsUpdateWithoutChatsInput>, chatGroupsUncheckedUpdateWithoutChatsInput>
  }

  export type chatusersUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput> | chatusersCreateWithoutChatsInput[] | chatusersUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutChatsInput | chatusersCreateOrConnectWithoutChatsInput[]
    upsert?: chatusersUpsertWithWhereUniqueWithoutChatsInput | chatusersUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chatusersCreateManyChatsInputEnvelope
    set?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    disconnect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    delete?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    update?: chatusersUpdateWithWhereUniqueWithoutChatsInput | chatusersUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chatusersUpdateManyWithWhereWithoutChatsInput | chatusersUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type chatGroupsUncheckedUpdateOneWithoutChatsNestedInput = {
    create?: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
    connectOrCreate?: chatGroupsCreateOrConnectWithoutChatsInput
    upsert?: chatGroupsUpsertWithoutChatsInput
    disconnect?: chatGroupsWhereInput | boolean
    delete?: chatGroupsWhereInput | boolean
    connect?: chatGroupsWhereUniqueInput
    update?: XOR<XOR<chatGroupsUpdateToOneWithWhereWithoutChatsInput, chatGroupsUpdateWithoutChatsInput>, chatGroupsUncheckedUpdateWithoutChatsInput>
  }

  export type chatusersUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput> | chatusersCreateWithoutChatsInput[] | chatusersUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutChatsInput | chatusersCreateOrConnectWithoutChatsInput[]
    upsert?: chatusersUpsertWithWhereUniqueWithoutChatsInput | chatusersUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chatusersCreateManyChatsInputEnvelope
    set?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    disconnect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    delete?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    update?: chatusersUpdateWithWhereUniqueWithoutChatsInput | chatusersUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chatusersUpdateManyWithWhereWithoutChatsInput | chatusersUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type chatsCreateNestedOneWithoutChatusersInput = {
    create?: XOR<chatsCreateWithoutChatusersInput, chatsUncheckedCreateWithoutChatusersInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatusersInput
    connect?: chatsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutChatusersInput = {
    create?: XOR<usersCreateWithoutChatusersInput, usersUncheckedCreateWithoutChatusersInput>
    connectOrCreate?: usersCreateOrConnectWithoutChatusersInput
    connect?: usersWhereUniqueInput
  }

  export type chatsUpdateOneRequiredWithoutChatusersNestedInput = {
    create?: XOR<chatsCreateWithoutChatusersInput, chatsUncheckedCreateWithoutChatusersInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatusersInput
    upsert?: chatsUpsertWithoutChatusersInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutChatusersInput, chatsUpdateWithoutChatusersInput>, chatsUncheckedUpdateWithoutChatusersInput>
  }

  export type usersUpdateOneRequiredWithoutChatusersNestedInput = {
    create?: XOR<usersCreateWithoutChatusersInput, usersUncheckedCreateWithoutChatusersInput>
    connectOrCreate?: usersCreateOrConnectWithoutChatusersInput
    upsert?: usersUpsertWithoutChatusersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChatusersInput, usersUpdateWithoutChatusersInput>, usersUncheckedUpdateWithoutChatusersInput>
  }

  export type tweetHashesCreateNestedManyWithoutHashesInput = {
    create?: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput> | tweetHashesCreateWithoutHashesInput[] | tweetHashesUncheckedCreateWithoutHashesInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutHashesInput | tweetHashesCreateOrConnectWithoutHashesInput[]
    createMany?: tweetHashesCreateManyHashesInputEnvelope
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
  }

  export type tweetHashesUncheckedCreateNestedManyWithoutHashesInput = {
    create?: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput> | tweetHashesCreateWithoutHashesInput[] | tweetHashesUncheckedCreateWithoutHashesInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutHashesInput | tweetHashesCreateOrConnectWithoutHashesInput[]
    createMany?: tweetHashesCreateManyHashesInputEnvelope
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
  }

  export type tweetHashesUpdateManyWithoutHashesNestedInput = {
    create?: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput> | tweetHashesCreateWithoutHashesInput[] | tweetHashesUncheckedCreateWithoutHashesInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutHashesInput | tweetHashesCreateOrConnectWithoutHashesInput[]
    upsert?: tweetHashesUpsertWithWhereUniqueWithoutHashesInput | tweetHashesUpsertWithWhereUniqueWithoutHashesInput[]
    createMany?: tweetHashesCreateManyHashesInputEnvelope
    set?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    disconnect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    delete?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    update?: tweetHashesUpdateWithWhereUniqueWithoutHashesInput | tweetHashesUpdateWithWhereUniqueWithoutHashesInput[]
    updateMany?: tweetHashesUpdateManyWithWhereWithoutHashesInput | tweetHashesUpdateManyWithWhereWithoutHashesInput[]
    deleteMany?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
  }

  export type tweetHashesUncheckedUpdateManyWithoutHashesNestedInput = {
    create?: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput> | tweetHashesCreateWithoutHashesInput[] | tweetHashesUncheckedCreateWithoutHashesInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutHashesInput | tweetHashesCreateOrConnectWithoutHashesInput[]
    upsert?: tweetHashesUpsertWithWhereUniqueWithoutHashesInput | tweetHashesUpsertWithWhereUniqueWithoutHashesInput[]
    createMany?: tweetHashesCreateManyHashesInputEnvelope
    set?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    disconnect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    delete?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    update?: tweetHashesUpdateWithWhereUniqueWithoutHashesInput | tweetHashesUpdateWithWhereUniqueWithoutHashesInput[]
    updateMany?: tweetHashesUpdateManyWithWhereWithoutHashesInput | tweetHashesUpdateManyWithWhereWithoutHashesInput[]
    deleteMany?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
  }

  export type MessageMediaCreateNestedManyWithoutMediasInput = {
    create?: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput> | MessageMediaCreateWithoutMediasInput[] | MessageMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMediasInput | MessageMediaCreateOrConnectWithoutMediasInput[]
    createMany?: MessageMediaCreateManyMediasInputEnvelope
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
  }

  export type TweetMediaCreateNestedManyWithoutMediasInput = {
    create?: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput> | TweetMediaCreateWithoutMediasInput[] | TweetMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutMediasInput | TweetMediaCreateOrConnectWithoutMediasInput[]
    createMany?: TweetMediaCreateManyMediasInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type MessageMediaUncheckedCreateNestedManyWithoutMediasInput = {
    create?: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput> | MessageMediaCreateWithoutMediasInput[] | MessageMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMediasInput | MessageMediaCreateOrConnectWithoutMediasInput[]
    createMany?: MessageMediaCreateManyMediasInputEnvelope
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
  }

  export type TweetMediaUncheckedCreateNestedManyWithoutMediasInput = {
    create?: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput> | TweetMediaCreateWithoutMediasInput[] | TweetMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutMediasInput | TweetMediaCreateOrConnectWithoutMediasInput[]
    createMany?: TweetMediaCreateManyMediasInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MessageMediaUpdateManyWithoutMediasNestedInput = {
    create?: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput> | MessageMediaCreateWithoutMediasInput[] | MessageMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMediasInput | MessageMediaCreateOrConnectWithoutMediasInput[]
    upsert?: MessageMediaUpsertWithWhereUniqueWithoutMediasInput | MessageMediaUpsertWithWhereUniqueWithoutMediasInput[]
    createMany?: MessageMediaCreateManyMediasInputEnvelope
    set?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    disconnect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    delete?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    update?: MessageMediaUpdateWithWhereUniqueWithoutMediasInput | MessageMediaUpdateWithWhereUniqueWithoutMediasInput[]
    updateMany?: MessageMediaUpdateManyWithWhereWithoutMediasInput | MessageMediaUpdateManyWithWhereWithoutMediasInput[]
    deleteMany?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
  }

  export type TweetMediaUpdateManyWithoutMediasNestedInput = {
    create?: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput> | TweetMediaCreateWithoutMediasInput[] | TweetMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutMediasInput | TweetMediaCreateOrConnectWithoutMediasInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutMediasInput | TweetMediaUpsertWithWhereUniqueWithoutMediasInput[]
    createMany?: TweetMediaCreateManyMediasInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutMediasInput | TweetMediaUpdateWithWhereUniqueWithoutMediasInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutMediasInput | TweetMediaUpdateManyWithWhereWithoutMediasInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type MessageMediaUncheckedUpdateManyWithoutMediasNestedInput = {
    create?: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput> | MessageMediaCreateWithoutMediasInput[] | MessageMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMediasInput | MessageMediaCreateOrConnectWithoutMediasInput[]
    upsert?: MessageMediaUpsertWithWhereUniqueWithoutMediasInput | MessageMediaUpsertWithWhereUniqueWithoutMediasInput[]
    createMany?: MessageMediaCreateManyMediasInputEnvelope
    set?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    disconnect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    delete?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    update?: MessageMediaUpdateWithWhereUniqueWithoutMediasInput | MessageMediaUpdateWithWhereUniqueWithoutMediasInput[]
    updateMany?: MessageMediaUpdateManyWithWhereWithoutMediasInput | MessageMediaUpdateManyWithWhereWithoutMediasInput[]
    deleteMany?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
  }

  export type TweetMediaUncheckedUpdateManyWithoutMediasNestedInput = {
    create?: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput> | TweetMediaCreateWithoutMediasInput[] | TweetMediaUncheckedCreateWithoutMediasInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutMediasInput | TweetMediaCreateOrConnectWithoutMediasInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutMediasInput | TweetMediaUpsertWithWhereUniqueWithoutMediasInput[]
    createMany?: TweetMediaCreateManyMediasInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutMediasInput | TweetMediaUpdateWithWhereUniqueWithoutMediasInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutMediasInput | TweetMediaUpdateManyWithWhereWithoutMediasInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type MessageMediaCreateNestedManyWithoutMessagesInput = {
    create?: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput> | MessageMediaCreateWithoutMessagesInput[] | MessageMediaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMessagesInput | MessageMediaCreateOrConnectWithoutMessagesInput[]
    createMany?: MessageMediaCreateManyMessagesInputEnvelope
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
  }

  export type chatsCreateNestedOneWithoutMessagesInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    connect?: chatsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMessagesInput = {
    create?: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessagesInput
    connect?: usersWhereUniqueInput
  }

  export type MessageMediaUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput> | MessageMediaCreateWithoutMessagesInput[] | MessageMediaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMessagesInput | MessageMediaCreateOrConnectWithoutMessagesInput[]
    createMany?: MessageMediaCreateManyMessagesInputEnvelope
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type MessageMediaUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput> | MessageMediaCreateWithoutMessagesInput[] | MessageMediaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMessagesInput | MessageMediaCreateOrConnectWithoutMessagesInput[]
    upsert?: MessageMediaUpsertWithWhereUniqueWithoutMessagesInput | MessageMediaUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: MessageMediaCreateManyMessagesInputEnvelope
    set?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    disconnect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    delete?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    update?: MessageMediaUpdateWithWhereUniqueWithoutMessagesInput | MessageMediaUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: MessageMediaUpdateManyWithWhereWithoutMessagesInput | MessageMediaUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
  }

  export type chatsUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    upsert?: chatsUpsertWithoutMessagesInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutMessagesInput, chatsUpdateWithoutMessagesInput>, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type usersUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessagesInput
    upsert?: usersUpsertWithoutMessagesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessagesInput, usersUpdateWithoutMessagesInput>, usersUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageMediaUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput> | MessageMediaCreateWithoutMessagesInput[] | MessageMediaUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: MessageMediaCreateOrConnectWithoutMessagesInput | MessageMediaCreateOrConnectWithoutMessagesInput[]
    upsert?: MessageMediaUpsertWithWhereUniqueWithoutMessagesInput | MessageMediaUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: MessageMediaCreateManyMessagesInputEnvelope
    set?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    disconnect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    delete?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    connect?: MessageMediaWhereUniqueInput | MessageMediaWhereUniqueInput[]
    update?: MessageMediaUpdateWithWhereUniqueWithoutMessagesInput | MessageMediaUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: MessageMediaUpdateManyWithWhereWithoutMessagesInput | MessageMediaUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutNotifications_notifications_actorIdTousersInput = {
    create?: XOR<usersCreateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_actorIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifications_notifications_actorIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type tweetsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<tweetsCreateWithoutNotificationsInput, tweetsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutNotificationsInput
    connect?: tweetsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutNotifications_notifications_userIdTousersInput = {
    create?: XOR<usersCreateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_userIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifications_notifications_userIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type usersUpdateOneWithoutNotifications_notifications_actorIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_actorIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifications_notifications_actorIdTousersInput
    upsert?: usersUpsertWithoutNotifications_notifications_actorIdTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotifications_notifications_actorIdTousersInput, usersUpdateWithoutNotifications_notifications_actorIdTousersInput>, usersUncheckedUpdateWithoutNotifications_notifications_actorIdTousersInput>
  }

  export type tweetsUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<tweetsCreateWithoutNotificationsInput, tweetsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutNotificationsInput
    upsert?: tweetsUpsertWithoutNotificationsInput
    disconnect?: tweetsWhereInput | boolean
    delete?: tweetsWhereInput | boolean
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutNotificationsInput, tweetsUpdateWithoutNotificationsInput>, tweetsUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateOneRequiredWithoutNotifications_notifications_userIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_userIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifications_notifications_userIdTousersInput
    upsert?: usersUpsertWithoutNotifications_notifications_userIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotifications_notifications_userIdTousersInput, usersUpdateWithoutNotifications_notifications_userIdTousersInput>, usersUncheckedUpdateWithoutNotifications_notifications_userIdTousersInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type hashesCreateNestedOneWithoutTweetHashesInput = {
    create?: XOR<hashesCreateWithoutTweetHashesInput, hashesUncheckedCreateWithoutTweetHashesInput>
    connectOrCreate?: hashesCreateOrConnectWithoutTweetHashesInput
    connect?: hashesWhereUniqueInput
  }

  export type tweetsCreateNestedOneWithoutTweetHashesInput = {
    create?: XOR<tweetsCreateWithoutTweetHashesInput, tweetsUncheckedCreateWithoutTweetHashesInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetHashesInput
    connect?: tweetsWhereUniqueInput
  }

  export type hashesUpdateOneRequiredWithoutTweetHashesNestedInput = {
    create?: XOR<hashesCreateWithoutTweetHashesInput, hashesUncheckedCreateWithoutTweetHashesInput>
    connectOrCreate?: hashesCreateOrConnectWithoutTweetHashesInput
    upsert?: hashesUpsertWithoutTweetHashesInput
    connect?: hashesWhereUniqueInput
    update?: XOR<XOR<hashesUpdateToOneWithWhereWithoutTweetHashesInput, hashesUpdateWithoutTweetHashesInput>, hashesUncheckedUpdateWithoutTweetHashesInput>
  }

  export type tweetsUpdateOneRequiredWithoutTweetHashesNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetHashesInput, tweetsUncheckedCreateWithoutTweetHashesInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetHashesInput
    upsert?: tweetsUpsertWithoutTweetHashesInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutTweetHashesInput, tweetsUpdateWithoutTweetHashesInput>, tweetsUncheckedUpdateWithoutTweetHashesInput>
  }

  export type tweetsCreateNestedOneWithoutTweetbookmarksInput = {
    create?: XOR<tweetsCreateWithoutTweetbookmarksInput, tweetsUncheckedCreateWithoutTweetbookmarksInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetbookmarksInput
    connect?: tweetsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTweetbookmarksInput = {
    create?: XOR<usersCreateWithoutTweetbookmarksInput, usersUncheckedCreateWithoutTweetbookmarksInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetbookmarksInput
    connect?: usersWhereUniqueInput
  }

  export type tweetsUpdateOneRequiredWithoutTweetbookmarksNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetbookmarksInput, tweetsUncheckedCreateWithoutTweetbookmarksInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetbookmarksInput
    upsert?: tweetsUpsertWithoutTweetbookmarksInput
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutTweetbookmarksInput, tweetsUpdateWithoutTweetbookmarksInput>, tweetsUncheckedUpdateWithoutTweetbookmarksInput>
  }

  export type usersUpdateOneRequiredWithoutTweetbookmarksNestedInput = {
    create?: XOR<usersCreateWithoutTweetbookmarksInput, usersUncheckedCreateWithoutTweetbookmarksInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetbookmarksInput
    upsert?: usersUpsertWithoutTweetbookmarksInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTweetbookmarksInput, usersUpdateWithoutTweetbookmarksInput>, usersUncheckedUpdateWithoutTweetbookmarksInput>
  }

  export type MentionCreateNestedManyWithoutTweetsInput = {
    create?: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput> | MentionCreateWithoutTweetsInput[] | MentionUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutTweetsInput | MentionCreateOrConnectWithoutTweetsInput[]
    createMany?: MentionCreateManyTweetsInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type RetweetCreateNestedManyWithoutTweetsInput = {
    create?: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput> | RetweetCreateWithoutTweetsInput[] | RetweetUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutTweetsInput | RetweetCreateOrConnectWithoutTweetsInput[]
    createMany?: RetweetCreateManyTweetsInputEnvelope
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
  }

  export type TweetLikeCreateNestedManyWithoutTweetsInput = {
    create?: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput> | TweetLikeCreateWithoutTweetsInput[] | TweetLikeUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutTweetsInput | TweetLikeCreateOrConnectWithoutTweetsInput[]
    createMany?: TweetLikeCreateManyTweetsInputEnvelope
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
  }

  export type TweetMediaCreateNestedManyWithoutTweetsInput = {
    create?: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput> | TweetMediaCreateWithoutTweetsInput[] | TweetMediaUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetsInput | TweetMediaCreateOrConnectWithoutTweetsInput[]
    createMany?: TweetMediaCreateManyTweetsInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type TweetSummaryCreateNestedOneWithoutTweetsInput = {
    create?: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TweetSummaryCreateOrConnectWithoutTweetsInput
    connect?: TweetSummaryWhereUniqueInput
  }

  export type notificationsCreateNestedManyWithoutTweetsInput = {
    create?: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput> | notificationsCreateWithoutTweetsInput[] | notificationsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutTweetsInput | notificationsCreateOrConnectWithoutTweetsInput[]
    createMany?: notificationsCreateManyTweetsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type tweetHashesCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput> | tweetHashesCreateWithoutTweetsInput[] | tweetHashesUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutTweetsInput | tweetHashesCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetHashesCreateManyTweetsInputEnvelope
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
  }

  export type tweetbookmarksCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput> | tweetbookmarksCreateWithoutTweetsInput[] | tweetbookmarksUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutTweetsInput | tweetbookmarksCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetbookmarksCreateManyTweetsInputEnvelope
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
  }

  export type tweetsCreateNestedOneWithoutOther_tweetsInput = {
    create?: XOR<tweetsCreateWithoutOther_tweetsInput, tweetsUncheckedCreateWithoutOther_tweetsInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutOther_tweetsInput
    connect?: tweetsWhereUniqueInput
  }

  export type tweetsCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput> | tweetsCreateWithoutTweetsInput[] | tweetsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetsInput | tweetsCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetsCreateManyTweetsInputEnvelope
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTweetsInput = {
    create?: XOR<usersCreateWithoutTweetsInput, usersUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetsInput
    connect?: usersWhereUniqueInput
  }

  export type MentionUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput> | MentionCreateWithoutTweetsInput[] | MentionUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutTweetsInput | MentionCreateOrConnectWithoutTweetsInput[]
    createMany?: MentionCreateManyTweetsInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type RetweetUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput> | RetweetCreateWithoutTweetsInput[] | RetweetUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutTweetsInput | RetweetCreateOrConnectWithoutTweetsInput[]
    createMany?: RetweetCreateManyTweetsInputEnvelope
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
  }

  export type TweetLikeUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput> | TweetLikeCreateWithoutTweetsInput[] | TweetLikeUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutTweetsInput | TweetLikeCreateOrConnectWithoutTweetsInput[]
    createMany?: TweetLikeCreateManyTweetsInputEnvelope
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
  }

  export type TweetMediaUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput> | TweetMediaCreateWithoutTweetsInput[] | TweetMediaUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetsInput | TweetMediaCreateOrConnectWithoutTweetsInput[]
    createMany?: TweetMediaCreateManyTweetsInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput = {
    create?: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TweetSummaryCreateOrConnectWithoutTweetsInput
    connect?: TweetSummaryWhereUniqueInput
  }

  export type notificationsUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput> | notificationsCreateWithoutTweetsInput[] | notificationsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutTweetsInput | notificationsCreateOrConnectWithoutTweetsInput[]
    createMany?: notificationsCreateManyTweetsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type tweetHashesUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput> | tweetHashesCreateWithoutTweetsInput[] | tweetHashesUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutTweetsInput | tweetHashesCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetHashesCreateManyTweetsInputEnvelope
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
  }

  export type tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput> | tweetbookmarksCreateWithoutTweetsInput[] | tweetbookmarksUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutTweetsInput | tweetbookmarksCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetbookmarksCreateManyTweetsInputEnvelope
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
  }

  export type tweetsUncheckedCreateNestedManyWithoutTweetsInput = {
    create?: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput> | tweetsCreateWithoutTweetsInput[] | tweetsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetsInput | tweetsCreateOrConnectWithoutTweetsInput[]
    createMany?: tweetsCreateManyTweetsInputEnvelope
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
  }

  export type EnumTweetTypeFieldUpdateOperationsInput = {
    set?: $Enums.TweetType
  }

  export type EnumReplyControlFieldUpdateOperationsInput = {
    set?: $Enums.ReplyControl
  }

  export type MentionUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput> | MentionCreateWithoutTweetsInput[] | MentionUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutTweetsInput | MentionCreateOrConnectWithoutTweetsInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutTweetsInput | MentionUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: MentionCreateManyTweetsInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutTweetsInput | MentionUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutTweetsInput | MentionUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type RetweetUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput> | RetweetCreateWithoutTweetsInput[] | RetweetUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutTweetsInput | RetweetCreateOrConnectWithoutTweetsInput[]
    upsert?: RetweetUpsertWithWhereUniqueWithoutTweetsInput | RetweetUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: RetweetCreateManyTweetsInputEnvelope
    set?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    disconnect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    delete?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    update?: RetweetUpdateWithWhereUniqueWithoutTweetsInput | RetweetUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: RetweetUpdateManyWithWhereWithoutTweetsInput | RetweetUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
  }

  export type TweetLikeUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput> | TweetLikeCreateWithoutTweetsInput[] | TweetLikeUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutTweetsInput | TweetLikeCreateOrConnectWithoutTweetsInput[]
    upsert?: TweetLikeUpsertWithWhereUniqueWithoutTweetsInput | TweetLikeUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: TweetLikeCreateManyTweetsInputEnvelope
    set?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    disconnect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    delete?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    update?: TweetLikeUpdateWithWhereUniqueWithoutTweetsInput | TweetLikeUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: TweetLikeUpdateManyWithWhereWithoutTweetsInput | TweetLikeUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
  }

  export type TweetMediaUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput> | TweetMediaCreateWithoutTweetsInput[] | TweetMediaUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetsInput | TweetMediaCreateOrConnectWithoutTweetsInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutTweetsInput | TweetMediaUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: TweetMediaCreateManyTweetsInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutTweetsInput | TweetMediaUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutTweetsInput | TweetMediaUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type TweetSummaryUpdateOneWithoutTweetsNestedInput = {
    create?: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TweetSummaryCreateOrConnectWithoutTweetsInput
    upsert?: TweetSummaryUpsertWithoutTweetsInput
    disconnect?: TweetSummaryWhereInput | boolean
    delete?: TweetSummaryWhereInput | boolean
    connect?: TweetSummaryWhereUniqueInput
    update?: XOR<XOR<TweetSummaryUpdateToOneWithWhereWithoutTweetsInput, TweetSummaryUpdateWithoutTweetsInput>, TweetSummaryUncheckedUpdateWithoutTweetsInput>
  }

  export type notificationsUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput> | notificationsCreateWithoutTweetsInput[] | notificationsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutTweetsInput | notificationsCreateOrConnectWithoutTweetsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutTweetsInput | notificationsUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: notificationsCreateManyTweetsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutTweetsInput | notificationsUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutTweetsInput | notificationsUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type tweetHashesUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput> | tweetHashesCreateWithoutTweetsInput[] | tweetHashesUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutTweetsInput | tweetHashesCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetHashesUpsertWithWhereUniqueWithoutTweetsInput | tweetHashesUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetHashesCreateManyTweetsInputEnvelope
    set?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    disconnect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    delete?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    update?: tweetHashesUpdateWithWhereUniqueWithoutTweetsInput | tweetHashesUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetHashesUpdateManyWithWhereWithoutTweetsInput | tweetHashesUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
  }

  export type tweetbookmarksUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput> | tweetbookmarksCreateWithoutTweetsInput[] | tweetbookmarksUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutTweetsInput | tweetbookmarksCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetbookmarksUpsertWithWhereUniqueWithoutTweetsInput | tweetbookmarksUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetbookmarksCreateManyTweetsInputEnvelope
    set?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    disconnect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    delete?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    update?: tweetbookmarksUpdateWithWhereUniqueWithoutTweetsInput | tweetbookmarksUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetbookmarksUpdateManyWithWhereWithoutTweetsInput | tweetbookmarksUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
  }

  export type tweetsUpdateOneWithoutOther_tweetsNestedInput = {
    create?: XOR<tweetsCreateWithoutOther_tweetsInput, tweetsUncheckedCreateWithoutOther_tweetsInput>
    connectOrCreate?: tweetsCreateOrConnectWithoutOther_tweetsInput
    upsert?: tweetsUpsertWithoutOther_tweetsInput
    disconnect?: tweetsWhereInput | boolean
    delete?: tweetsWhereInput | boolean
    connect?: tweetsWhereUniqueInput
    update?: XOR<XOR<tweetsUpdateToOneWithWhereWithoutOther_tweetsInput, tweetsUpdateWithoutOther_tweetsInput>, tweetsUncheckedUpdateWithoutOther_tweetsInput>
  }

  export type tweetsUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput> | tweetsCreateWithoutTweetsInput[] | tweetsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetsInput | tweetsCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetsUpsertWithWhereUniqueWithoutTweetsInput | tweetsUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetsCreateManyTweetsInputEnvelope
    set?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    disconnect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    delete?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    update?: tweetsUpdateWithWhereUniqueWithoutTweetsInput | tweetsUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetsUpdateManyWithWhereWithoutTweetsInput | tweetsUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<usersCreateWithoutTweetsInput, usersUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTweetsInput
    upsert?: usersUpsertWithoutTweetsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTweetsInput, usersUpdateWithoutTweetsInput>, usersUncheckedUpdateWithoutTweetsInput>
  }

  export type MentionUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput> | MentionCreateWithoutTweetsInput[] | MentionUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutTweetsInput | MentionCreateOrConnectWithoutTweetsInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutTweetsInput | MentionUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: MentionCreateManyTweetsInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutTweetsInput | MentionUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutTweetsInput | MentionUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type RetweetUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput> | RetweetCreateWithoutTweetsInput[] | RetweetUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutTweetsInput | RetweetCreateOrConnectWithoutTweetsInput[]
    upsert?: RetweetUpsertWithWhereUniqueWithoutTweetsInput | RetweetUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: RetweetCreateManyTweetsInputEnvelope
    set?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    disconnect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    delete?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    update?: RetweetUpdateWithWhereUniqueWithoutTweetsInput | RetweetUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: RetweetUpdateManyWithWhereWithoutTweetsInput | RetweetUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
  }

  export type TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput> | TweetLikeCreateWithoutTweetsInput[] | TweetLikeUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutTweetsInput | TweetLikeCreateOrConnectWithoutTweetsInput[]
    upsert?: TweetLikeUpsertWithWhereUniqueWithoutTweetsInput | TweetLikeUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: TweetLikeCreateManyTweetsInputEnvelope
    set?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    disconnect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    delete?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    update?: TweetLikeUpdateWithWhereUniqueWithoutTweetsInput | TweetLikeUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: TweetLikeUpdateManyWithWhereWithoutTweetsInput | TweetLikeUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
  }

  export type TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput> | TweetMediaCreateWithoutTweetsInput[] | TweetMediaUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetsInput | TweetMediaCreateOrConnectWithoutTweetsInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutTweetsInput | TweetMediaUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: TweetMediaCreateManyTweetsInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutTweetsInput | TweetMediaUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutTweetsInput | TweetMediaUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput = {
    create?: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TweetSummaryCreateOrConnectWithoutTweetsInput
    upsert?: TweetSummaryUpsertWithoutTweetsInput
    disconnect?: TweetSummaryWhereInput | boolean
    delete?: TweetSummaryWhereInput | boolean
    connect?: TweetSummaryWhereUniqueInput
    update?: XOR<XOR<TweetSummaryUpdateToOneWithWhereWithoutTweetsInput, TweetSummaryUpdateWithoutTweetsInput>, TweetSummaryUncheckedUpdateWithoutTweetsInput>
  }

  export type notificationsUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput> | notificationsCreateWithoutTweetsInput[] | notificationsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutTweetsInput | notificationsCreateOrConnectWithoutTweetsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutTweetsInput | notificationsUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: notificationsCreateManyTweetsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutTweetsInput | notificationsUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutTweetsInput | notificationsUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput> | tweetHashesCreateWithoutTweetsInput[] | tweetHashesUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetHashesCreateOrConnectWithoutTweetsInput | tweetHashesCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetHashesUpsertWithWhereUniqueWithoutTweetsInput | tweetHashesUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetHashesCreateManyTweetsInputEnvelope
    set?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    disconnect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    delete?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    connect?: tweetHashesWhereUniqueInput | tweetHashesWhereUniqueInput[]
    update?: tweetHashesUpdateWithWhereUniqueWithoutTweetsInput | tweetHashesUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetHashesUpdateManyWithWhereWithoutTweetsInput | tweetHashesUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
  }

  export type tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput> | tweetbookmarksCreateWithoutTweetsInput[] | tweetbookmarksUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutTweetsInput | tweetbookmarksCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetbookmarksUpsertWithWhereUniqueWithoutTweetsInput | tweetbookmarksUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetbookmarksCreateManyTweetsInputEnvelope
    set?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    disconnect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    delete?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    update?: tweetbookmarksUpdateWithWhereUniqueWithoutTweetsInput | tweetbookmarksUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetbookmarksUpdateManyWithWhereWithoutTweetsInput | tweetbookmarksUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
  }

  export type tweetsUncheckedUpdateManyWithoutTweetsNestedInput = {
    create?: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput> | tweetsCreateWithoutTweetsInput[] | tweetsUncheckedCreateWithoutTweetsInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutTweetsInput | tweetsCreateOrConnectWithoutTweetsInput[]
    upsert?: tweetsUpsertWithWhereUniqueWithoutTweetsInput | tweetsUpsertWithWhereUniqueWithoutTweetsInput[]
    createMany?: tweetsCreateManyTweetsInputEnvelope
    set?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    disconnect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    delete?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    update?: tweetsUpdateWithWhereUniqueWithoutTweetsInput | tweetsUpdateWithWhereUniqueWithoutTweetsInput[]
    updateMany?: tweetsUpdateManyWithWhereWithoutTweetsInput | tweetsUpdateManyWithWhereWithoutTweetsInput[]
    deleteMany?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
  }

  export type DeviceRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput> | DeviceRecordCreateWithoutUserInput[] | DeviceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRecordCreateOrConnectWithoutUserInput | DeviceRecordCreateOrConnectWithoutUserInput[]
    createMany?: DeviceRecordCreateManyUserInputEnvelope
    connect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
  }

  export type OldPasswordCreateNestedManyWithoutUserInput = {
    create?: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput> | OldPasswordCreateWithoutUserInput[] | OldPasswordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OldPasswordCreateOrConnectWithoutUserInput | OldPasswordCreateOrConnectWithoutUserInput[]
    createMany?: OldPasswordCreateManyUserInputEnvelope
    connect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput> | BlockCreateWithoutUsers_Block_blockedIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockedIdTousersInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput> | BlockCreateWithoutUsers_Block_blockerIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockerIdTousersInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput> | FollowCreateWithoutUsers_Follow_followerIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followerIdTousersInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput> | FollowCreateWithoutUsers_Follow_followingIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followingIdTousersInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionedIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionedIdTousersInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionerIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionerIdTousersInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput> | MuteCreateWithoutUsers_Mute_mutedIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_mutedIdTousersInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput> | MuteCreateWithoutUsers_Mute_muterIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_muterIdTousersInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type RetweetCreateNestedManyWithoutUsersInput = {
    create?: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput> | RetweetCreateWithoutUsersInput[] | RetweetUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutUsersInput | RetweetCreateOrConnectWithoutUsersInput[]
    createMany?: RetweetCreateManyUsersInputEnvelope
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
  }

  export type TweetLikeCreateNestedManyWithoutUsersInput = {
    create?: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput> | TweetLikeCreateWithoutUsersInput[] | TweetLikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutUsersInput | TweetLikeCreateOrConnectWithoutUsersInput[]
    createMany?: TweetLikeCreateManyUsersInputEnvelope
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
  }

  export type chatusersCreateNestedManyWithoutUsersInput = {
    create?: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput> | chatusersCreateWithoutUsersInput[] | chatusersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutUsersInput | chatusersCreateOrConnectWithoutUsersInput[]
    createMany?: chatusersCreateManyUsersInputEnvelope
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput> | notificationsCreateWithoutUsers_notifications_actorIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_actorIdTousersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput> | notificationsCreateWithoutUsers_notifications_userIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_userIdTousersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type tweetbookmarksCreateNestedManyWithoutUsersInput = {
    create?: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput> | tweetbookmarksCreateWithoutUsersInput[] | tweetbookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutUsersInput | tweetbookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: tweetbookmarksCreateManyUsersInputEnvelope
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
  }

  export type tweetsCreateNestedManyWithoutUsersInput = {
    create?: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput> | tweetsCreateWithoutUsersInput[] | tweetsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutUsersInput | tweetsCreateOrConnectWithoutUsersInput[]
    createMany?: tweetsCreateManyUsersInputEnvelope
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
  }

  export type DeviceRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput> | DeviceRecordCreateWithoutUserInput[] | DeviceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRecordCreateOrConnectWithoutUserInput | DeviceRecordCreateOrConnectWithoutUserInput[]
    createMany?: DeviceRecordCreateManyUserInputEnvelope
    connect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
  }

  export type OldPasswordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput> | OldPasswordCreateWithoutUserInput[] | OldPasswordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OldPasswordCreateOrConnectWithoutUserInput | OldPasswordCreateOrConnectWithoutUserInput[]
    createMany?: OldPasswordCreateManyUserInputEnvelope
    connect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput> | BlockCreateWithoutUsers_Block_blockedIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockedIdTousersInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput> | BlockCreateWithoutUsers_Block_blockerIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockerIdTousersInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput> | FollowCreateWithoutUsers_Follow_followerIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followerIdTousersInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput> | FollowCreateWithoutUsers_Follow_followingIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followingIdTousersInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionedIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionedIdTousersInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionerIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionerIdTousersInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput> | MuteCreateWithoutUsers_Mute_mutedIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_mutedIdTousersInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput> | MuteCreateWithoutUsers_Mute_muterIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_muterIdTousersInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type RetweetUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput> | RetweetCreateWithoutUsersInput[] | RetweetUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutUsersInput | RetweetCreateOrConnectWithoutUsersInput[]
    createMany?: RetweetCreateManyUsersInputEnvelope
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
  }

  export type TweetLikeUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput> | TweetLikeCreateWithoutUsersInput[] | TweetLikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutUsersInput | TweetLikeCreateOrConnectWithoutUsersInput[]
    createMany?: TweetLikeCreateManyUsersInputEnvelope
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
  }

  export type chatusersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput> | chatusersCreateWithoutUsersInput[] | chatusersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutUsersInput | chatusersCreateOrConnectWithoutUsersInput[]
    createMany?: chatusersCreateManyUsersInputEnvelope
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput> | notificationsCreateWithoutUsers_notifications_actorIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_actorIdTousersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput> | notificationsCreateWithoutUsers_notifications_userIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_userIdTousersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput> | tweetbookmarksCreateWithoutUsersInput[] | tweetbookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutUsersInput | tweetbookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: tweetbookmarksCreateManyUsersInputEnvelope
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
  }

  export type tweetsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput> | tweetsCreateWithoutUsersInput[] | tweetsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutUsersInput | tweetsCreateOrConnectWithoutUsersInput[]
    createMany?: tweetsCreateManyUsersInputEnvelope
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DeviceRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput> | DeviceRecordCreateWithoutUserInput[] | DeviceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRecordCreateOrConnectWithoutUserInput | DeviceRecordCreateOrConnectWithoutUserInput[]
    upsert?: DeviceRecordUpsertWithWhereUniqueWithoutUserInput | DeviceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceRecordCreateManyUserInputEnvelope
    set?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    disconnect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    delete?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    connect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    update?: DeviceRecordUpdateWithWhereUniqueWithoutUserInput | DeviceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceRecordUpdateManyWithWhereWithoutUserInput | DeviceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceRecordScalarWhereInput | DeviceRecordScalarWhereInput[]
  }

  export type OldPasswordUpdateManyWithoutUserNestedInput = {
    create?: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput> | OldPasswordCreateWithoutUserInput[] | OldPasswordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OldPasswordCreateOrConnectWithoutUserInput | OldPasswordCreateOrConnectWithoutUserInput[]
    upsert?: OldPasswordUpsertWithWhereUniqueWithoutUserInput | OldPasswordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OldPasswordCreateManyUserInputEnvelope
    set?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    disconnect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    delete?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    connect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    update?: OldPasswordUpdateWithWhereUniqueWithoutUserInput | OldPasswordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OldPasswordUpdateManyWithWhereWithoutUserInput | OldPasswordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OldPasswordScalarWhereInput | OldPasswordScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput> | BlockCreateWithoutUsers_Block_blockedIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput | BlockUpsertWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockedIdTousersInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput | BlockUpdateWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutUsers_Block_blockedIdTousersInput | BlockUpdateManyWithWhereWithoutUsers_Block_blockedIdTousersInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput> | BlockCreateWithoutUsers_Block_blockerIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput | BlockUpsertWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockerIdTousersInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput | BlockUpdateWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutUsers_Block_blockerIdTousersInput | BlockUpdateManyWithWhereWithoutUsers_Block_blockerIdTousersInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput> | FollowCreateWithoutUsers_Follow_followerIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput | FollowUpsertWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followerIdTousersInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput | FollowUpdateWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutUsers_Follow_followerIdTousersInput | FollowUpdateManyWithWhereWithoutUsers_Follow_followerIdTousersInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput> | FollowCreateWithoutUsers_Follow_followingIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput | FollowUpsertWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followingIdTousersInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput | FollowUpdateWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutUsers_Follow_followingIdTousersInput | FollowUpdateManyWithWhereWithoutUsers_Follow_followingIdTousersInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionedIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput | MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionedIdTousersInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput | MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUsers_Mention_mentionedIdTousersInput | MentionUpdateManyWithWhereWithoutUsers_Mention_mentionedIdTousersInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionerIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput | MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionerIdTousersInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput | MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUsers_Mention_mentionerIdTousersInput | MentionUpdateManyWithWhereWithoutUsers_Mention_mentionerIdTousersInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput> | MuteCreateWithoutUsers_Mute_mutedIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput | MuteUpsertWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_mutedIdTousersInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput | MuteUpdateWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutUsers_Mute_mutedIdTousersInput | MuteUpdateManyWithWhereWithoutUsers_Mute_mutedIdTousersInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput> | MuteCreateWithoutUsers_Mute_muterIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput | MuteUpsertWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_muterIdTousersInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput | MuteUpdateWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutUsers_Mute_muterIdTousersInput | MuteUpdateManyWithWhereWithoutUsers_Mute_muterIdTousersInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type RetweetUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput> | RetweetCreateWithoutUsersInput[] | RetweetUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutUsersInput | RetweetCreateOrConnectWithoutUsersInput[]
    upsert?: RetweetUpsertWithWhereUniqueWithoutUsersInput | RetweetUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RetweetCreateManyUsersInputEnvelope
    set?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    disconnect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    delete?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    update?: RetweetUpdateWithWhereUniqueWithoutUsersInput | RetweetUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RetweetUpdateManyWithWhereWithoutUsersInput | RetweetUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
  }

  export type TweetLikeUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput> | TweetLikeCreateWithoutUsersInput[] | TweetLikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutUsersInput | TweetLikeCreateOrConnectWithoutUsersInput[]
    upsert?: TweetLikeUpsertWithWhereUniqueWithoutUsersInput | TweetLikeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TweetLikeCreateManyUsersInputEnvelope
    set?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    disconnect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    delete?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    update?: TweetLikeUpdateWithWhereUniqueWithoutUsersInput | TweetLikeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TweetLikeUpdateManyWithWhereWithoutUsersInput | TweetLikeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
  }

  export type chatusersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput> | chatusersCreateWithoutUsersInput[] | chatusersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutUsersInput | chatusersCreateOrConnectWithoutUsersInput[]
    upsert?: chatusersUpsertWithWhereUniqueWithoutUsersInput | chatusersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chatusersCreateManyUsersInputEnvelope
    set?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    disconnect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    delete?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    update?: chatusersUpdateWithWhereUniqueWithoutUsersInput | chatusersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chatusersUpdateManyWithWhereWithoutUsersInput | chatusersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsersInput | messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsersInput | messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsersInput | messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput> | notificationsCreateWithoutUsers_notifications_actorIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput | notificationsUpsertWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_actorIdTousersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput | notificationsUpdateWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsers_notifications_actorIdTousersInput | notificationsUpdateManyWithWhereWithoutUsers_notifications_actorIdTousersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput> | notificationsCreateWithoutUsers_notifications_userIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsers_notifications_userIdTousersInput | notificationsUpsertWithWhereUniqueWithoutUsers_notifications_userIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_userIdTousersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsers_notifications_userIdTousersInput | notificationsUpdateWithWhereUniqueWithoutUsers_notifications_userIdTousersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsers_notifications_userIdTousersInput | notificationsUpdateManyWithWhereWithoutUsers_notifications_userIdTousersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type tweetbookmarksUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput> | tweetbookmarksCreateWithoutUsersInput[] | tweetbookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutUsersInput | tweetbookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: tweetbookmarksUpsertWithWhereUniqueWithoutUsersInput | tweetbookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tweetbookmarksCreateManyUsersInputEnvelope
    set?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    disconnect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    delete?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    update?: tweetbookmarksUpdateWithWhereUniqueWithoutUsersInput | tweetbookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tweetbookmarksUpdateManyWithWhereWithoutUsersInput | tweetbookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
  }

  export type tweetsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput> | tweetsCreateWithoutUsersInput[] | tweetsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutUsersInput | tweetsCreateOrConnectWithoutUsersInput[]
    upsert?: tweetsUpsertWithWhereUniqueWithoutUsersInput | tweetsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tweetsCreateManyUsersInputEnvelope
    set?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    disconnect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    delete?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    update?: tweetsUpdateWithWhereUniqueWithoutUsersInput | tweetsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tweetsUpdateManyWithWhereWithoutUsersInput | tweetsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
  }

  export type DeviceRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput> | DeviceRecordCreateWithoutUserInput[] | DeviceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceRecordCreateOrConnectWithoutUserInput | DeviceRecordCreateOrConnectWithoutUserInput[]
    upsert?: DeviceRecordUpsertWithWhereUniqueWithoutUserInput | DeviceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceRecordCreateManyUserInputEnvelope
    set?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    disconnect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    delete?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    connect?: DeviceRecordWhereUniqueInput | DeviceRecordWhereUniqueInput[]
    update?: DeviceRecordUpdateWithWhereUniqueWithoutUserInput | DeviceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceRecordUpdateManyWithWhereWithoutUserInput | DeviceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceRecordScalarWhereInput | DeviceRecordScalarWhereInput[]
  }

  export type OldPasswordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput> | OldPasswordCreateWithoutUserInput[] | OldPasswordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OldPasswordCreateOrConnectWithoutUserInput | OldPasswordCreateOrConnectWithoutUserInput[]
    upsert?: OldPasswordUpsertWithWhereUniqueWithoutUserInput | OldPasswordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OldPasswordCreateManyUserInputEnvelope
    set?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    disconnect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    delete?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    connect?: OldPasswordWhereUniqueInput | OldPasswordWhereUniqueInput[]
    update?: OldPasswordUpdateWithWhereUniqueWithoutUserInput | OldPasswordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OldPasswordUpdateManyWithWhereWithoutUserInput | OldPasswordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OldPasswordScalarWhereInput | OldPasswordScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput> | BlockCreateWithoutUsers_Block_blockedIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput | BlockUpsertWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockedIdTousersInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput | BlockUpdateWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutUsers_Block_blockedIdTousersInput | BlockUpdateManyWithWhereWithoutUsers_Block_blockedIdTousersInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput = {
    create?: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput> | BlockCreateWithoutUsers_Block_blockerIdTousersInput[] | BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput | BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput | BlockUpsertWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput[]
    createMany?: BlockCreateManyUsers_Block_blockerIdTousersInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput | BlockUpdateWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutUsers_Block_blockerIdTousersInput | BlockUpdateManyWithWhereWithoutUsers_Block_blockerIdTousersInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput> | FollowCreateWithoutUsers_Follow_followerIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput | FollowUpsertWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followerIdTousersInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput | FollowUpdateWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutUsers_Follow_followerIdTousersInput | FollowUpdateManyWithWhereWithoutUsers_Follow_followerIdTousersInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput = {
    create?: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput> | FollowCreateWithoutUsers_Follow_followingIdTousersInput[] | FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput | FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput | FollowUpsertWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput[]
    createMany?: FollowCreateManyUsers_Follow_followingIdTousersInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput | FollowUpdateWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutUsers_Follow_followingIdTousersInput | FollowUpdateManyWithWhereWithoutUsers_Follow_followingIdTousersInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionedIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput | MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionedIdTousersInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput | MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUsers_Mention_mentionedIdTousersInput | MentionUpdateManyWithWhereWithoutUsers_Mention_mentionedIdTousersInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput = {
    create?: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput> | MentionCreateWithoutUsers_Mention_mentionerIdTousersInput[] | MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput | MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput | MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput[]
    createMany?: MentionCreateManyUsers_Mention_mentionerIdTousersInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput | MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUsers_Mention_mentionerIdTousersInput | MentionUpdateManyWithWhereWithoutUsers_Mention_mentionerIdTousersInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput> | MuteCreateWithoutUsers_Mute_mutedIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput | MuteUpsertWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_mutedIdTousersInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput | MuteUpdateWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutUsers_Mute_mutedIdTousersInput | MuteUpdateManyWithWhereWithoutUsers_Mute_mutedIdTousersInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput = {
    create?: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput> | MuteCreateWithoutUsers_Mute_muterIdTousersInput[] | MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput | MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput | MuteUpsertWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput[]
    createMany?: MuteCreateManyUsers_Mute_muterIdTousersInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput | MuteUpdateWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutUsers_Mute_muterIdTousersInput | MuteUpdateManyWithWhereWithoutUsers_Mute_muterIdTousersInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type RetweetUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput> | RetweetCreateWithoutUsersInput[] | RetweetUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RetweetCreateOrConnectWithoutUsersInput | RetweetCreateOrConnectWithoutUsersInput[]
    upsert?: RetweetUpsertWithWhereUniqueWithoutUsersInput | RetweetUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RetweetCreateManyUsersInputEnvelope
    set?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    disconnect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    delete?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    connect?: RetweetWhereUniqueInput | RetweetWhereUniqueInput[]
    update?: RetweetUpdateWithWhereUniqueWithoutUsersInput | RetweetUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RetweetUpdateManyWithWhereWithoutUsersInput | RetweetUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
  }

  export type TweetLikeUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput> | TweetLikeCreateWithoutUsersInput[] | TweetLikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TweetLikeCreateOrConnectWithoutUsersInput | TweetLikeCreateOrConnectWithoutUsersInput[]
    upsert?: TweetLikeUpsertWithWhereUniqueWithoutUsersInput | TweetLikeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TweetLikeCreateManyUsersInputEnvelope
    set?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    disconnect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    delete?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    connect?: TweetLikeWhereUniqueInput | TweetLikeWhereUniqueInput[]
    update?: TweetLikeUpdateWithWhereUniqueWithoutUsersInput | TweetLikeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TweetLikeUpdateManyWithWhereWithoutUsersInput | TweetLikeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
  }

  export type chatusersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput> | chatusersCreateWithoutUsersInput[] | chatusersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatusersCreateOrConnectWithoutUsersInput | chatusersCreateOrConnectWithoutUsersInput[]
    upsert?: chatusersUpsertWithWhereUniqueWithoutUsersInput | chatusersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chatusersCreateManyUsersInputEnvelope
    set?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    disconnect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    delete?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    connect?: chatusersWhereUniqueInput | chatusersWhereUniqueInput[]
    update?: chatusersUpdateWithWhereUniqueWithoutUsersInput | chatusersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chatusersUpdateManyWithWhereWithoutUsersInput | chatusersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsersInput | messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsersInput | messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsersInput | messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput> | notificationsCreateWithoutUsers_notifications_actorIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput | notificationsUpsertWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_actorIdTousersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput | notificationsUpdateWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsers_notifications_actorIdTousersInput | notificationsUpdateManyWithWhereWithoutUsers_notifications_actorIdTousersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput> | notificationsCreateWithoutUsers_notifications_userIdTousersInput[] | notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput | notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsers_notifications_userIdTousersInput | notificationsUpsertWithWhereUniqueWithoutUsers_notifications_userIdTousersInput[]
    createMany?: notificationsCreateManyUsers_notifications_userIdTousersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsers_notifications_userIdTousersInput | notificationsUpdateWithWhereUniqueWithoutUsers_notifications_userIdTousersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsers_notifications_userIdTousersInput | notificationsUpdateManyWithWhereWithoutUsers_notifications_userIdTousersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput> | tweetbookmarksCreateWithoutUsersInput[] | tweetbookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetbookmarksCreateOrConnectWithoutUsersInput | tweetbookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: tweetbookmarksUpsertWithWhereUniqueWithoutUsersInput | tweetbookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tweetbookmarksCreateManyUsersInputEnvelope
    set?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    disconnect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    delete?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    connect?: tweetbookmarksWhereUniqueInput | tweetbookmarksWhereUniqueInput[]
    update?: tweetbookmarksUpdateWithWhereUniqueWithoutUsersInput | tweetbookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tweetbookmarksUpdateManyWithWhereWithoutUsersInput | tweetbookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
  }

  export type tweetsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput> | tweetsCreateWithoutUsersInput[] | tweetsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tweetsCreateOrConnectWithoutUsersInput | tweetsCreateOrConnectWithoutUsersInput[]
    upsert?: tweetsUpsertWithWhereUniqueWithoutUsersInput | tweetsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tweetsCreateManyUsersInputEnvelope
    set?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    disconnect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    delete?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    connect?: tweetsWhereUniqueInput | tweetsWhereUniqueInput[]
    update?: tweetsUpdateWithWhereUniqueWithoutUsersInput | tweetsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tweetsUpdateManyWithWhereWithoutUsersInput | tweetsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDevice_recordInput = {
    create?: XOR<usersCreateWithoutDevice_recordInput, usersUncheckedCreateWithoutDevice_recordInput>
    connectOrCreate?: usersCreateOrConnectWithoutDevice_recordInput
    connect?: usersWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutDevice_recordNestedInput = {
    create?: XOR<usersCreateWithoutDevice_recordInput, usersUncheckedCreateWithoutDevice_recordInput>
    connectOrCreate?: usersCreateOrConnectWithoutDevice_recordInput
    upsert?: usersUpsertWithoutDevice_recordInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDevice_recordInput, usersUpdateWithoutDevice_recordInput>, usersUncheckedUpdateWithoutDevice_recordInput>
  }

  export type usersCreateNestedOneWithoutOld_passwordsInput = {
    create?: XOR<usersCreateWithoutOld_passwordsInput, usersUncheckedCreateWithoutOld_passwordsInput>
    connectOrCreate?: usersCreateOrConnectWithoutOld_passwordsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutOld_passwordsNestedInput = {
    create?: XOR<usersCreateWithoutOld_passwordsInput, usersUncheckedCreateWithoutOld_passwordsInput>
    connectOrCreate?: usersCreateOrConnectWithoutOld_passwordsInput
    upsert?: usersUpsertWithoutOld_passwordsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOld_passwordsInput, usersUpdateWithoutOld_passwordsInput>, usersUncheckedUpdateWithoutOld_passwordsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumFollowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowStatusFilter<$PrismaModel> | $Enums.FollowStatus
  }

  export type NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowStatus | EnumFollowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowStatus[] | ListEnumFollowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTweetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TweetType | EnumTweetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTweetTypeFilter<$PrismaModel> | $Enums.TweetType
  }

  export type NestedEnumReplyControlFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyControl | EnumReplyControlFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyControlFilter<$PrismaModel> | $Enums.ReplyControl
  }

  export type NestedEnumTweetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TweetType | EnumTweetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TweetType[] | ListEnumTweetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTweetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TweetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTweetTypeFilter<$PrismaModel>
    _max?: NestedEnumTweetTypeFilter<$PrismaModel>
  }

  export type NestedEnumReplyControlWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReplyControl | EnumReplyControlFieldRefInput<$PrismaModel>
    in?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReplyControl[] | ListEnumReplyControlFieldRefInput<$PrismaModel>
    not?: NestedEnumReplyControlWithAggregatesFilter<$PrismaModel> | $Enums.ReplyControl
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReplyControlFilter<$PrismaModel>
    _max?: NestedEnumReplyControlFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type usersCreateWithoutBlock_Block_blockedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBlock_Block_blockedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBlock_Block_blockedIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockedIdTousersInput>
  }

  export type usersCreateWithoutBlock_Block_blockerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBlock_Block_blockerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBlock_Block_blockerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockerIdTousersInput>
  }

  export type usersUpsertWithoutBlock_Block_blockedIdTousersInput = {
    update: XOR<usersUpdateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedUpdateWithoutBlock_Block_blockedIdTousersInput>
    create: XOR<usersCreateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockedIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBlock_Block_blockedIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBlock_Block_blockedIdTousersInput, usersUncheckedUpdateWithoutBlock_Block_blockedIdTousersInput>
  }

  export type usersUpdateWithoutBlock_Block_blockedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBlock_Block_blockedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutBlock_Block_blockerIdTousersInput = {
    update: XOR<usersUpdateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedUpdateWithoutBlock_Block_blockerIdTousersInput>
    create: XOR<usersCreateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedCreateWithoutBlock_Block_blockerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBlock_Block_blockerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBlock_Block_blockerIdTousersInput, usersUncheckedUpdateWithoutBlock_Block_blockerIdTousersInput>
  }

  export type usersUpdateWithoutBlock_Block_blockerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBlock_Block_blockerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutFollow_Follow_followerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFollow_Follow_followerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFollow_Follow_followerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followerIdTousersInput>
  }

  export type usersCreateWithoutFollow_Follow_followingIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFollow_Follow_followingIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFollow_Follow_followingIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followingIdTousersInput>
  }

  export type usersUpsertWithoutFollow_Follow_followerIdTousersInput = {
    update: XOR<usersUpdateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedUpdateWithoutFollow_Follow_followerIdTousersInput>
    create: XOR<usersCreateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFollow_Follow_followerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFollow_Follow_followerIdTousersInput, usersUncheckedUpdateWithoutFollow_Follow_followerIdTousersInput>
  }

  export type usersUpdateWithoutFollow_Follow_followerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFollow_Follow_followerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutFollow_Follow_followingIdTousersInput = {
    update: XOR<usersUpdateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedUpdateWithoutFollow_Follow_followingIdTousersInput>
    create: XOR<usersCreateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedCreateWithoutFollow_Follow_followingIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFollow_Follow_followingIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFollow_Follow_followingIdTousersInput, usersUncheckedUpdateWithoutFollow_Follow_followingIdTousersInput>
  }

  export type usersUpdateWithoutFollow_Follow_followingIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFollow_Follow_followingIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutMention_Mention_mentionedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMention_Mention_mentionedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMention_Mention_mentionedIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionedIdTousersInput>
  }

  export type usersCreateWithoutMention_Mention_mentionerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMention_Mention_mentionerIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMention_Mention_mentionerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionerIdTousersInput>
  }

  export type tweetsCreateWithoutMentionInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutMentionInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutMentionInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutMentionInput, tweetsUncheckedCreateWithoutMentionInput>
  }

  export type usersUpsertWithoutMention_Mention_mentionedIdTousersInput = {
    update: XOR<usersUpdateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedUpdateWithoutMention_Mention_mentionedIdTousersInput>
    create: XOR<usersCreateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionedIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMention_Mention_mentionedIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMention_Mention_mentionedIdTousersInput, usersUncheckedUpdateWithoutMention_Mention_mentionedIdTousersInput>
  }

  export type usersUpdateWithoutMention_Mention_mentionedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMention_Mention_mentionedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutMention_Mention_mentionerIdTousersInput = {
    update: XOR<usersUpdateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedUpdateWithoutMention_Mention_mentionerIdTousersInput>
    create: XOR<usersCreateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedCreateWithoutMention_Mention_mentionerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMention_Mention_mentionerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMention_Mention_mentionerIdTousersInput, usersUncheckedUpdateWithoutMention_Mention_mentionerIdTousersInput>
  }

  export type usersUpdateWithoutMention_Mention_mentionerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMention_Mention_mentionerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tweetsUpsertWithoutMentionInput = {
    update: XOR<tweetsUpdateWithoutMentionInput, tweetsUncheckedUpdateWithoutMentionInput>
    create: XOR<tweetsCreateWithoutMentionInput, tweetsUncheckedCreateWithoutMentionInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutMentionInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutMentionInput, tweetsUncheckedUpdateWithoutMentionInput>
  }

  export type tweetsUpdateWithoutMentionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutMentionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type mediasCreateWithoutMessageMediaInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    TweetMedia?: TweetMediaCreateNestedManyWithoutMediasInput
  }

  export type mediasUncheckedCreateWithoutMessageMediaInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutMediasInput
  }

  export type mediasCreateOrConnectWithoutMessageMediaInput = {
    where: mediasWhereUniqueInput
    create: XOR<mediasCreateWithoutMessageMediaInput, mediasUncheckedCreateWithoutMessageMediaInput>
  }

  export type messagesCreateWithoutMessageMediaInput = {
    id: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    chats: chatsCreateNestedOneWithoutMessagesInput
    users: usersCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutMessageMediaInput = {
    id: string
    chatId: string
    userId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
  }

  export type messagesCreateOrConnectWithoutMessageMediaInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutMessageMediaInput, messagesUncheckedCreateWithoutMessageMediaInput>
  }

  export type mediasUpsertWithoutMessageMediaInput = {
    update: XOR<mediasUpdateWithoutMessageMediaInput, mediasUncheckedUpdateWithoutMessageMediaInput>
    create: XOR<mediasCreateWithoutMessageMediaInput, mediasUncheckedCreateWithoutMessageMediaInput>
    where?: mediasWhereInput
  }

  export type mediasUpdateToOneWithWhereWithoutMessageMediaInput = {
    where?: mediasWhereInput
    data: XOR<mediasUpdateWithoutMessageMediaInput, mediasUncheckedUpdateWithoutMessageMediaInput>
  }

  export type mediasUpdateWithoutMessageMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    TweetMedia?: TweetMediaUpdateManyWithoutMediasNestedInput
  }

  export type mediasUncheckedUpdateWithoutMessageMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutMediasNestedInput
  }

  export type messagesUpsertWithoutMessageMediaInput = {
    update: XOR<messagesUpdateWithoutMessageMediaInput, messagesUncheckedUpdateWithoutMessageMediaInput>
    create: XOR<messagesCreateWithoutMessageMediaInput, messagesUncheckedCreateWithoutMessageMediaInput>
    where?: messagesWhereInput
  }

  export type messagesUpdateToOneWithWhereWithoutMessageMediaInput = {
    where?: messagesWhereInput
    data: XOR<messagesUpdateWithoutMessageMediaInput, messagesUncheckedUpdateWithoutMessageMediaInput>
  }

  export type messagesUpdateWithoutMessageMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    chats?: chatsUpdateOneRequiredWithoutMessagesNestedInput
    users?: usersUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutMessageMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
  }

  export type usersCreateWithoutMute_Mute_mutedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMute_Mute_mutedIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMute_Mute_mutedIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedCreateWithoutMute_Mute_mutedIdTousersInput>
  }

  export type usersCreateWithoutMute_Mute_muterIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMute_Mute_muterIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMute_Mute_muterIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMute_Mute_muterIdTousersInput, usersUncheckedCreateWithoutMute_Mute_muterIdTousersInput>
  }

  export type usersUpsertWithoutMute_Mute_mutedIdTousersInput = {
    update: XOR<usersUpdateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedUpdateWithoutMute_Mute_mutedIdTousersInput>
    create: XOR<usersCreateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedCreateWithoutMute_Mute_mutedIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMute_Mute_mutedIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMute_Mute_mutedIdTousersInput, usersUncheckedUpdateWithoutMute_Mute_mutedIdTousersInput>
  }

  export type usersUpdateWithoutMute_Mute_mutedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMute_Mute_mutedIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutMute_Mute_muterIdTousersInput = {
    update: XOR<usersUpdateWithoutMute_Mute_muterIdTousersInput, usersUncheckedUpdateWithoutMute_Mute_muterIdTousersInput>
    create: XOR<usersCreateWithoutMute_Mute_muterIdTousersInput, usersUncheckedCreateWithoutMute_Mute_muterIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMute_Mute_muterIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMute_Mute_muterIdTousersInput, usersUncheckedUpdateWithoutMute_Mute_muterIdTousersInput>
  }

  export type usersUpdateWithoutMute_Mute_muterIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMute_Mute_muterIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tweetsCreateWithoutRetweetInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutRetweetInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutRetweetInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutRetweetInput, tweetsUncheckedCreateWithoutRetweetInput>
  }

  export type usersCreateWithoutRetweetInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRetweetInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRetweetInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRetweetInput, usersUncheckedCreateWithoutRetweetInput>
  }

  export type tweetsUpsertWithoutRetweetInput = {
    update: XOR<tweetsUpdateWithoutRetweetInput, tweetsUncheckedUpdateWithoutRetweetInput>
    create: XOR<tweetsCreateWithoutRetweetInput, tweetsUncheckedCreateWithoutRetweetInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutRetweetInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutRetweetInput, tweetsUncheckedUpdateWithoutRetweetInput>
  }

  export type tweetsUpdateWithoutRetweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutRetweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type usersUpsertWithoutRetweetInput = {
    update: XOR<usersUpdateWithoutRetweetInput, usersUncheckedUpdateWithoutRetweetInput>
    create: XOR<usersCreateWithoutRetweetInput, usersUncheckedCreateWithoutRetweetInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRetweetInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRetweetInput, usersUncheckedUpdateWithoutRetweetInput>
  }

  export type usersUpdateWithoutRetweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRetweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tweetsCreateWithoutTweetLikeInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetLikeInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetLikeInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetLikeInput, tweetsUncheckedCreateWithoutTweetLikeInput>
  }

  export type usersCreateWithoutTweetLikeInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTweetLikeInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTweetLikeInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTweetLikeInput, usersUncheckedCreateWithoutTweetLikeInput>
  }

  export type tweetsUpsertWithoutTweetLikeInput = {
    update: XOR<tweetsUpdateWithoutTweetLikeInput, tweetsUncheckedUpdateWithoutTweetLikeInput>
    create: XOR<tweetsCreateWithoutTweetLikeInput, tweetsUncheckedCreateWithoutTweetLikeInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutTweetLikeInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutTweetLikeInput, tweetsUncheckedUpdateWithoutTweetLikeInput>
  }

  export type tweetsUpdateWithoutTweetLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type usersUpsertWithoutTweetLikeInput = {
    update: XOR<usersUpdateWithoutTweetLikeInput, usersUncheckedUpdateWithoutTweetLikeInput>
    create: XOR<usersCreateWithoutTweetLikeInput, usersUncheckedCreateWithoutTweetLikeInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTweetLikeInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTweetLikeInput, usersUncheckedUpdateWithoutTweetLikeInput>
  }

  export type usersUpdateWithoutTweetLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTweetLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type mediasCreateWithoutTweetMediaInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    MessageMedia?: MessageMediaCreateNestedManyWithoutMediasInput
  }

  export type mediasUncheckedCreateWithoutTweetMediaInput = {
    id: string
    name: string
    url: string
    type: $Enums.MediaType
    size?: number | null
    MessageMedia?: MessageMediaUncheckedCreateNestedManyWithoutMediasInput
  }

  export type mediasCreateOrConnectWithoutTweetMediaInput = {
    where: mediasWhereUniqueInput
    create: XOR<mediasCreateWithoutTweetMediaInput, mediasUncheckedCreateWithoutTweetMediaInput>
  }

  export type tweetsCreateWithoutTweetMediaInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetMediaInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetMediaInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetMediaInput, tweetsUncheckedCreateWithoutTweetMediaInput>
  }

  export type mediasUpsertWithoutTweetMediaInput = {
    update: XOR<mediasUpdateWithoutTweetMediaInput, mediasUncheckedUpdateWithoutTweetMediaInput>
    create: XOR<mediasCreateWithoutTweetMediaInput, mediasUncheckedCreateWithoutTweetMediaInput>
    where?: mediasWhereInput
  }

  export type mediasUpdateToOneWithWhereWithoutTweetMediaInput = {
    where?: mediasWhereInput
    data: XOR<mediasUpdateWithoutTweetMediaInput, mediasUncheckedUpdateWithoutTweetMediaInput>
  }

  export type mediasUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    MessageMedia?: MessageMediaUpdateManyWithoutMediasNestedInput
  }

  export type mediasUncheckedUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    size?: NullableIntFieldUpdateOperationsInput | number | null
    MessageMedia?: MessageMediaUncheckedUpdateManyWithoutMediasNestedInput
  }

  export type tweetsUpsertWithoutTweetMediaInput = {
    update: XOR<tweetsUpdateWithoutTweetMediaInput, tweetsUncheckedUpdateWithoutTweetMediaInput>
    create: XOR<tweetsCreateWithoutTweetMediaInput, tweetsUncheckedCreateWithoutTweetMediaInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutTweetMediaInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutTweetMediaInput, tweetsUncheckedUpdateWithoutTweetMediaInput>
  }

  export type tweetsUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsCreateWithoutTweetSummaryInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetSummaryInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetSummaryInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetSummaryInput, tweetsUncheckedCreateWithoutTweetSummaryInput>
  }

  export type tweetsUpsertWithoutTweetSummaryInput = {
    update: XOR<tweetsUpdateWithoutTweetSummaryInput, tweetsUncheckedUpdateWithoutTweetSummaryInput>
    create: XOR<tweetsCreateWithoutTweetSummaryInput, tweetsUncheckedCreateWithoutTweetSummaryInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutTweetSummaryInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutTweetSummaryInput, tweetsUncheckedUpdateWithoutTweetSummaryInput>
  }

  export type tweetsUpdateWithoutTweetSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type chatsCreateWithoutChatGroupsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatusers?: chatusersCreateNestedManyWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutChatGroupsInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatusers?: chatusersUncheckedCreateNestedManyWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutChatGroupsInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutChatGroupsInput, chatsUncheckedCreateWithoutChatGroupsInput>
  }

  export type chatsUpsertWithoutChatGroupsInput = {
    update: XOR<chatsUpdateWithoutChatGroupsInput, chatsUncheckedUpdateWithoutChatGroupsInput>
    create: XOR<chatsCreateWithoutChatGroupsInput, chatsUncheckedCreateWithoutChatGroupsInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutChatGroupsInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutChatGroupsInput, chatsUncheckedUpdateWithoutChatGroupsInput>
  }

  export type chatsUpdateWithoutChatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatusers?: chatusersUpdateManyWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutChatGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatusers?: chatusersUncheckedUpdateManyWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type chatGroupsCreateWithoutChatsInput = {
    name?: string | null
    description?: string | null
    photo?: string | null
  }

  export type chatGroupsUncheckedCreateWithoutChatsInput = {
    name?: string | null
    description?: string | null
    photo?: string | null
  }

  export type chatGroupsCreateOrConnectWithoutChatsInput = {
    where: chatGroupsWhereUniqueInput
    create: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
  }

  export type chatusersCreateWithoutChatsInput = {
    id: string
    users: usersCreateNestedOneWithoutChatusersInput
  }

  export type chatusersUncheckedCreateWithoutChatsInput = {
    id: string
    userId: string
  }

  export type chatusersCreateOrConnectWithoutChatsInput = {
    where: chatusersWhereUniqueInput
    create: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput>
  }

  export type chatusersCreateManyChatsInputEnvelope = {
    data: chatusersCreateManyChatsInput | chatusersCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutChatsInput = {
    id: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaCreateNestedManyWithoutMessagesInput
    users: usersCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutChatsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesCreateOrConnectWithoutChatsInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesCreateManyChatsInputEnvelope = {
    data: messagesCreateManyChatsInput | messagesCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type chatGroupsUpsertWithoutChatsInput = {
    update: XOR<chatGroupsUpdateWithoutChatsInput, chatGroupsUncheckedUpdateWithoutChatsInput>
    create: XOR<chatGroupsCreateWithoutChatsInput, chatGroupsUncheckedCreateWithoutChatsInput>
    where?: chatGroupsWhereInput
  }

  export type chatGroupsUpdateToOneWithWhereWithoutChatsInput = {
    where?: chatGroupsWhereInput
    data: XOR<chatGroupsUpdateWithoutChatsInput, chatGroupsUncheckedUpdateWithoutChatsInput>
  }

  export type chatGroupsUpdateWithoutChatsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatGroupsUncheckedUpdateWithoutChatsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatusersUpsertWithWhereUniqueWithoutChatsInput = {
    where: chatusersWhereUniqueInput
    update: XOR<chatusersUpdateWithoutChatsInput, chatusersUncheckedUpdateWithoutChatsInput>
    create: XOR<chatusersCreateWithoutChatsInput, chatusersUncheckedCreateWithoutChatsInput>
  }

  export type chatusersUpdateWithWhereUniqueWithoutChatsInput = {
    where: chatusersWhereUniqueInput
    data: XOR<chatusersUpdateWithoutChatsInput, chatusersUncheckedUpdateWithoutChatsInput>
  }

  export type chatusersUpdateManyWithWhereWithoutChatsInput = {
    where: chatusersScalarWhereInput
    data: XOR<chatusersUpdateManyMutationInput, chatusersUncheckedUpdateManyWithoutChatsInput>
  }

  export type chatusersScalarWhereInput = {
    AND?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
    OR?: chatusersScalarWhereInput[]
    NOT?: chatusersScalarWhereInput | chatusersScalarWhereInput[]
    id?: StringFilter<"chatusers"> | string
    userId?: StringFilter<"chatusers"> | string
    chatId?: StringFilter<"chatusers"> | string
  }

  export type messagesUpsertWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
  }

  export type messagesUpdateManyWithWhereWithoutChatsInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutChatsInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: StringFilter<"messages"> | string
    chatId?: StringFilter<"messages"> | string
    userId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    createdAt?: DateTimeFilter<"messages"> | Date | string
    status?: EnumMessageStatusFilter<"messages"> | $Enums.MessageStatus
  }

  export type chatsCreateWithoutChatusersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsCreateNestedOneWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutChatusersInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsUncheckedCreateNestedOneWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutChatusersInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutChatusersInput, chatsUncheckedCreateWithoutChatusersInput>
  }

  export type usersCreateWithoutChatusersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChatusersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChatusersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChatusersInput, usersUncheckedCreateWithoutChatusersInput>
  }

  export type chatsUpsertWithoutChatusersInput = {
    update: XOR<chatsUpdateWithoutChatusersInput, chatsUncheckedUpdateWithoutChatusersInput>
    create: XOR<chatsCreateWithoutChatusersInput, chatsUncheckedCreateWithoutChatusersInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutChatusersInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutChatusersInput, chatsUncheckedUpdateWithoutChatusersInput>
  }

  export type chatsUpdateWithoutChatusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUpdateOneWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutChatusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUncheckedUpdateOneWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type usersUpsertWithoutChatusersInput = {
    update: XOR<usersUpdateWithoutChatusersInput, usersUncheckedUpdateWithoutChatusersInput>
    create: XOR<usersCreateWithoutChatusersInput, usersUncheckedCreateWithoutChatusersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChatusersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChatusersInput, usersUncheckedUpdateWithoutChatusersInput>
  }

  export type usersUpdateWithoutChatusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChatusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tweetHashesCreateWithoutHashesInput = {
    tweets: tweetsCreateNestedOneWithoutTweetHashesInput
  }

  export type tweetHashesUncheckedCreateWithoutHashesInput = {
    tweetId: string
  }

  export type tweetHashesCreateOrConnectWithoutHashesInput = {
    where: tweetHashesWhereUniqueInput
    create: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput>
  }

  export type tweetHashesCreateManyHashesInputEnvelope = {
    data: tweetHashesCreateManyHashesInput | tweetHashesCreateManyHashesInput[]
    skipDuplicates?: boolean
  }

  export type tweetHashesUpsertWithWhereUniqueWithoutHashesInput = {
    where: tweetHashesWhereUniqueInput
    update: XOR<tweetHashesUpdateWithoutHashesInput, tweetHashesUncheckedUpdateWithoutHashesInput>
    create: XOR<tweetHashesCreateWithoutHashesInput, tweetHashesUncheckedCreateWithoutHashesInput>
  }

  export type tweetHashesUpdateWithWhereUniqueWithoutHashesInput = {
    where: tweetHashesWhereUniqueInput
    data: XOR<tweetHashesUpdateWithoutHashesInput, tweetHashesUncheckedUpdateWithoutHashesInput>
  }

  export type tweetHashesUpdateManyWithWhereWithoutHashesInput = {
    where: tweetHashesScalarWhereInput
    data: XOR<tweetHashesUpdateManyMutationInput, tweetHashesUncheckedUpdateManyWithoutHashesInput>
  }

  export type tweetHashesScalarWhereInput = {
    AND?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
    OR?: tweetHashesScalarWhereInput[]
    NOT?: tweetHashesScalarWhereInput | tweetHashesScalarWhereInput[]
    tweetId?: StringFilter<"tweetHashes"> | string
    hashId?: StringFilter<"tweetHashes"> | string
  }

  export type MessageMediaCreateWithoutMediasInput = {
    messages: messagesCreateNestedOneWithoutMessageMediaInput
  }

  export type MessageMediaUncheckedCreateWithoutMediasInput = {
    messageId: string
  }

  export type MessageMediaCreateOrConnectWithoutMediasInput = {
    where: MessageMediaWhereUniqueInput
    create: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput>
  }

  export type MessageMediaCreateManyMediasInputEnvelope = {
    data: MessageMediaCreateManyMediasInput | MessageMediaCreateManyMediasInput[]
    skipDuplicates?: boolean
  }

  export type TweetMediaCreateWithoutMediasInput = {
    tweets: tweetsCreateNestedOneWithoutTweetMediaInput
  }

  export type TweetMediaUncheckedCreateWithoutMediasInput = {
    tweetId: string
  }

  export type TweetMediaCreateOrConnectWithoutMediasInput = {
    where: TweetMediaWhereUniqueInput
    create: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput>
  }

  export type TweetMediaCreateManyMediasInputEnvelope = {
    data: TweetMediaCreateManyMediasInput | TweetMediaCreateManyMediasInput[]
    skipDuplicates?: boolean
  }

  export type MessageMediaUpsertWithWhereUniqueWithoutMediasInput = {
    where: MessageMediaWhereUniqueInput
    update: XOR<MessageMediaUpdateWithoutMediasInput, MessageMediaUncheckedUpdateWithoutMediasInput>
    create: XOR<MessageMediaCreateWithoutMediasInput, MessageMediaUncheckedCreateWithoutMediasInput>
  }

  export type MessageMediaUpdateWithWhereUniqueWithoutMediasInput = {
    where: MessageMediaWhereUniqueInput
    data: XOR<MessageMediaUpdateWithoutMediasInput, MessageMediaUncheckedUpdateWithoutMediasInput>
  }

  export type MessageMediaUpdateManyWithWhereWithoutMediasInput = {
    where: MessageMediaScalarWhereInput
    data: XOR<MessageMediaUpdateManyMutationInput, MessageMediaUncheckedUpdateManyWithoutMediasInput>
  }

  export type MessageMediaScalarWhereInput = {
    AND?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
    OR?: MessageMediaScalarWhereInput[]
    NOT?: MessageMediaScalarWhereInput | MessageMediaScalarWhereInput[]
    messageId?: StringFilter<"MessageMedia"> | string
    mediaId?: StringFilter<"MessageMedia"> | string
  }

  export type TweetMediaUpsertWithWhereUniqueWithoutMediasInput = {
    where: TweetMediaWhereUniqueInput
    update: XOR<TweetMediaUpdateWithoutMediasInput, TweetMediaUncheckedUpdateWithoutMediasInput>
    create: XOR<TweetMediaCreateWithoutMediasInput, TweetMediaUncheckedCreateWithoutMediasInput>
  }

  export type TweetMediaUpdateWithWhereUniqueWithoutMediasInput = {
    where: TweetMediaWhereUniqueInput
    data: XOR<TweetMediaUpdateWithoutMediasInput, TweetMediaUncheckedUpdateWithoutMediasInput>
  }

  export type TweetMediaUpdateManyWithWhereWithoutMediasInput = {
    where: TweetMediaScalarWhereInput
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyWithoutMediasInput>
  }

  export type TweetMediaScalarWhereInput = {
    AND?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
    OR?: TweetMediaScalarWhereInput[]
    NOT?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
    tweetId?: StringFilter<"TweetMedia"> | string
    mediaId?: StringFilter<"TweetMedia"> | string
  }

  export type MessageMediaCreateWithoutMessagesInput = {
    medias: mediasCreateNestedOneWithoutMessageMediaInput
  }

  export type MessageMediaUncheckedCreateWithoutMessagesInput = {
    mediaId: string
  }

  export type MessageMediaCreateOrConnectWithoutMessagesInput = {
    where: MessageMediaWhereUniqueInput
    create: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput>
  }

  export type MessageMediaCreateManyMessagesInputEnvelope = {
    data: MessageMediaCreateManyMessagesInput | MessageMediaCreateManyMessagesInput[]
    skipDuplicates?: boolean
  }

  export type chatsCreateWithoutMessagesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsCreateNestedOneWithoutChatsInput
    chatusers?: chatusersCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutMessagesInput = {
    id: string
    createdAt?: Date | string
    updatedAt: Date | string
    DMChat: boolean
    chatGroups?: chatGroupsUncheckedCreateNestedOneWithoutChatsInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutMessagesInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
  }

  export type usersCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
  }

  export type MessageMediaUpsertWithWhereUniqueWithoutMessagesInput = {
    where: MessageMediaWhereUniqueInput
    update: XOR<MessageMediaUpdateWithoutMessagesInput, MessageMediaUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageMediaCreateWithoutMessagesInput, MessageMediaUncheckedCreateWithoutMessagesInput>
  }

  export type MessageMediaUpdateWithWhereUniqueWithoutMessagesInput = {
    where: MessageMediaWhereUniqueInput
    data: XOR<MessageMediaUpdateWithoutMessagesInput, MessageMediaUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageMediaUpdateManyWithWhereWithoutMessagesInput = {
    where: MessageMediaScalarWhereInput
    data: XOR<MessageMediaUpdateManyMutationInput, MessageMediaUncheckedUpdateManyWithoutMessagesInput>
  }

  export type chatsUpsertWithoutMessagesInput = {
    update: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutMessagesInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type chatsUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUpdateOneWithoutChatsNestedInput
    chatusers?: chatusersUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DMChat?: BoolFieldUpdateOperationsInput | boolean
    chatGroups?: chatGroupsUncheckedUpdateOneWithoutChatsNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type usersUpsertWithoutMessagesInput = {
    update: XOR<usersUpdateWithoutMessagesInput, usersUncheckedUpdateWithoutMessagesInput>
    create: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessagesInput, usersUncheckedUpdateWithoutMessagesInput>
  }

  export type usersUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotifications_notifications_actorIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotifications_notifications_actorIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotifications_notifications_actorIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_actorIdTousersInput>
  }

  export type tweetsCreateWithoutNotificationsInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutNotificationsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutNotificationsInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutNotificationsInput, tweetsUncheckedCreateWithoutNotificationsInput>
  }

  export type usersCreateWithoutNotifications_notifications_userIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotifications_notifications_userIdTousersInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotifications_notifications_userIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_userIdTousersInput>
  }

  export type usersUpsertWithoutNotifications_notifications_actorIdTousersInput = {
    update: XOR<usersUpdateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedUpdateWithoutNotifications_notifications_actorIdTousersInput>
    create: XOR<usersCreateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_actorIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotifications_notifications_actorIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotifications_notifications_actorIdTousersInput, usersUncheckedUpdateWithoutNotifications_notifications_actorIdTousersInput>
  }

  export type usersUpdateWithoutNotifications_notifications_actorIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotifications_notifications_actorIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tweetsUpsertWithoutNotificationsInput = {
    update: XOR<tweetsUpdateWithoutNotificationsInput, tweetsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<tweetsCreateWithoutNotificationsInput, tweetsUncheckedCreateWithoutNotificationsInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutNotificationsInput, tweetsUncheckedUpdateWithoutNotificationsInput>
  }

  export type tweetsUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type usersUpsertWithoutNotifications_notifications_userIdTousersInput = {
    update: XOR<usersUpdateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedUpdateWithoutNotifications_notifications_userIdTousersInput>
    create: XOR<usersCreateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedCreateWithoutNotifications_notifications_userIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotifications_notifications_userIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotifications_notifications_userIdTousersInput, usersUncheckedUpdateWithoutNotifications_notifications_userIdTousersInput>
  }

  export type usersUpdateWithoutNotifications_notifications_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotifications_notifications_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type hashesCreateWithoutTweetHashesInput = {
    id: string
    tag_text: string
  }

  export type hashesUncheckedCreateWithoutTweetHashesInput = {
    id: string
    tag_text: string
  }

  export type hashesCreateOrConnectWithoutTweetHashesInput = {
    where: hashesWhereUniqueInput
    create: XOR<hashesCreateWithoutTweetHashesInput, hashesUncheckedCreateWithoutTweetHashesInput>
  }

  export type tweetsCreateWithoutTweetHashesInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetHashesInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetHashesInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetHashesInput, tweetsUncheckedCreateWithoutTweetHashesInput>
  }

  export type hashesUpsertWithoutTweetHashesInput = {
    update: XOR<hashesUpdateWithoutTweetHashesInput, hashesUncheckedUpdateWithoutTweetHashesInput>
    create: XOR<hashesCreateWithoutTweetHashesInput, hashesUncheckedCreateWithoutTweetHashesInput>
    where?: hashesWhereInput
  }

  export type hashesUpdateToOneWithWhereWithoutTweetHashesInput = {
    where?: hashesWhereInput
    data: XOR<hashesUpdateWithoutTweetHashesInput, hashesUncheckedUpdateWithoutTweetHashesInput>
  }

  export type hashesUpdateWithoutTweetHashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
  }

  export type hashesUncheckedUpdateWithoutTweetHashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_text?: StringFieldUpdateOperationsInput | string
  }

  export type tweetsUpsertWithoutTweetHashesInput = {
    update: XOR<tweetsUpdateWithoutTweetHashesInput, tweetsUncheckedUpdateWithoutTweetHashesInput>
    create: XOR<tweetsCreateWithoutTweetHashesInput, tweetsUncheckedCreateWithoutTweetHashesInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutTweetHashesInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutTweetHashesInput, tweetsUncheckedUpdateWithoutTweetHashesInput>
  }

  export type tweetsUpdateWithoutTweetHashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetHashesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsCreateWithoutTweetbookmarksInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetbookmarksInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetbookmarksInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetbookmarksInput, tweetsUncheckedCreateWithoutTweetbookmarksInput>
  }

  export type usersCreateWithoutTweetbookmarksInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTweetbookmarksInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTweetbookmarksInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTweetbookmarksInput, usersUncheckedCreateWithoutTweetbookmarksInput>
  }

  export type tweetsUpsertWithoutTweetbookmarksInput = {
    update: XOR<tweetsUpdateWithoutTweetbookmarksInput, tweetsUncheckedUpdateWithoutTweetbookmarksInput>
    create: XOR<tweetsCreateWithoutTweetbookmarksInput, tweetsUncheckedCreateWithoutTweetbookmarksInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutTweetbookmarksInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutTweetbookmarksInput, tweetsUncheckedUpdateWithoutTweetbookmarksInput>
  }

  export type tweetsUpdateWithoutTweetbookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetbookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type usersUpsertWithoutTweetbookmarksInput = {
    update: XOR<usersUpdateWithoutTweetbookmarksInput, usersUncheckedUpdateWithoutTweetbookmarksInput>
    create: XOR<usersCreateWithoutTweetbookmarksInput, usersUncheckedCreateWithoutTweetbookmarksInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTweetbookmarksInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTweetbookmarksInput, usersUncheckedUpdateWithoutTweetbookmarksInput>
  }

  export type usersUpdateWithoutTweetbookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTweetbookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type MentionCreateWithoutTweetsInput = {
    users_Mention_mentionedIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionedIdTousersInput
    users_Mention_mentionerIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionerIdTousersInput
  }

  export type MentionUncheckedCreateWithoutTweetsInput = {
    mentionerId: string
    mentionedId: string
  }

  export type MentionCreateOrConnectWithoutTweetsInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput>
  }

  export type MentionCreateManyTweetsInputEnvelope = {
    data: MentionCreateManyTweetsInput | MentionCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type RetweetCreateWithoutTweetsInput = {
    users: usersCreateNestedOneWithoutRetweetInput
  }

  export type RetweetUncheckedCreateWithoutTweetsInput = {
    userId: string
  }

  export type RetweetCreateOrConnectWithoutTweetsInput = {
    where: RetweetWhereUniqueInput
    create: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput>
  }

  export type RetweetCreateManyTweetsInputEnvelope = {
    data: RetweetCreateManyTweetsInput | RetweetCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type TweetLikeCreateWithoutTweetsInput = {
    users: usersCreateNestedOneWithoutTweetLikeInput
  }

  export type TweetLikeUncheckedCreateWithoutTweetsInput = {
    userId: string
  }

  export type TweetLikeCreateOrConnectWithoutTweetsInput = {
    where: TweetLikeWhereUniqueInput
    create: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput>
  }

  export type TweetLikeCreateManyTweetsInputEnvelope = {
    data: TweetLikeCreateManyTweetsInput | TweetLikeCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type TweetMediaCreateWithoutTweetsInput = {
    medias: mediasCreateNestedOneWithoutTweetMediaInput
  }

  export type TweetMediaUncheckedCreateWithoutTweetsInput = {
    mediaId: string
  }

  export type TweetMediaCreateOrConnectWithoutTweetsInput = {
    where: TweetMediaWhereUniqueInput
    create: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput>
  }

  export type TweetMediaCreateManyTweetsInputEnvelope = {
    data: TweetMediaCreateManyTweetsInput | TweetMediaCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type TweetSummaryCreateWithoutTweetsInput = {
    id: string
    summary: string
  }

  export type TweetSummaryUncheckedCreateWithoutTweetsInput = {
    id: string
    summary: string
  }

  export type TweetSummaryCreateOrConnectWithoutTweetsInput = {
    where: TweetSummaryWhereUniqueInput
    create: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
  }

  export type notificationsCreateWithoutTweetsInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    users_notifications_actorIdTousers?: usersCreateNestedOneWithoutNotifications_notifications_actorIdTousersInput
    users_notifications_userIdTousers: usersCreateNestedOneWithoutNotifications_notifications_userIdTousersInput
  }

  export type notificationsUncheckedCreateWithoutTweetsInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    actorId?: string | null
  }

  export type notificationsCreateOrConnectWithoutTweetsInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput>
  }

  export type notificationsCreateManyTweetsInputEnvelope = {
    data: notificationsCreateManyTweetsInput | notificationsCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type tweetHashesCreateWithoutTweetsInput = {
    hashes: hashesCreateNestedOneWithoutTweetHashesInput
  }

  export type tweetHashesUncheckedCreateWithoutTweetsInput = {
    hashId: string
  }

  export type tweetHashesCreateOrConnectWithoutTweetsInput = {
    where: tweetHashesWhereUniqueInput
    create: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput>
  }

  export type tweetHashesCreateManyTweetsInputEnvelope = {
    data: tweetHashesCreateManyTweetsInput | tweetHashesCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type tweetbookmarksCreateWithoutTweetsInput = {
    id: string
    users: usersCreateNestedOneWithoutTweetbookmarksInput
  }

  export type tweetbookmarksUncheckedCreateWithoutTweetsInput = {
    id: string
    userId: string
  }

  export type tweetbookmarksCreateOrConnectWithoutTweetsInput = {
    where: tweetbookmarksWhereUniqueInput
    create: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput>
  }

  export type tweetbookmarksCreateManyTweetsInputEnvelope = {
    data: tweetbookmarksCreateManyTweetsInput | tweetbookmarksCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type tweetsCreateWithoutOther_tweetsInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutOther_tweetsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutOther_tweetsInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutOther_tweetsInput, tweetsUncheckedCreateWithoutOther_tweetsInput>
  }

  export type tweetsCreateWithoutTweetsInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
    users: usersCreateNestedOneWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutTweetsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutTweetsInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput>
  }

  export type tweetsCreateManyTweetsInputEnvelope = {
    data: tweetsCreateManyTweetsInput | tweetsCreateManyTweetsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTweetsInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTweetsInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTweetsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTweetsInput, usersUncheckedCreateWithoutTweetsInput>
  }

  export type MentionUpsertWithWhereUniqueWithoutTweetsInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutTweetsInput, MentionUncheckedUpdateWithoutTweetsInput>
    create: XOR<MentionCreateWithoutTweetsInput, MentionUncheckedCreateWithoutTweetsInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutTweetsInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutTweetsInput, MentionUncheckedUpdateWithoutTweetsInput>
  }

  export type MentionUpdateManyWithWhereWithoutTweetsInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutTweetsInput>
  }

  export type MentionScalarWhereInput = {
    AND?: MentionScalarWhereInput | MentionScalarWhereInput[]
    OR?: MentionScalarWhereInput[]
    NOT?: MentionScalarWhereInput | MentionScalarWhereInput[]
    tweetId?: StringFilter<"Mention"> | string
    mentionerId?: StringFilter<"Mention"> | string
    mentionedId?: StringFilter<"Mention"> | string
  }

  export type RetweetUpsertWithWhereUniqueWithoutTweetsInput = {
    where: RetweetWhereUniqueInput
    update: XOR<RetweetUpdateWithoutTweetsInput, RetweetUncheckedUpdateWithoutTweetsInput>
    create: XOR<RetweetCreateWithoutTweetsInput, RetweetUncheckedCreateWithoutTweetsInput>
  }

  export type RetweetUpdateWithWhereUniqueWithoutTweetsInput = {
    where: RetweetWhereUniqueInput
    data: XOR<RetweetUpdateWithoutTweetsInput, RetweetUncheckedUpdateWithoutTweetsInput>
  }

  export type RetweetUpdateManyWithWhereWithoutTweetsInput = {
    where: RetweetScalarWhereInput
    data: XOR<RetweetUpdateManyMutationInput, RetweetUncheckedUpdateManyWithoutTweetsInput>
  }

  export type RetweetScalarWhereInput = {
    AND?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
    OR?: RetweetScalarWhereInput[]
    NOT?: RetweetScalarWhereInput | RetweetScalarWhereInput[]
    userId?: StringFilter<"Retweet"> | string
    tweetId?: StringFilter<"Retweet"> | string
  }

  export type TweetLikeUpsertWithWhereUniqueWithoutTweetsInput = {
    where: TweetLikeWhereUniqueInput
    update: XOR<TweetLikeUpdateWithoutTweetsInput, TweetLikeUncheckedUpdateWithoutTweetsInput>
    create: XOR<TweetLikeCreateWithoutTweetsInput, TweetLikeUncheckedCreateWithoutTweetsInput>
  }

  export type TweetLikeUpdateWithWhereUniqueWithoutTweetsInput = {
    where: TweetLikeWhereUniqueInput
    data: XOR<TweetLikeUpdateWithoutTweetsInput, TweetLikeUncheckedUpdateWithoutTweetsInput>
  }

  export type TweetLikeUpdateManyWithWhereWithoutTweetsInput = {
    where: TweetLikeScalarWhereInput
    data: XOR<TweetLikeUpdateManyMutationInput, TweetLikeUncheckedUpdateManyWithoutTweetsInput>
  }

  export type TweetLikeScalarWhereInput = {
    AND?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
    OR?: TweetLikeScalarWhereInput[]
    NOT?: TweetLikeScalarWhereInput | TweetLikeScalarWhereInput[]
    tweetId?: StringFilter<"TweetLike"> | string
    userId?: StringFilter<"TweetLike"> | string
  }

  export type TweetMediaUpsertWithWhereUniqueWithoutTweetsInput = {
    where: TweetMediaWhereUniqueInput
    update: XOR<TweetMediaUpdateWithoutTweetsInput, TweetMediaUncheckedUpdateWithoutTweetsInput>
    create: XOR<TweetMediaCreateWithoutTweetsInput, TweetMediaUncheckedCreateWithoutTweetsInput>
  }

  export type TweetMediaUpdateWithWhereUniqueWithoutTweetsInput = {
    where: TweetMediaWhereUniqueInput
    data: XOR<TweetMediaUpdateWithoutTweetsInput, TweetMediaUncheckedUpdateWithoutTweetsInput>
  }

  export type TweetMediaUpdateManyWithWhereWithoutTweetsInput = {
    where: TweetMediaScalarWhereInput
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyWithoutTweetsInput>
  }

  export type TweetSummaryUpsertWithoutTweetsInput = {
    update: XOR<TweetSummaryUpdateWithoutTweetsInput, TweetSummaryUncheckedUpdateWithoutTweetsInput>
    create: XOR<TweetSummaryCreateWithoutTweetsInput, TweetSummaryUncheckedCreateWithoutTweetsInput>
    where?: TweetSummaryWhereInput
  }

  export type TweetSummaryUpdateToOneWithWhereWithoutTweetsInput = {
    where?: TweetSummaryWhereInput
    data: XOR<TweetSummaryUpdateWithoutTweetsInput, TweetSummaryUncheckedUpdateWithoutTweetsInput>
  }

  export type TweetSummaryUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
  }

  export type TweetSummaryUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUpsertWithWhereUniqueWithoutTweetsInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutTweetsInput, notificationsUncheckedUpdateWithoutTweetsInput>
    create: XOR<notificationsCreateWithoutTweetsInput, notificationsUncheckedCreateWithoutTweetsInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutTweetsInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutTweetsInput, notificationsUncheckedUpdateWithoutTweetsInput>
  }

  export type notificationsUpdateManyWithWhereWithoutTweetsInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutTweetsInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    content?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    userId?: StringFilter<"notifications"> | string
    tweetId?: StringNullableFilter<"notifications"> | string | null
    actorId?: StringNullableFilter<"notifications"> | string | null
  }

  export type tweetHashesUpsertWithWhereUniqueWithoutTweetsInput = {
    where: tweetHashesWhereUniqueInput
    update: XOR<tweetHashesUpdateWithoutTweetsInput, tweetHashesUncheckedUpdateWithoutTweetsInput>
    create: XOR<tweetHashesCreateWithoutTweetsInput, tweetHashesUncheckedCreateWithoutTweetsInput>
  }

  export type tweetHashesUpdateWithWhereUniqueWithoutTweetsInput = {
    where: tweetHashesWhereUniqueInput
    data: XOR<tweetHashesUpdateWithoutTweetsInput, tweetHashesUncheckedUpdateWithoutTweetsInput>
  }

  export type tweetHashesUpdateManyWithWhereWithoutTweetsInput = {
    where: tweetHashesScalarWhereInput
    data: XOR<tweetHashesUpdateManyMutationInput, tweetHashesUncheckedUpdateManyWithoutTweetsInput>
  }

  export type tweetbookmarksUpsertWithWhereUniqueWithoutTweetsInput = {
    where: tweetbookmarksWhereUniqueInput
    update: XOR<tweetbookmarksUpdateWithoutTweetsInput, tweetbookmarksUncheckedUpdateWithoutTweetsInput>
    create: XOR<tweetbookmarksCreateWithoutTweetsInput, tweetbookmarksUncheckedCreateWithoutTweetsInput>
  }

  export type tweetbookmarksUpdateWithWhereUniqueWithoutTweetsInput = {
    where: tweetbookmarksWhereUniqueInput
    data: XOR<tweetbookmarksUpdateWithoutTweetsInput, tweetbookmarksUncheckedUpdateWithoutTweetsInput>
  }

  export type tweetbookmarksUpdateManyWithWhereWithoutTweetsInput = {
    where: tweetbookmarksScalarWhereInput
    data: XOR<tweetbookmarksUpdateManyMutationInput, tweetbookmarksUncheckedUpdateManyWithoutTweetsInput>
  }

  export type tweetbookmarksScalarWhereInput = {
    AND?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
    OR?: tweetbookmarksScalarWhereInput[]
    NOT?: tweetbookmarksScalarWhereInput | tweetbookmarksScalarWhereInput[]
    id?: StringFilter<"tweetbookmarks"> | string
    userId?: StringFilter<"tweetbookmarks"> | string
    tweetId?: StringFilter<"tweetbookmarks"> | string
  }

  export type tweetsUpsertWithoutOther_tweetsInput = {
    update: XOR<tweetsUpdateWithoutOther_tweetsInput, tweetsUncheckedUpdateWithoutOther_tweetsInput>
    create: XOR<tweetsCreateWithoutOther_tweetsInput, tweetsUncheckedCreateWithoutOther_tweetsInput>
    where?: tweetsWhereInput
  }

  export type tweetsUpdateToOneWithWhereWithoutOther_tweetsInput = {
    where?: tweetsWhereInput
    data: XOR<tweetsUpdateWithoutOther_tweetsInput, tweetsUncheckedUpdateWithoutOther_tweetsInput>
  }

  export type tweetsUpdateWithoutOther_tweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutOther_tweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsUpsertWithWhereUniqueWithoutTweetsInput = {
    where: tweetsWhereUniqueInput
    update: XOR<tweetsUpdateWithoutTweetsInput, tweetsUncheckedUpdateWithoutTweetsInput>
    create: XOR<tweetsCreateWithoutTweetsInput, tweetsUncheckedCreateWithoutTweetsInput>
  }

  export type tweetsUpdateWithWhereUniqueWithoutTweetsInput = {
    where: tweetsWhereUniqueInput
    data: XOR<tweetsUpdateWithoutTweetsInput, tweetsUncheckedUpdateWithoutTweetsInput>
  }

  export type tweetsUpdateManyWithWhereWithoutTweetsInput = {
    where: tweetsScalarWhereInput
    data: XOR<tweetsUpdateManyMutationInput, tweetsUncheckedUpdateManyWithoutTweetsInput>
  }

  export type tweetsScalarWhereInput = {
    AND?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
    OR?: tweetsScalarWhereInput[]
    NOT?: tweetsScalarWhereInput | tweetsScalarWhereInput[]
    id?: StringFilter<"tweets"> | string
    userId?: StringFilter<"tweets"> | string
    content?: StringFilter<"tweets"> | string
    createdAt?: DateTimeFilter<"tweets"> | Date | string
    likesCount?: IntFilter<"tweets"> | number
    retweetCount?: IntFilter<"tweets"> | number
    repliesCount?: IntFilter<"tweets"> | number
    parentId?: StringNullableFilter<"tweets"> | string | null
    tweetType?: EnumTweetTypeFilter<"tweets"> | $Enums.TweetType
    replyControl?: EnumReplyControlFilter<"tweets"> | $Enums.ReplyControl
  }

  export type usersUpsertWithoutTweetsInput = {
    update: XOR<usersUpdateWithoutTweetsInput, usersUncheckedUpdateWithoutTweetsInput>
    create: XOR<usersCreateWithoutTweetsInput, usersUncheckedCreateWithoutTweetsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTweetsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTweetsInput, usersUncheckedUpdateWithoutTweetsInput>
  }

  export type usersUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type DeviceRecordCreateWithoutUserInput = {
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
  }

  export type DeviceRecordUncheckedCreateWithoutUserInput = {
    id?: number
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
  }

  export type DeviceRecordCreateOrConnectWithoutUserInput = {
    where: DeviceRecordWhereUniqueInput
    create: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput>
  }

  export type DeviceRecordCreateManyUserInputEnvelope = {
    data: DeviceRecordCreateManyUserInput | DeviceRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OldPasswordCreateWithoutUserInput = {
    password: string
  }

  export type OldPasswordUncheckedCreateWithoutUserInput = {
    id?: number
    password: string
  }

  export type OldPasswordCreateOrConnectWithoutUserInput = {
    where: OldPasswordWhereUniqueInput
    create: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput>
  }

  export type OldPasswordCreateManyUserInputEnvelope = {
    data: OldPasswordCreateManyUserInput | OldPasswordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutUsers_Block_blockedIdTousersInput = {
    users_Block_blockerIdTousers: usersCreateNestedOneWithoutBlock_Block_blockerIdTousersInput
  }

  export type BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput = {
    blockerId: string
  }

  export type BlockCreateOrConnectWithoutUsers_Block_blockedIdTousersInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput>
  }

  export type BlockCreateManyUsers_Block_blockedIdTousersInputEnvelope = {
    data: BlockCreateManyUsers_Block_blockedIdTousersInput | BlockCreateManyUsers_Block_blockedIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutUsers_Block_blockerIdTousersInput = {
    users_Block_blockedIdTousers: usersCreateNestedOneWithoutBlock_Block_blockedIdTousersInput
  }

  export type BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput = {
    blockedId: string
  }

  export type BlockCreateOrConnectWithoutUsers_Block_blockerIdTousersInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput>
  }

  export type BlockCreateManyUsers_Block_blockerIdTousersInputEnvelope = {
    data: BlockCreateManyUsers_Block_blockerIdTousersInput | BlockCreateManyUsers_Block_blockerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutUsers_Follow_followerIdTousersInput = {
    status?: $Enums.FollowStatus
    users_Follow_followingIdTousers: usersCreateNestedOneWithoutFollow_Follow_followingIdTousersInput
  }

  export type FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput = {
    followingId: string
    status?: $Enums.FollowStatus
  }

  export type FollowCreateOrConnectWithoutUsers_Follow_followerIdTousersInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput>
  }

  export type FollowCreateManyUsers_Follow_followerIdTousersInputEnvelope = {
    data: FollowCreateManyUsers_Follow_followerIdTousersInput | FollowCreateManyUsers_Follow_followerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutUsers_Follow_followingIdTousersInput = {
    status?: $Enums.FollowStatus
    users_Follow_followerIdTousers: usersCreateNestedOneWithoutFollow_Follow_followerIdTousersInput
  }

  export type FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput = {
    followerId: string
    status?: $Enums.FollowStatus
  }

  export type FollowCreateOrConnectWithoutUsers_Follow_followingIdTousersInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput>
  }

  export type FollowCreateManyUsers_Follow_followingIdTousersInputEnvelope = {
    data: FollowCreateManyUsers_Follow_followingIdTousersInput | FollowCreateManyUsers_Follow_followingIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type MentionCreateWithoutUsers_Mention_mentionedIdTousersInput = {
    users_Mention_mentionerIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionerIdTousersInput
    tweets: tweetsCreateNestedOneWithoutMentionInput
  }

  export type MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput = {
    tweetId: string
    mentionerId: string
  }

  export type MentionCreateOrConnectWithoutUsers_Mention_mentionedIdTousersInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput>
  }

  export type MentionCreateManyUsers_Mention_mentionedIdTousersInputEnvelope = {
    data: MentionCreateManyUsers_Mention_mentionedIdTousersInput | MentionCreateManyUsers_Mention_mentionedIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type MentionCreateWithoutUsers_Mention_mentionerIdTousersInput = {
    users_Mention_mentionedIdTousers: usersCreateNestedOneWithoutMention_Mention_mentionedIdTousersInput
    tweets: tweetsCreateNestedOneWithoutMentionInput
  }

  export type MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput = {
    tweetId: string
    mentionedId: string
  }

  export type MentionCreateOrConnectWithoutUsers_Mention_mentionerIdTousersInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput>
  }

  export type MentionCreateManyUsers_Mention_mentionerIdTousersInputEnvelope = {
    data: MentionCreateManyUsers_Mention_mentionerIdTousersInput | MentionCreateManyUsers_Mention_mentionerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutUsers_Mute_mutedIdTousersInput = {
    users_Mute_muterIdTousers: usersCreateNestedOneWithoutMute_Mute_muterIdTousersInput
  }

  export type MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput = {
    muterId: string
  }

  export type MuteCreateOrConnectWithoutUsers_Mute_mutedIdTousersInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput>
  }

  export type MuteCreateManyUsers_Mute_mutedIdTousersInputEnvelope = {
    data: MuteCreateManyUsers_Mute_mutedIdTousersInput | MuteCreateManyUsers_Mute_mutedIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutUsers_Mute_muterIdTousersInput = {
    users_Mute_mutedIdTousers: usersCreateNestedOneWithoutMute_Mute_mutedIdTousersInput
  }

  export type MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput = {
    mutedId: string
  }

  export type MuteCreateOrConnectWithoutUsers_Mute_muterIdTousersInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput>
  }

  export type MuteCreateManyUsers_Mute_muterIdTousersInputEnvelope = {
    data: MuteCreateManyUsers_Mute_muterIdTousersInput | MuteCreateManyUsers_Mute_muterIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type RetweetCreateWithoutUsersInput = {
    tweets: tweetsCreateNestedOneWithoutRetweetInput
  }

  export type RetweetUncheckedCreateWithoutUsersInput = {
    tweetId: string
  }

  export type RetweetCreateOrConnectWithoutUsersInput = {
    where: RetweetWhereUniqueInput
    create: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput>
  }

  export type RetweetCreateManyUsersInputEnvelope = {
    data: RetweetCreateManyUsersInput | RetweetCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type TweetLikeCreateWithoutUsersInput = {
    tweets: tweetsCreateNestedOneWithoutTweetLikeInput
  }

  export type TweetLikeUncheckedCreateWithoutUsersInput = {
    tweetId: string
  }

  export type TweetLikeCreateOrConnectWithoutUsersInput = {
    where: TweetLikeWhereUniqueInput
    create: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput>
  }

  export type TweetLikeCreateManyUsersInputEnvelope = {
    data: TweetLikeCreateManyUsersInput | TweetLikeCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type chatusersCreateWithoutUsersInput = {
    id: string
    chats: chatsCreateNestedOneWithoutChatusersInput
  }

  export type chatusersUncheckedCreateWithoutUsersInput = {
    id: string
    chatId: string
  }

  export type chatusersCreateOrConnectWithoutUsersInput = {
    where: chatusersWhereUniqueInput
    create: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput>
  }

  export type chatusersCreateManyUsersInputEnvelope = {
    data: chatusersCreateManyUsersInput | chatusersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaCreateNestedManyWithoutMessagesInput
    chats: chatsCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutUsersInput = {
    id: string
    chatId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesCreateOrConnectWithoutUsersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput>
  }

  export type messagesCreateManyUsersInputEnvelope = {
    data: messagesCreateManyUsersInput | messagesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsers_notifications_actorIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    tweets?: tweetsCreateNestedOneWithoutNotificationsInput
    users_notifications_userIdTousers: usersCreateNestedOneWithoutNotifications_notifications_userIdTousersInput
  }

  export type notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    tweetId?: string | null
  }

  export type notificationsCreateOrConnectWithoutUsers_notifications_actorIdTousersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput>
  }

  export type notificationsCreateManyUsers_notifications_actorIdTousersInputEnvelope = {
    data: notificationsCreateManyUsers_notifications_actorIdTousersInput | notificationsCreateManyUsers_notifications_actorIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsers_notifications_userIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    users_notifications_actorIdTousers?: usersCreateNestedOneWithoutNotifications_notifications_actorIdTousersInput
    tweets?: tweetsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    tweetId?: string | null
    actorId?: string | null
  }

  export type notificationsCreateOrConnectWithoutUsers_notifications_userIdTousersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput>
  }

  export type notificationsCreateManyUsers_notifications_userIdTousersInputEnvelope = {
    data: notificationsCreateManyUsers_notifications_userIdTousersInput | notificationsCreateManyUsers_notifications_userIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type tweetbookmarksCreateWithoutUsersInput = {
    id: string
    tweets: tweetsCreateNestedOneWithoutTweetbookmarksInput
  }

  export type tweetbookmarksUncheckedCreateWithoutUsersInput = {
    id: string
    tweetId: string
  }

  export type tweetbookmarksCreateOrConnectWithoutUsersInput = {
    where: tweetbookmarksWhereUniqueInput
    create: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput>
  }

  export type tweetbookmarksCreateManyUsersInputEnvelope = {
    data: tweetbookmarksCreateManyUsersInput | tweetbookmarksCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type tweetsCreateWithoutUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryCreateNestedOneWithoutTweetsInput
    notifications?: notificationsCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutTweetsInput
    tweets?: tweetsCreateNestedOneWithoutOther_tweetsInput
    other_tweets?: tweetsCreateNestedManyWithoutTweetsInput
  }

  export type tweetsUncheckedCreateWithoutUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
    Mention?: MentionUncheckedCreateNestedManyWithoutTweetsInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutTweetsInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutTweetsInput
    TweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetsInput
    TweetSummary?: TweetSummaryUncheckedCreateNestedOneWithoutTweetsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutTweetsInput
    tweetHashes?: tweetHashesUncheckedCreateNestedManyWithoutTweetsInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutTweetsInput
    other_tweets?: tweetsUncheckedCreateNestedManyWithoutTweetsInput
  }

  export type tweetsCreateOrConnectWithoutUsersInput = {
    where: tweetsWhereUniqueInput
    create: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput>
  }

  export type tweetsCreateManyUsersInputEnvelope = {
    data: tweetsCreateManyUsersInput | tweetsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type DeviceRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceRecordWhereUniqueInput
    update: XOR<DeviceRecordUpdateWithoutUserInput, DeviceRecordUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceRecordCreateWithoutUserInput, DeviceRecordUncheckedCreateWithoutUserInput>
  }

  export type DeviceRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceRecordWhereUniqueInput
    data: XOR<DeviceRecordUpdateWithoutUserInput, DeviceRecordUncheckedUpdateWithoutUserInput>
  }

  export type DeviceRecordUpdateManyWithWhereWithoutUserInput = {
    where: DeviceRecordScalarWhereInput
    data: XOR<DeviceRecordUpdateManyMutationInput, DeviceRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceRecordScalarWhereInput = {
    AND?: DeviceRecordScalarWhereInput | DeviceRecordScalarWhereInput[]
    OR?: DeviceRecordScalarWhereInput[]
    NOT?: DeviceRecordScalarWhereInput | DeviceRecordScalarWhereInput[]
    id?: IntFilter<"DeviceRecord"> | number
    userid?: StringFilter<"DeviceRecord"> | string
    city?: StringNullableFilter<"DeviceRecord"> | string | null
    region?: StringNullableFilter<"DeviceRecord"> | string | null
    country?: StringNullableFilter<"DeviceRecord"> | string | null
    locale?: StringNullableFilter<"DeviceRecord"> | string | null
    lat?: FloatNullableFilter<"DeviceRecord"> | number | null
    lon?: FloatNullableFilter<"DeviceRecord"> | number | null
    zipcode?: StringNullableFilter<"DeviceRecord"> | string | null
    last_login?: DateTimeNullableFilter<"DeviceRecord"> | Date | string | null
    browser?: StringNullableFilter<"DeviceRecord"> | string | null
  }

  export type OldPasswordUpsertWithWhereUniqueWithoutUserInput = {
    where: OldPasswordWhereUniqueInput
    update: XOR<OldPasswordUpdateWithoutUserInput, OldPasswordUncheckedUpdateWithoutUserInput>
    create: XOR<OldPasswordCreateWithoutUserInput, OldPasswordUncheckedCreateWithoutUserInput>
  }

  export type OldPasswordUpdateWithWhereUniqueWithoutUserInput = {
    where: OldPasswordWhereUniqueInput
    data: XOR<OldPasswordUpdateWithoutUserInput, OldPasswordUncheckedUpdateWithoutUserInput>
  }

  export type OldPasswordUpdateManyWithWhereWithoutUserInput = {
    where: OldPasswordScalarWhereInput
    data: XOR<OldPasswordUpdateManyMutationInput, OldPasswordUncheckedUpdateManyWithoutUserInput>
  }

  export type OldPasswordScalarWhereInput = {
    AND?: OldPasswordScalarWhereInput | OldPasswordScalarWhereInput[]
    OR?: OldPasswordScalarWhereInput[]
    NOT?: OldPasswordScalarWhereInput | OldPasswordScalarWhereInput[]
    id?: IntFilter<"OldPassword"> | number
    user_id?: StringFilter<"OldPassword"> | string
    password?: StringFilter<"OldPassword"> | string
  }

  export type BlockUpsertWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedUpdateWithoutUsers_Block_blockedIdTousersInput>
    create: XOR<BlockCreateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockedIdTousersInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutUsers_Block_blockedIdTousersInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutUsers_Block_blockedIdTousersInput, BlockUncheckedUpdateWithoutUsers_Block_blockedIdTousersInput>
  }

  export type BlockUpdateManyWithWhereWithoutUsers_Block_blockedIdTousersInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    blockedId?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
  }

  export type BlockUpsertWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedUpdateWithoutUsers_Block_blockerIdTousersInput>
    create: XOR<BlockCreateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedCreateWithoutUsers_Block_blockerIdTousersInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutUsers_Block_blockerIdTousersInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutUsers_Block_blockerIdTousersInput, BlockUncheckedUpdateWithoutUsers_Block_blockerIdTousersInput>
  }

  export type BlockUpdateManyWithWhereWithoutUsers_Block_blockerIdTousersInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersInput>
  }

  export type FollowUpsertWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedUpdateWithoutUsers_Follow_followerIdTousersInput>
    create: XOR<FollowCreateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followerIdTousersInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutUsers_Follow_followerIdTousersInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutUsers_Follow_followerIdTousersInput, FollowUncheckedUpdateWithoutUsers_Follow_followerIdTousersInput>
  }

  export type FollowUpdateManyWithWhereWithoutUsers_Follow_followerIdTousersInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    status?: EnumFollowStatusFilter<"Follow"> | $Enums.FollowStatus
  }

  export type FollowUpsertWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedUpdateWithoutUsers_Follow_followingIdTousersInput>
    create: XOR<FollowCreateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedCreateWithoutUsers_Follow_followingIdTousersInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutUsers_Follow_followingIdTousersInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutUsers_Follow_followingIdTousersInput, FollowUncheckedUpdateWithoutUsers_Follow_followingIdTousersInput>
  }

  export type FollowUpdateManyWithWhereWithoutUsers_Follow_followingIdTousersInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersInput>
  }

  export type MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedUpdateWithoutUsers_Mention_mentionedIdTousersInput>
    create: XOR<MentionCreateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionedIdTousersInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionedIdTousersInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutUsers_Mention_mentionedIdTousersInput, MentionUncheckedUpdateWithoutUsers_Mention_mentionedIdTousersInput>
  }

  export type MentionUpdateManyWithWhereWithoutUsers_Mention_mentionedIdTousersInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersInput>
  }

  export type MentionUpsertWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedUpdateWithoutUsers_Mention_mentionerIdTousersInput>
    create: XOR<MentionCreateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedCreateWithoutUsers_Mention_mentionerIdTousersInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutUsers_Mention_mentionerIdTousersInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutUsers_Mention_mentionerIdTousersInput, MentionUncheckedUpdateWithoutUsers_Mention_mentionerIdTousersInput>
  }

  export type MentionUpdateManyWithWhereWithoutUsers_Mention_mentionerIdTousersInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersInput>
  }

  export type MuteUpsertWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedUpdateWithoutUsers_Mute_mutedIdTousersInput>
    create: XOR<MuteCreateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_mutedIdTousersInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutUsers_Mute_mutedIdTousersInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutUsers_Mute_mutedIdTousersInput, MuteUncheckedUpdateWithoutUsers_Mute_mutedIdTousersInput>
  }

  export type MuteUpdateManyWithWhereWithoutUsers_Mute_mutedIdTousersInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersInput>
  }

  export type MuteScalarWhereInput = {
    AND?: MuteScalarWhereInput | MuteScalarWhereInput[]
    OR?: MuteScalarWhereInput[]
    NOT?: MuteScalarWhereInput | MuteScalarWhereInput[]
    mutedId?: StringFilter<"Mute"> | string
    muterId?: StringFilter<"Mute"> | string
  }

  export type MuteUpsertWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedUpdateWithoutUsers_Mute_muterIdTousersInput>
    create: XOR<MuteCreateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedCreateWithoutUsers_Mute_muterIdTousersInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutUsers_Mute_muterIdTousersInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutUsers_Mute_muterIdTousersInput, MuteUncheckedUpdateWithoutUsers_Mute_muterIdTousersInput>
  }

  export type MuteUpdateManyWithWhereWithoutUsers_Mute_muterIdTousersInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersInput>
  }

  export type RetweetUpsertWithWhereUniqueWithoutUsersInput = {
    where: RetweetWhereUniqueInput
    update: XOR<RetweetUpdateWithoutUsersInput, RetweetUncheckedUpdateWithoutUsersInput>
    create: XOR<RetweetCreateWithoutUsersInput, RetweetUncheckedCreateWithoutUsersInput>
  }

  export type RetweetUpdateWithWhereUniqueWithoutUsersInput = {
    where: RetweetWhereUniqueInput
    data: XOR<RetweetUpdateWithoutUsersInput, RetweetUncheckedUpdateWithoutUsersInput>
  }

  export type RetweetUpdateManyWithWhereWithoutUsersInput = {
    where: RetweetScalarWhereInput
    data: XOR<RetweetUpdateManyMutationInput, RetweetUncheckedUpdateManyWithoutUsersInput>
  }

  export type TweetLikeUpsertWithWhereUniqueWithoutUsersInput = {
    where: TweetLikeWhereUniqueInput
    update: XOR<TweetLikeUpdateWithoutUsersInput, TweetLikeUncheckedUpdateWithoutUsersInput>
    create: XOR<TweetLikeCreateWithoutUsersInput, TweetLikeUncheckedCreateWithoutUsersInput>
  }

  export type TweetLikeUpdateWithWhereUniqueWithoutUsersInput = {
    where: TweetLikeWhereUniqueInput
    data: XOR<TweetLikeUpdateWithoutUsersInput, TweetLikeUncheckedUpdateWithoutUsersInput>
  }

  export type TweetLikeUpdateManyWithWhereWithoutUsersInput = {
    where: TweetLikeScalarWhereInput
    data: XOR<TweetLikeUpdateManyMutationInput, TweetLikeUncheckedUpdateManyWithoutUsersInput>
  }

  export type chatusersUpsertWithWhereUniqueWithoutUsersInput = {
    where: chatusersWhereUniqueInput
    update: XOR<chatusersUpdateWithoutUsersInput, chatusersUncheckedUpdateWithoutUsersInput>
    create: XOR<chatusersCreateWithoutUsersInput, chatusersUncheckedCreateWithoutUsersInput>
  }

  export type chatusersUpdateWithWhereUniqueWithoutUsersInput = {
    where: chatusersWhereUniqueInput
    data: XOR<chatusersUpdateWithoutUsersInput, chatusersUncheckedUpdateWithoutUsersInput>
  }

  export type chatusersUpdateManyWithWhereWithoutUsersInput = {
    where: chatusersScalarWhereInput
    data: XOR<chatusersUpdateManyMutationInput, chatusersUncheckedUpdateManyWithoutUsersInput>
  }

  export type messagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsersInput, messagesUncheckedUpdateWithoutUsersInput>
    create: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsersInput, messagesUncheckedUpdateWithoutUsersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedUpdateWithoutUsers_notifications_actorIdTousersInput>
    create: XOR<notificationsCreateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_actorIdTousersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsers_notifications_actorIdTousersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsers_notifications_actorIdTousersInput, notificationsUncheckedUpdateWithoutUsers_notifications_actorIdTousersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsers_notifications_actorIdTousersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsers_notifications_userIdTousersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedUpdateWithoutUsers_notifications_userIdTousersInput>
    create: XOR<notificationsCreateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedCreateWithoutUsers_notifications_userIdTousersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsers_notifications_userIdTousersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsers_notifications_userIdTousersInput, notificationsUncheckedUpdateWithoutUsers_notifications_userIdTousersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsers_notifications_userIdTousersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersInput>
  }

  export type tweetbookmarksUpsertWithWhereUniqueWithoutUsersInput = {
    where: tweetbookmarksWhereUniqueInput
    update: XOR<tweetbookmarksUpdateWithoutUsersInput, tweetbookmarksUncheckedUpdateWithoutUsersInput>
    create: XOR<tweetbookmarksCreateWithoutUsersInput, tweetbookmarksUncheckedCreateWithoutUsersInput>
  }

  export type tweetbookmarksUpdateWithWhereUniqueWithoutUsersInput = {
    where: tweetbookmarksWhereUniqueInput
    data: XOR<tweetbookmarksUpdateWithoutUsersInput, tweetbookmarksUncheckedUpdateWithoutUsersInput>
  }

  export type tweetbookmarksUpdateManyWithWhereWithoutUsersInput = {
    where: tweetbookmarksScalarWhereInput
    data: XOR<tweetbookmarksUpdateManyMutationInput, tweetbookmarksUncheckedUpdateManyWithoutUsersInput>
  }

  export type tweetsUpsertWithWhereUniqueWithoutUsersInput = {
    where: tweetsWhereUniqueInput
    update: XOR<tweetsUpdateWithoutUsersInput, tweetsUncheckedUpdateWithoutUsersInput>
    create: XOR<tweetsCreateWithoutUsersInput, tweetsUncheckedCreateWithoutUsersInput>
  }

  export type tweetsUpdateWithWhereUniqueWithoutUsersInput = {
    where: tweetsWhereUniqueInput
    data: XOR<tweetsUpdateWithoutUsersInput, tweetsUncheckedUpdateWithoutUsersInput>
  }

  export type tweetsUpdateManyWithWhereWithoutUsersInput = {
    where: tweetsScalarWhereInput
    data: XOR<tweetsUpdateManyMutationInput, tweetsUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersCreateWithoutDevice_recordInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    old_passwords?: OldPasswordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDevice_recordInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    old_passwords?: OldPasswordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDevice_recordInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDevice_recordInput, usersUncheckedCreateWithoutDevice_recordInput>
  }

  export type usersUpsertWithoutDevice_recordInput = {
    update: XOR<usersUpdateWithoutDevice_recordInput, usersUncheckedUpdateWithoutDevice_recordInput>
    create: XOR<usersCreateWithoutDevice_recordInput, usersUncheckedCreateWithoutDevice_recordInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDevice_recordInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDevice_recordInput, usersUncheckedUpdateWithoutDevice_recordInput>
  }

  export type usersUpdateWithoutDevice_recordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    old_passwords?: OldPasswordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDevice_recordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    old_passwords?: OldPasswordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutOld_passwordsInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeCreateNestedManyWithoutUsersInput
    chatusers?: chatusersCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksCreateNestedManyWithoutUsersInput
    tweets?: tweetsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOld_passwordsInput = {
    id?: string
    name?: string | null
    username: string
    email: string
    is_email_verified?: boolean
    password: string
    saltPassword: string
    otp?: number | null
    otpExpiry?: Date | string | null
    tfa_verifed?: boolean
    bio?: string | null
    dateOfBirth: Date | string
    joinDate?: Date | string
    verified?: boolean
    address?: string | null
    website?: string | null
    protectedAccount?: boolean
    profilePhoto?: string | null
    cover?: string | null
    provider?: string | null
    login_codes?: string | null
    login_codes_set?: boolean
    device_record?: DeviceRecordUncheckedCreateNestedManyWithoutUserInput
    Block_Block_blockedIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockedIdTousersInput
    Block_Block_blockerIdTousers?: BlockUncheckedCreateNestedManyWithoutUsers_Block_blockerIdTousersInput
    Follow_Follow_followerIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followerIdTousersInput
    Follow_Follow_followingIdTousers?: FollowUncheckedCreateNestedManyWithoutUsers_Follow_followingIdTousersInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionedIdTousersInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedCreateNestedManyWithoutUsers_Mention_mentionerIdTousersInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_mutedIdTousersInput
    Mute_Mute_muterIdTousers?: MuteUncheckedCreateNestedManyWithoutUsers_Mute_muterIdTousersInput
    Retweet?: RetweetUncheckedCreateNestedManyWithoutUsersInput
    TweetLike?: TweetLikeUncheckedCreateNestedManyWithoutUsersInput
    chatusers?: chatusersUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_actorIdTousersInput
    notifications_notifications_userIdTousers?: notificationsUncheckedCreateNestedManyWithoutUsers_notifications_userIdTousersInput
    tweetbookmarks?: tweetbookmarksUncheckedCreateNestedManyWithoutUsersInput
    tweets?: tweetsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOld_passwordsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOld_passwordsInput, usersUncheckedCreateWithoutOld_passwordsInput>
  }

  export type usersUpsertWithoutOld_passwordsInput = {
    update: XOR<usersUpdateWithoutOld_passwordsInput, usersUncheckedUpdateWithoutOld_passwordsInput>
    create: XOR<usersCreateWithoutOld_passwordsInput, usersUncheckedCreateWithoutOld_passwordsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOld_passwordsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOld_passwordsInput, usersUncheckedUpdateWithoutOld_passwordsInput>
  }

  export type usersUpdateWithoutOld_passwordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOld_passwordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_email_verified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    saltPassword?: StringFieldUpdateOperationsInput | string
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    otpExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tfa_verifed?: BoolFieldUpdateOperationsInput | boolean
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    protectedAccount?: BoolFieldUpdateOperationsInput | boolean
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes?: NullableStringFieldUpdateOperationsInput | string | null
    login_codes_set?: BoolFieldUpdateOperationsInput | boolean
    device_record?: DeviceRecordUncheckedUpdateManyWithoutUserNestedInput
    Block_Block_blockedIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersNestedInput
    Block_Block_blockerIdTousers?: BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersNestedInput
    Follow_Follow_followerIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersNestedInput
    Follow_Follow_followingIdTousers?: FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersNestedInput
    Mention_Mention_mentionedIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersNestedInput
    Mention_Mention_mentionerIdTousers?: MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersNestedInput
    Mute_Mute_mutedIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersNestedInput
    Mute_Mute_muterIdTousers?: MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutUsersNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutUsersNestedInput
    chatusers?: chatusersUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    notifications_notifications_actorIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersNestedInput
    notifications_notifications_userIdTousers?: notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutUsersNestedInput
    tweets?: tweetsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type chatusersCreateManyChatsInput = {
    id: string
    userId: string
  }

  export type messagesCreateManyChatsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
  }

  export type chatusersUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutChatusersNestedInput
  }

  export type chatusersUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatusersUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type messagesUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUpdateManyWithoutMessagesNestedInput
    users?: usersUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
  }

  export type tweetHashesCreateManyHashesInput = {
    tweetId: string
  }

  export type tweetHashesUpdateWithoutHashesInput = {
    tweets?: tweetsUpdateOneRequiredWithoutTweetHashesNestedInput
  }

  export type tweetHashesUncheckedUpdateWithoutHashesInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetHashesUncheckedUpdateManyWithoutHashesInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaCreateManyMediasInput = {
    messageId: string
  }

  export type TweetMediaCreateManyMediasInput = {
    tweetId: string
  }

  export type MessageMediaUpdateWithoutMediasInput = {
    messages?: messagesUpdateOneRequiredWithoutMessageMediaNestedInput
  }

  export type MessageMediaUncheckedUpdateWithoutMediasInput = {
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaUncheckedUpdateManyWithoutMediasInput = {
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaUpdateWithoutMediasInput = {
    tweets?: tweetsUpdateOneRequiredWithoutTweetMediaNestedInput
  }

  export type TweetMediaUncheckedUpdateWithoutMediasInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaUncheckedUpdateManyWithoutMediasInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaCreateManyMessagesInput = {
    mediaId: string
  }

  export type MessageMediaUpdateWithoutMessagesInput = {
    medias?: mediasUpdateOneRequiredWithoutMessageMediaNestedInput
  }

  export type MessageMediaUncheckedUpdateWithoutMessagesInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageMediaUncheckedUpdateManyWithoutMessagesInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionCreateManyTweetsInput = {
    mentionerId: string
    mentionedId: string
  }

  export type RetweetCreateManyTweetsInput = {
    userId: string
  }

  export type TweetLikeCreateManyTweetsInput = {
    userId: string
  }

  export type TweetMediaCreateManyTweetsInput = {
    mediaId: string
  }

  export type notificationsCreateManyTweetsInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    actorId?: string | null
  }

  export type tweetHashesCreateManyTweetsInput = {
    hashId: string
  }

  export type tweetbookmarksCreateManyTweetsInput = {
    id: string
    userId: string
  }

  export type tweetsCreateManyTweetsInput = {
    id: string
    userId: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
  }

  export type MentionUpdateWithoutTweetsInput = {
    users_Mention_mentionedIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionedIdTousersNestedInput
    users_Mention_mentionerIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionerIdTousersNestedInput
  }

  export type MentionUncheckedUpdateWithoutTweetsInput = {
    mentionerId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionUncheckedUpdateManyWithoutTweetsInput = {
    mentionerId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetUpdateWithoutTweetsInput = {
    users?: usersUpdateOneRequiredWithoutRetweetNestedInput
  }

  export type RetweetUncheckedUpdateWithoutTweetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetUncheckedUpdateManyWithoutTweetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeUpdateWithoutTweetsInput = {
    users?: usersUpdateOneRequiredWithoutTweetLikeNestedInput
  }

  export type TweetLikeUncheckedUpdateWithoutTweetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeUncheckedUpdateManyWithoutTweetsInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaUpdateWithoutTweetsInput = {
    medias?: mediasUpdateOneRequiredWithoutTweetMediaNestedInput
  }

  export type TweetMediaUncheckedUpdateWithoutTweetsInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetMediaUncheckedUpdateManyWithoutTweetsInput = {
    mediaId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_notifications_actorIdTousers?: usersUpdateOneWithoutNotifications_notifications_actorIdTousersNestedInput
    users_notifications_userIdTousers?: usersUpdateOneRequiredWithoutNotifications_notifications_userIdTousersNestedInput
  }

  export type notificationsUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tweetHashesUpdateWithoutTweetsInput = {
    hashes?: hashesUpdateOneRequiredWithoutTweetHashesNestedInput
  }

  export type tweetHashesUncheckedUpdateWithoutTweetsInput = {
    hashId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetHashesUncheckedUpdateManyWithoutTweetsInput = {
    hashId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutTweetbookmarksNestedInput
  }

  export type tweetbookmarksUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksUncheckedUpdateManyWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetsUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
    users?: usersUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateManyWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
  }

  export type DeviceRecordCreateManyUserInput = {
    id?: number
    city?: string | null
    region?: string | null
    country?: string | null
    locale?: string | null
    lat?: number | null
    lon?: number | null
    zipcode?: string | null
    last_login?: Date | string | null
    browser?: string | null
  }

  export type OldPasswordCreateManyUserInput = {
    id?: number
    password: string
  }

  export type BlockCreateManyUsers_Block_blockedIdTousersInput = {
    blockerId: string
  }

  export type BlockCreateManyUsers_Block_blockerIdTousersInput = {
    blockedId: string
  }

  export type FollowCreateManyUsers_Follow_followerIdTousersInput = {
    followingId: string
    status?: $Enums.FollowStatus
  }

  export type FollowCreateManyUsers_Follow_followingIdTousersInput = {
    followerId: string
    status?: $Enums.FollowStatus
  }

  export type MentionCreateManyUsers_Mention_mentionedIdTousersInput = {
    tweetId: string
    mentionerId: string
  }

  export type MentionCreateManyUsers_Mention_mentionerIdTousersInput = {
    tweetId: string
    mentionedId: string
  }

  export type MuteCreateManyUsers_Mute_mutedIdTousersInput = {
    muterId: string
  }

  export type MuteCreateManyUsers_Mute_muterIdTousersInput = {
    mutedId: string
  }

  export type RetweetCreateManyUsersInput = {
    tweetId: string
  }

  export type TweetLikeCreateManyUsersInput = {
    tweetId: string
  }

  export type chatusersCreateManyUsersInput = {
    id: string
    chatId: string
  }

  export type messagesCreateManyUsersInput = {
    id: string
    chatId: string
    content: string
    createdAt?: Date | string
    status?: $Enums.MessageStatus
  }

  export type notificationsCreateManyUsers_notifications_actorIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
    tweetId?: string | null
  }

  export type notificationsCreateManyUsers_notifications_userIdTousersInput = {
    id: string
    type: $Enums.NotificationType
    content: string
    isRead?: boolean
    createdAt?: Date | string
    tweetId?: string | null
    actorId?: string | null
  }

  export type tweetbookmarksCreateManyUsersInput = {
    id: string
    tweetId: string
  }

  export type tweetsCreateManyUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    likesCount?: number
    retweetCount?: number
    repliesCount?: number
    parentId?: string | null
    tweetType: $Enums.TweetType
    replyControl?: $Enums.ReplyControl
  }

  export type DeviceRecordUpdateWithoutUserInput = {
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OldPasswordUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OldPasswordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OldPasswordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUpdateWithoutUsers_Block_blockedIdTousersInput = {
    users_Block_blockerIdTousers?: usersUpdateOneRequiredWithoutBlock_Block_blockerIdTousersNestedInput
  }

  export type BlockUncheckedUpdateWithoutUsers_Block_blockedIdTousersInput = {
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUncheckedUpdateManyWithoutUsers_Block_blockedIdTousersInput = {
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUpdateWithoutUsers_Block_blockerIdTousersInput = {
    users_Block_blockedIdTousers?: usersUpdateOneRequiredWithoutBlock_Block_blockedIdTousersNestedInput
  }

  export type BlockUncheckedUpdateWithoutUsers_Block_blockerIdTousersInput = {
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUncheckedUpdateManyWithoutUsers_Block_blockerIdTousersInput = {
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpdateWithoutUsers_Follow_followerIdTousersInput = {
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
    users_Follow_followingIdTousers?: usersUpdateOneRequiredWithoutFollow_Follow_followingIdTousersNestedInput
  }

  export type FollowUncheckedUpdateWithoutUsers_Follow_followerIdTousersInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type FollowUncheckedUpdateManyWithoutUsers_Follow_followerIdTousersInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type FollowUpdateWithoutUsers_Follow_followingIdTousersInput = {
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
    users_Follow_followerIdTousers?: usersUpdateOneRequiredWithoutFollow_Follow_followerIdTousersNestedInput
  }

  export type FollowUncheckedUpdateWithoutUsers_Follow_followingIdTousersInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type FollowUncheckedUpdateManyWithoutUsers_Follow_followingIdTousersInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    status?: EnumFollowStatusFieldUpdateOperationsInput | $Enums.FollowStatus
  }

  export type MentionUpdateWithoutUsers_Mention_mentionedIdTousersInput = {
    users_Mention_mentionerIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionerIdTousersNestedInput
    tweets?: tweetsUpdateOneRequiredWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateWithoutUsers_Mention_mentionedIdTousersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionerId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionUncheckedUpdateManyWithoutUsers_Mention_mentionedIdTousersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionerId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionUpdateWithoutUsers_Mention_mentionerIdTousersInput = {
    users_Mention_mentionedIdTousers?: usersUpdateOneRequiredWithoutMention_Mention_mentionedIdTousersNestedInput
    tweets?: tweetsUpdateOneRequiredWithoutMentionNestedInput
  }

  export type MentionUncheckedUpdateWithoutUsers_Mention_mentionerIdTousersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type MentionUncheckedUpdateManyWithoutUsers_Mention_mentionerIdTousersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
    mentionedId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteUpdateWithoutUsers_Mute_mutedIdTousersInput = {
    users_Mute_muterIdTousers?: usersUpdateOneRequiredWithoutMute_Mute_muterIdTousersNestedInput
  }

  export type MuteUncheckedUpdateWithoutUsers_Mute_mutedIdTousersInput = {
    muterId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteUncheckedUpdateManyWithoutUsers_Mute_mutedIdTousersInput = {
    muterId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteUpdateWithoutUsers_Mute_muterIdTousersInput = {
    users_Mute_mutedIdTousers?: usersUpdateOneRequiredWithoutMute_Mute_mutedIdTousersNestedInput
  }

  export type MuteUncheckedUpdateWithoutUsers_Mute_muterIdTousersInput = {
    mutedId?: StringFieldUpdateOperationsInput | string
  }

  export type MuteUncheckedUpdateManyWithoutUsers_Mute_muterIdTousersInput = {
    mutedId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetUpdateWithoutUsersInput = {
    tweets?: tweetsUpdateOneRequiredWithoutRetweetNestedInput
  }

  export type RetweetUncheckedUpdateWithoutUsersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type RetweetUncheckedUpdateManyWithoutUsersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeUpdateWithoutUsersInput = {
    tweets?: tweetsUpdateOneRequiredWithoutTweetLikeNestedInput
  }

  export type TweetLikeUncheckedUpdateWithoutUsersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type TweetLikeUncheckedUpdateManyWithoutUsersInput = {
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type chatusersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chats?: chatsUpdateOneRequiredWithoutChatusersNestedInput
  }

  export type chatusersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type chatusersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type messagesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUpdateManyWithoutMessagesNestedInput
    chats?: chatsUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    MessageMedia?: MessageMediaUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
  }

  export type notificationsUpdateWithoutUsers_notifications_actorIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: tweetsUpdateOneWithoutNotificationsNestedInput
    users_notifications_userIdTousers?: usersUpdateOneRequiredWithoutNotifications_notifications_userIdTousersNestedInput
  }

  export type notificationsUncheckedUpdateWithoutUsers_notifications_actorIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutUsers_notifications_actorIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsUpdateWithoutUsers_notifications_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_notifications_actorIdTousers?: usersUpdateOneWithoutNotifications_notifications_actorIdTousersNestedInput
    tweets?: tweetsUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateWithoutUsers_notifications_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutUsers_notifications_userIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tweetbookmarksUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweets?: tweetsUpdateOneRequiredWithoutTweetbookmarksNestedInput
  }

  export type tweetbookmarksUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetbookmarksUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
  }

  export type tweetsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUpdateManyWithoutTweetsNestedInput
    tweets?: tweetsUpdateOneWithoutOther_tweetsNestedInput
    other_tweets?: tweetsUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
    Mention?: MentionUncheckedUpdateManyWithoutTweetsNestedInput
    Retweet?: RetweetUncheckedUpdateManyWithoutTweetsNestedInput
    TweetLike?: TweetLikeUncheckedUpdateManyWithoutTweetsNestedInput
    TweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetsNestedInput
    TweetSummary?: TweetSummaryUncheckedUpdateOneWithoutTweetsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutTweetsNestedInput
    tweetHashes?: tweetHashesUncheckedUpdateManyWithoutTweetsNestedInput
    tweetbookmarks?: tweetbookmarksUncheckedUpdateManyWithoutTweetsNestedInput
    other_tweets?: tweetsUncheckedUpdateManyWithoutTweetsNestedInput
  }

  export type tweetsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    retweetCount?: IntFieldUpdateOperationsInput | number
    repliesCount?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetType?: EnumTweetTypeFieldUpdateOperationsInput | $Enums.TweetType
    replyControl?: EnumReplyControlFieldUpdateOperationsInput | $Enums.ReplyControl
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}